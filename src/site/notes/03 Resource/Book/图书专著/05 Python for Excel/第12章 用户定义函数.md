---
{"dg-publish":true,"dg-permalink":"books/35799208/12","permalink":"/books/35799208/12/","metatags":{"description":"本章涉及了 pandas 中用于分析数据集的一些新的概念和工具。我们学习了如何读取 CSV 文件，如何处理缺失或重复的数据，如何利用描述性统计量，也见识到了将 DataFrame 转化为交互式图表有多简单。虽然你可能需要一些时间来消化这些知识，但是应该很快就能体会到 pandas 带来的强大力量。本章对 pandas 和 Excel 的 AutoFilter 功能、VLOOKUP 公式、数据透视表、PowerQuery 进行了对比。","og:site_name":"DavonOs","og:title":"Excel Python","og:type":"book","og:url":"https://zuji.eu.org/books/35799208/12","og:image":"https://file.ituring.com.cn/LargeCover/22038dc37469788a2ed5","og:image:width":"50","og:image:alt":"bookcover"},"created":"2025-09-24 14:43","updated":"2025-09-26 16:25"}
---

# 12.1 UDF 入门

在使用 quickstart 命令运行我们的第一个 UDF 之前，首先介绍一下事前准备。为了能够跟上本章中的示例，你需要安装好 xlwings 插件，并启用 Excel 的“信任 VBA 项目对象模型”选项。

插件

假定你已经像第 10 章讲的那样安装好了 xlwings 插件。不过，这并非硬性要求：虽然这个插件可以方便我们的开发——特别是点击 Import Function（导入函数）按钮，但是对于部署过程来说它并不是必要的，可以在独立模式中通过设置工作簿来替换它。更详细的操作请参见第 10 章。

信任 VBA 项目对象模型

要编写你的第一个 UDF，需要修改 Excel 的一项设置：进入“文件（File）>选项（Options）>信任中心（Trust Center）>信任中心设置（Trust Center Settings）>宏设置（Macro Settings）”菜单项中，勾选“信任 VBA 项目对象模型”（Trust access to the VBA project object model），如图 12- 1 所示。这样 xlwings 就可以在点击插件的 Import Function 按钮后自动将 VBA 模块插入工作簿中，很快你就会看到这样的操作是如何完成的。由于仅在导入过程中才需要这项设置，因此应将其视为最终用户无须担心的一项开发者设置。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/5dacbcc7377713112762678fb0a80b38b287fa69a1954dad7ecbe1ef4b60376c.jpg)  
图 12-1：信任 VBA 项目对象模型

完成这两项准备工作之后，就可以运行你的第一个 UDF 了。

# UDF Quickstart

和 xlwings 的其他功能一样，创建 UDF 的最简单办法就是从 quickstart 命令开始。在 Anaconda Prompt 中执行下面的命令之前，务必通过 cd 命令切换到你所选的工作目录。如果你现在位于 home 目录中，想要切换到桌面，那么首先需要执行 cd Desktop：

# (base)> xlwings quickstart first_udf

从文件浏览器中进入 first_udf 文件夹，在 Excel 中打开 first_udf. xlsm 文件，同时在 VS Code 中打开 first_udf. py。然后在 xlwings 功能区插件中点击 Import Function 按钮。在默认情况下这个过程是静默的，也就是说只要没有错误你就看不到任何提示内容。不过，

如果你勾选了 Excel 插件中的 ShowConsole（显示控制台）选项，然后再次点击 ImportFunctions 按钮，就会在打开的命令提示符中看到下面的内容：

xlwings server running [...] Imported functions from the following modules: first_udf

第一行打印了一些细节，不过可以忽略它们。最重要的是打印出这一行内容之后，Python 就启动了。第二行确认从 first_udf 模块中正常导入了函数。现在在 first_udf. xlsm 的活动工作表的 A 1 单元格中输入=hello ("xlwings")，然后按回车键，如图 12- 2 所示，你会看到公式求值后的结果。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/37a48f6ee6b26389937284c6f399e04a69fd219ce786af88e754baa23ad31b92.jpg)  
图 12-2：first_udf. xlsm

下面来逐步分析一下 UDF 的工作原理：首先看到 first_udf. py（参见例 12- 1）中的 hello 函数，此前我们一直忽略了 quickstart 的这部分代码。

# 例 12-1 first_udf. py（节选）

import xlwings as xw @xw. func def hello (name): return f"Hello {name}!"

在点击 xlwings 插件的 ImportFunctions 按钮时，所有被@xw. func 标记的函数都会被导入 Excel 中。导入之后你便可以在 Excel 中将其用作单元格公式，其中的技术细节马上就会讲到。@xw. func 是一个装饰器，这就意味着你必须把它放到函数定义的上方。如果想详细了解装饰器的工作原理，可以参见“函数装饰器”。

# 函数装饰器

装饰器是放在函数定义上面的一个函数名且开头有@符号。这是一种改变函数行为的便捷方式，xlwings 利用装饰器来识别你想在 Excel 中使用的函数。为了帮助你理解装饰器的工作方式，下面的例子展示了一个叫作 verbose 的装饰器，它会在 print_hello 函数执行前和执行后打印一些文本。从技术上来说，装饰器会将函数（print_hello）作为实参传递给 verbose 函数的 func 参数。verbose 函数内部的 wrapper 函数随后可以进行必要的工作。在本例中，就是在调用 print_hello 函数前后各打印一个值。内部函数的名称可以随意命名：

In[1]： #函数装饰器的定义def verbose (func): def wrapper (): print ("Before calling the function.") func () print ("After calling the function.") return wrapperIn[2]: #使用函数装饰器 @verbosedef print_hello (): print ("hello!") In[3]: #调用被装饰函数的效果print_hello () Before calling the function. hello! After calling the function.

你可以在本章结尾处的表 12- 1 中看到对 xlwings 提供的所有装饰器的总结。

在默认情况下，如果函数参数是单元格区域，那么 xlwings 就会将单元格区域的值而不是 xlwings 的 range 对象传递给你。在大部分时候这是很方便的，你可以利用单元格为参数来调用 hello 函数。例如，可以将“xlwings”写入 A 2 单元格，然后将 A 1 的公式改成下面这样：

=hello (A 2)

其结果和图 12- 2 是一样的。12.3 节会向你展示如何修改这种行为，使得参数以 xlwingsrange 对象形式传递。届时你就会明白，在有些情况下需要这样做。在 VBA 中，等效的 hello 函数看起来像下面这样：

Function hello (name As String) As Stringhello  $=$  "Hello"&name&!"End Function

点击插件上的 Import Functions 按钮之后，xlwings 会在你的 Excel 工作簿中插入一个名为 xlwings_udfs 的 VBA 模块。这个模块中保存了每一个导入的 Python 函数生成的 VBA 函数：这些 VBA 函数包装器负责执行对应的 Python 函数。虽然也可以按快捷键 Alt+F 11 打开 xlwings_udfs 看一下里面的内容，但是你完全可以忽略它们，因为这些代码都是自动生成的，每次点击 Import Functions 按钮时，所有的更改都会丢失。现在来用 first_udf. py 中的 hello 函数测试一下，把返回值中的 Hello 换成 Bye：

@xw. func def hello (name): return f"Bye {name}!"

要在 Excel 中重新计算函数，可以双击 A 1 单元格编辑公式（或者选中单元格，按 F 2 键激活编辑模式），然后按回车键。也可以按键盘快捷键 Ctrl+Alt+F 9：这个快捷键会强制重新

计算所有已打开的工作簿中的所有工作表，且包括 hello 公式。注意，F 9 键（重新计算所有已打开的工作簿中的所有工作表）或快捷键 Shift+F 9（重新计算活动工作表）并不会重新计算 UDF，因为只有在依赖单元格发生改变时 Excel 才会重新计算 UDF。要改变这种行为，可以为 func 装饰器添加对应的参数以使函数具有易失性：

@xw. func（volatile  $=$  True) def hello (name): return f"Bye {name}!"

每次 Excel 执行重新计算时，易失性函数都会求值，无论函数的依赖项是否发生改变。有一些 Excel 内置函数就是易失的，比如  $= \text{RAND()}$  或  $= \text{NOW()}$  。大量使用这些函数会导致工作簿变慢，所以应避免过度使用。如果修改了函数名、参数，或者像上面那样修改了 func 装饰器，那么在这些情况下需要点击 Import Functions 按钮重新导入函数：Python 解释器会重启并导入更新后的函数。如果现在把 Bye 改回 Hello，则只需使用键盘快捷键 Shift+F 9 或者 F 9 键重新计算公式即可，因为函数已经是易失性函数了。

# 在修改 Python 文件后记得保存

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/2b2ac585dcc67d7aad51f710c9c5e8c163cdc60e93bdc226ffa79f8bc061b9c4.jpg)

在修改 Python 源文件之后忘记保存是一个常见的失误。因此，在按下 Import Functions 按钮或者重新计算 Excel 中的 UDF 之前一定要再次检查 Python 文件是否已经保存。

在默认情况下，xlwings 会在 Excel 文件所在目录从同名 Python 文件中导入函数。重命名和移动 Python 源文件需要做与第 10 章提到过的类似的更改，即和 RunPython 调用一样，将 first_udf. py 改成 hello. py。为了让 xlwings 知道发生了改变，需要将模块名称（hello，不带. py 扩展名）添加到 xlwings 插件的 UDF Modules 中，如图 12- 3 所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/e532d1874a4b66bf37aa87e831e4112519658c0f3158d5570f07db423981f8b3.jpg)  
图 12-3：UDF 模块设置

点击 Import Functions 按钮重新导入该函数。然后重新计算 Excel 的公式，确认一切照常工作。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/7b817a734f9a3df5302a6aea146a1eaaa58585af81ba0b0afeea974b30bb77cf.jpg)

# 从多个 Python 模块中导入函数

如果你想从多个模块中导入函数，那么可以在 UDF Module 设置中用分号分隔多个模块名，比如 hello; another_module。

现在将 hello. py 移动到桌面上：此时你需要将桌面的路径添加到 xlwings 插件的 PYTHONPATH 中。正如在第 10 章中看到的那样，也可以通过环境变量来实现，也就是说将插件中的 PYTHONPATH 设置为 %USERPROFILE%Desktop。如果 PYTHONPATH 中还留有第 10 章的 pyscripts 文件夹，则可以直接覆盖，或者不去管它，多个路径之间用分号分隔就行了。完成这些改动之后，再次点击 Import Functions 按钮，重新计算 Excel 中的函数，检查一切是否照常工作。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/810a0af5050b2161f5f54b42bccceebd5f9f220bd853b333883f2e337bf14b50.jpg)

# 配置和部署

本章一直在讲修改插件的设置，但是第 10 章中有关配置和部署的内容对本章也是适用的。也就是说，可以在 xlwings. conf 工作表或者 Excel 文件所在目录的配置文件中修改设置。如果不使用 xlwings 插件，那么也可以使用处于独立模式中的工作簿。使用 UDF 时，你还可以构建自己的自定义插件，这样就可以让所有工作簿共享 UDF 而不用分别导入。有关构建自定义插件的更多内容，请参见 xlwings 文档。

如果你修改了 UDF 的 Python 代码，则 xlwings 会在保存 Python 文件时跟进所有更改。正如前面提到的那样，如果你修改了函数名、参数、装饰器等内容，则只需要重新导入 UDF。但是如果你的源文件导入了其他模块的代码，而这些模块的内容也发生了更改，那么让 Excel 跟进所有更改的最简单办法是点击 Restart UDF Server（重启 UDF 服务器）。

现在你已经知道如何用 Python 编写一个简单的 UDF 并将其用到 Excel 中。下一节的案例研究会向你介绍运用了 pandas DataFrame 的更为真实的 UDF。

# 12.2 案例研究：Google Trends

在本节的案例研究中，我们会先使用来自 Google Trends 的数据学习如何利用 pandas DataFrame 和动态数组（动态数组是微软在 2020 年官方发布的 Excel 最令人激动的新特性之一）。然后会创建直接连接到 Google Trends 的 UDF，以及使用 DataFrame 的 plot 方法的 UDF。最后会了解一下如何调试 UDF。下面先来简要介绍一下 Google Trends。

# 12.2.1 Google Trends 简介

Google Trends 是谷歌提供的一项服务，你可以利用它来分析某条谷歌搜索查询在不同时间和地区的受欢迎程度。图 12- 4 展示的是在添加了一些热门编程语言名称之后的 Google Trends 页面，其选定了全世界为地区，2016 年 1 月 1 日至 2020 年 12 月 26 日为时间范围。每个搜索关键词都在输入之后显示的下拉菜单中选择了 Programming language 为上下文。这样就可以忽略蟒蛇和爪哇岛。谷歌会以百分制来评价关键词在选定时间范围和位置的搜索热度。在我们的例子中，它表明在给定的时间范围和位置中，在 2016 年 2 月，Java 的

搜索热度最高。要想了解有关 Google Trends 的更多细节，可以参见其官方博客文章。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/2f72e6691486aac62c16d7dd0a9a9ec5b9ded679f5370e863a2332f1892e0af6.jpg)  
图 12-4：随时间变化的热度，数据来源：Google Trends

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/09cf762acf121a97be3a664b2e723837409039d6e055774e71e02702e4882702.jpg)

# 随机采样

Google Trends 的数据来源于随机采样，也就是说，即使你选择了和图 12- 4 同样的位置、时间范围和搜索关键词，看到的结果也可能和图片中不一样。

我按下下载按钮（参见图 12- 4）下载了 CSV 文件，并将其中的数据复制到了 quickstart 项目的 Excel 工作簿中。在下一节中，我会向你展示这个工作簿在哪里，并使用这个文件和 UDF 直接在 Excel 中分析数据。

# 12.2.2 使用 DataFrame 和动态数组

pandas DataFrame 也是 UDF 的“好伙伴”，对此你应该不会感到惊讶。为了了解 DataFrame 和 UDF 是如何协作的，并在此过程中学习动态数组，我们进入配套代码库的 udfs 目录下的 describe 文件夹中，在 Excel 中打开 describe. xlsm，在 VS Code 中打开 describe. py。这个 Excel 文件包含了来自 Google Trends 的数据，而在 Python 文件中你会看到开头有一个简单的函数，如例 12- 2 所示。

# 例 12-2 describe. py

import xlwings as xw  import pandas as pd

@ xw.func@xw.arg ("df", pd. DataFrame, index=True, header=True) def describe (df):    return df.describe ()

和之前的 quickstart 项目中的 hello 函数相比，你会注意到这里还有另一个装饰器：

@xw.arg ("df", pd. DataFrame, index=True, header=True)

arg 是 argument 的缩写，你可以在这个装饰器中应用第 9 章在介绍 xlwings 语法时提到的那些转换器和选项。换句话说，这个装饰器之于 UDF，就像 options 方法之于 xlwings 的 range 对象一样，它们提供了同样的功能。规范地说，arg 装饰器的语法如下：

@xw.arg ("argument_name", convert=None, option 1=value 1, option 2=value 2, ...)

为了帮助你和第 9 章联系起来，下面是 describe 函数的等效脚本（假定 describe. xlsm 已在 Excel 中打开且应用到了 A 3: F 263）：

import xlwings as xwimport pandas as pd

data_range = xw.Book ("describe. xlsm"), sheets[0]["A 3: F 263"]df = data_range.options (pd. DataFrame, index=True, header=True). valuedf.describe ()

index 和 header 选项并非必填参数，因为它们有默认值。这里把这两个参数包含进来是为了展示它们是如何用到 UDF 上的。当 describe. xlsm 为活动工作簿时，点击 Import Functions 按钮，在一个空单元格（如 H 3）中输入=describe (A 3: F 263)。按下回车键会发生什么取决于 Excel 的版本，尤其是当你的 Excel 版本比较新且支持动态数组的话。如果 Excel 支持动态数组，你就会看到图 12- 5 所示的情形，也就是说 describe 函数在 H 3: M 11 的输出会被蓝色边框包围。只有当光标在数组中时才能看到蓝色边框，图 12- 5 只是一张截图，因此并未显示此效果。我们马上就会看到动态数组是如何工作的，你还可以在后文的“动态数组”中了解到更多知识。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/d229bc2165e26fbaf44e26f6df7351d1cd69a6ece392ea1ab601e571c57063bb.jpg)  
图 12-5：describe 函数和动态数组

不过，如果你使用的是不支持动态数组的 Excel，那么按下按钮之后就跟什么都没发生一样：在默认情况下这个公式只会返回左上方的 H 3 单元格，这是一个空单元格。要解决这个问题，需要使用微软如今称为旧式 CSE 数组的技术。CSE 数组需要按快捷键 Ctrl+Shift+Enter，而不是只按回车键，CSE 因此而得名。下面来详细了解一下它们的工作方式。

- 选中 H 3 单元格并按下 Delete 键以确认其为空单元格。- 选择从 H 3 开始到 M 11 结束的输出区域中的所有单元格。- 选中 H 3: M 11 区域之后，输入公式=describe (A 3: F 263)，按快捷键 Ctrl+Shift+Enter 确认。

你应该会看到和图 12- 5 差不多的画面，但是有以下区别。

- 在 H 3: M 11 区域周围没有蓝色边框。- 公式被花括号包围表明它是 CSE 数组： $\{= \text{describe} (A3:F263)\}$ 。- 选中左上角单元格并按下 Delete 键即可删除动态数组，但是如果想删除 CSE 数组，则必须选中整个数组才可以。

现在来引入可选参数以使这个函数更加有用。这个名为 selection 的可选参数可以让我们指定想在输出中包含的列。如果你有很多列但是只想在 describe 函数中包含其中的一个子集，那么这就会成为一个很好用的特性。将函数做如下改动。

@xw. func @xw.arg ("df"，pd. DataFrame) def describe（df, selection  $\equiv$  None):  $=$  if selection is not None: return df. loc[:, selection]. describe（)  $=$  else: return df.describe ()

① 这里省去了 Index 参数和 header 参数，直接使用了默认值。不过你也可以保留它们。

② 添加可选参数 selection，以 None 为默认值。

③ 如果提供了 selection，则可以用它来筛选 DataFrame 的列。

函数修改完毕后，要记得保存，然后再按下 xlwings 插件上的 ImportFunctions 按钮。因为添加了新的参数，所以必须这样做。将 Selection 写入 A 2 单元格，将 TRUE 写入 B 2: F 2 单元格区域。最后，根据你的 Excel 版本是否支持动态数组，对 H 3 单元格中的公式进行相应的改动。

支持动态数组

选中 H 3 单元格，将公式修改为=describe (A 3: F 263，B 2: F 2)，按下回车键。

不支持动态数组

从 H 3 单元格开始，选中 H 3: M 11 区域，然后按下 F 2 键激活 H 3 单元格的编辑模式，将公式修改为=describe (A 3: F 263，B 2: F 2)。最后按下快捷键 Ctrl+Shift+Enter。

为了测试一下改进后的函数，把 E 2 单元格中 Java 的 TRUE 改成 FALSE 来看看会发生什么：支持动态数组时，你会看到表格神奇地缩小了一列。而使用 CSE 数组时，你会得到一列难看的 #N/A ，如图 12- 6 所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/a3e5291eaf7772ae3d2224540e49541867c23e17e879c247e130d1d711e55df9.jpg)  
图 12-6：排除一列后的动态数组（上）和 CSE 数组（下）

要避免这种问题，xlwings 可以利用返回装饰器来调整旧式 CSE 数组的大小。像下面这样添加这个装饰器：

@ xw.func@xw.arg （"df"，pd. DataFrame）@xw. ret（expand="table"）def describe（df, selection  $\equiv$  None): if selection is not None: return df. loc[:, selection]. describe () else: return df.describe()

①添加返回装饰器并设置参数 expand="table"，xlwings 会调整 CSE 数组的大小以匹配返回的 DataFrame 的维度。

在添加返回装饰器之后，保存 Python 源文件，切换至 Excel，按下快捷键 Ctrl+Alt+F 9 重新计算：CSE 数组的大小会发生变化，同时全是 #N/A的列也被移除了 。由于这只是一种妥协的做法，因此强烈建议还是尽可能地使用支持动态数组的 Excel 版本。

# 函数装饰器的顺序

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/a5c9ad587856f8548953387a49b167e86908ba7769a581639f302e080dea83a9.jpg)

函数装饰器的顺序一定要把 xw. func 装饰器放在 xw. arg 装饰器和 xw. ret 装饰器上方，不过 xw. arg 和 xw. ret 的顺序无关紧要。

返回装饰器在概念上和参数装饰器的工作方式是一样的，只不过你不必指定参数的名称。例如，返回装饰器的语法看起来是这样的：

@xw. ret（convert=None，option 1=value 1，option 2=value 2，...)

通常情况下不必显式地提供 convert 参数，因为 xlwings 会自动识别返回值类型。这和第 9 章中将值写入 Excel 所用到的 options 方法是一样的行为。

如果不想在返回的 DataFrame 中包含索引，那么可以像下面这样使用这个装饰器。

@xw.ret (index=False)

# 动态数组

动态数组见识过动态数组在 describe 函数下的工作方式后，我敢肯定你也认同动态数组是微软这么久以来为 Excel 加入的最关键、最振奋人心的功能。动态数组在 2020 年首次和使用最新版本的 Microsoft 365 订户见面。要想知道你使用的版本是否支持这项功能，可以检查 UNIQUE 函数是否存在：在单元格中输入=UNIQUE，如果 Excel 提示了这个函数名，那么就是支持动态数组的。如果你使用的是带有永久许可证的 Excel 而不是 Microsoft 365 订阅版的话，那么可能就需要获取宣称会在 2021 年发布的版本——可能叫 Office 2021。关于动态数组的行为，这里有一些技术上的要点。

·如果动态数组用一个值覆盖了一个单元格，你就会得到 #SPILL ！错误。在删除或移动发生重叠的单元格为动态数组腾出空间之后，数组就会完成写入。注意，xlwings 的带有 expand="table"的返回装饰器则没有那么智能，它会覆盖现有单元格中的值而不会发出警告！·可以使用左上角单元格地址加上 #符号来应用动态数组的一个区域 。如果你的动态数组位于 A 1: B 2，你想对所有单元格进行求和，就可以写成=SUM (A 1#)。·如果你想让动态数组表现得和旧式 CSE 数组一样，就需要在公式前加上@符号。例如，要让矩阵乘法运算返回旧式 CSE 数组，需要写成=@ #MULT ()。

对于这里这个介绍性的例子来说，下载一个 CSV 文件然后将里面的值复制并粘贴到 Excel 文件里面也没什么问题。但是复制粘贴这个过程本身就很容易出错，所以在能够避免这种操作的时候应该尽量避免。使用 GoogleTrends 的时候，你自然能够避免复制粘贴，下一节会展示应该怎样做。

# 12.2.3 从 GoogleTrends 上获取数据

12.2.3 从 Google Trends 上获取数据前面的例子没什么复杂的，基本上就是包装了一个简单的 pandas 函数。要着手操作更贴近现实的例子，需要创建一个从 Google Trends 上下载数据的 UDF，这样你就不用到网页上去手动下载 CSV 文件了。Google Trends 没有官方的 API，但是有一个叫作 pytrends 的 Python 包填补了这一空缺。非官方 API 意味着只要谷歌想修改 API，它随时都能改。所以有可能在某个时候本节中的例子就用不了了。不过，考虑到在撰写本书时 pytrends 已经面世 5 年多了，即使出现问题它也很有可能会更新修复。我在第 1 章中提到存在着万能的 Python 包，pytrends 就是一个绝佳的例子。如果你无法使用 PowerQuery，那么可能需要再投入一点儿资金才可以，至少我没能找到一种免费的即插即用的解决方案。由于 pytrends 不是 Anaconda 的一部分，也不是官方 Conda 包，如果你还没有安装的话，可以用来 pip 安装：

# (base)> pip install pytrends

为了复现图 12- 4 中网页版 GoogleTrends 的情形，需要在“Programming language”上下文中为搜索关键词找到正确的标识符。要做到这一点，pytrends 可以打印出 GoogleTrends 在下拉菜单中建议的各种搜索上下文或者类别。在下面的示例代码中，mid 代表 MachineID，这就是我们要找的 ID：

In[4]: from pytrends. request import TrendReq In[5]： #首先 ，来实例化一个 TrendRequest 对象 trend  $=$  TrendReq () In[6]： #现在就能打印出输入 "Python"后出现在 #网页版GoogleTrends下拉菜单中的那些建议 trend.suggestions ("Python") Out[6]:[{mid': '/m/05 z 1_，'title': 'Python'，'type': 'Programming language'}, {'mid': '/m/05 tb 5'，'title': 'Python family'，'type': 'Snake'}, {'mid': '/m/0 cV 6_m'，'title': 'Pythons'，'type': 'Snake'}, {'mid': '/m/06 bxxb'，'title': 'CPython'，'type': 'Topic'}, {'mid': '/g/1 q 6 j 3 gsvm'，'title': 'python'，'type': 'Topic'}]

对其他编程语言也重复这个过程以获取所有编程语言关键词的 mid，有了这些 mid 后就能编写例 12- 3 中的 UDF 了。你可以在配套代码库的 udfs 文件夹的 google_trends 目录中找到源代码。

例 12- 3 google_trends. py 中的 get_interest_over_time 函数（只摘录了相关部分的 import 语句）

import pandas as pd from pytrends. request import TrendReq import xlwings as xw

@xw.func (call_in_wizard=False) ①@xw.arg ("mids", doc="Machine IDs: A range of max 5 cells") ②@xw.arg ("start_date", doc="A date- formatted cell") ③@xw.arg ("end_date", doc="A date- formatted cell") def get_interest_over_time (mids, start_date, end_date):    """查询 Google Trends：在返回值中将常见编程语言的 Machine ID（mid）替换成人类可读的名称，例如，对于 Machine ID "/m/05 z 1_"会返回"Python""" ④# 检查并转换参数 assert len (mids) <= 5, "Too many mids (max: 5)" ⑤start_date = start_date.date (). isoformat () ⑥end_date = end_date.date (). isoformat ()# 构造 Google Trends 请求并返回 DataFrametrend = TrendReq (timeout=10) ⑦trend. build_payload (kw_list=mids, timeframe=f"{start_date} {end_date}") ⑧df = trend. interest_over_time () ⑨# 用人类可读的单词替换谷歌的 mids = {"/m/05 z 1_": "Python", "/m/02997": "JavaScript", "/m/0 jgag": "C++", "/m/07 sbkbfb": "Java", "/m/060 kv": "PHP"}df = df.rename (columns=mids) ⑩# 删去 isPartial 列 return df.drop (columns="isPartial") ⑪

① 在默认情况下，在函数向导（Function Wizard）中打开这个函数时 Excel 会调用这个函数。这个过程会很费时间，特别是当函数涉及 API 请求时，所以这里关闭了这个功能。

② 可以为函数参数添加文档字符串，在你编辑各个参数时，函数向导会显示这些内容，如图 12-8 所示。

③ 函数的文档字符串会显示在函数向导中，如图 12-8 所示。

④ 当用户提供了过多的 mid 时，可以方便地利用 assert 语句引发错误。Google Trends 允许每个查询最多有 5 个 mid。

⑤ pytrends 要求用格式为 YYYY-MM-DD 的单个字符串来表示开始日期和结束日期。由于我们用的是格式为日期的单元格来表示开始日期和结束日期，因此它们在 Python 代码中是 datetime 对象的形式。调用它们的 date 方法和 isoformat 方法可以将它们正确格式化为 pytrends 所需形式。

⑥ 此处在初始化一个 pytrends request 对象。为其将 timeout 设置为 10 秒可以降低发生 requests. exceptions. ReadTimeout 错误的风险，如果 Google Trends 花了较长时间进行响应，那么时不时就会发生这种错误。如果你依然看到了这样的错误，则可以再运行一次这个函数或者延长超时时间。

⑦ 为请求对象提供 kw_list 参数和 timeframe 参数。

$③$  通过调用 interest_over_time 执行实际的请求，它会返回一个 pandas DataFrame。

$⑨$  将 mid 重命名为人类可读的内容。

$10$  最后一列叫作 isPartial。为了保持简单性且和网页版对应，在返回 DataFrame 时会丢弃这一列。

现在打开配套代码库中的 google_trends. xlsm，点击 xlwings 插件上的 Import Functions 按钮，然后在 A 4 单元格中调用 get_interest_over_time 函数，如图 12- 7 所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/09055197ba5bffa68d09af04f13d9cc6d5f87e429b8e108567c8355d7407fc07.jpg)  
图 12-7：google_trends. xlsm

要获取各个函数参数的帮助，在选中 A 4 单元格时点击公式栏左侧的插入函数按钮，点击按钮后会打开函数向导，你可以在其中的 xlwings 分类下找到你的 UDF。在选中 get_interest_over_time 后，你会看到函数参数的名称以及作为描述的文档字符串（仅显示前 256 个字符），如图 12- 8 所示。另外，你也可以在 A 4 单元格中输入=get_interest_over_time（（这个左括号也要输进去），然后再按下插入函数按钮，这样就可以直接进入图 12- 8 所示的界面。注意，UDF 返回的日期是没有格式化的。要修复这个问题，在包含日期的列上右键单击，选择格式化单元格，然后在日期分类下选择想要的日期格式。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/7b2fdd3495c30a8754cf5c443d8ccb1dfa9a7510ed0f94858bc9197c3f9baa36.jpg)  
图 12-8：函数向导

如果仔细观察图 12- 7，看到结果数组的蓝色边框你就会明白我再次用到了动态数组。因为截图的下面部分被截断了，而数组是从最左边开始的，所以你只能看到从 A 4 单元格开始的边框的上面和右边部分，甚至从截图上也很难识别它们。如果你的 Excel 不支持动态数组，则可以通过为 get_interest_over_time 函数添加下面的返回装饰器（加在其他装饰器下面）来凑合一下：

@wx. ret（expand="table")

现在你已经知道如何处理更为复杂的 UDF，接下来看看如何通过 UDF 绘制图表。

# 12.2.4 使用 UDF 绘制图表

你可能还记得在第 5 章中，调用 DataFrame 的 plot 方法会默认返回一张 Matplotlib 的图像。在第 9 章和第 11 章中，我们已经见到了如何将这样的图像以图片形式插入 Excel 中。在使用 UDF 时，有一种更简单的方法可以生成图表。来看一下例 12- 4 中的 google_trends. py 的第二部分。

# 例 12-4 google_trends. py 中的 plot 函数（仅节选了相关的 import 语句）

import xlwings as xw import pandas as pd import matplotlib. pyplot as plt @xw. func @xw. arg（"df"，pd. DataFrame) def plot（df, name, caller): 0 plt. style. use（"seaborn"） 2 if not df. empty: 6 caller. sheet. pictures. add（df. plot（). get figure（). 4 top=caller. offset（row_offset=1). top, 5 left=caller. left, name=name, update=True) 6 return f"<Plot:{name}>" 7

1 caller 参数是 xlwings 保留的一个特殊参数：当你从 Excel 单元格调用这个函数时，它并不会被暴露给用户。caller 参数在幕后由 xlwings 给出，它代表着调用该函数的单元格（以 xlwings range 对象的形式）。有了以 range 对象表示的调用方单元格，我们就可以更方便地利用 pictures. add 的 top 参数和 left 参数来放置图表。name 参数定义了放置在 Excel 中的图片名称。

2 使用 seaborn 样式可以让图表在视觉上更具吸引力。

3 只有在 DataFrame 非空时才调用 plot 方法。在空 DataFrame 上调用 plot 方法会引发错误。

4 get_figure () 从 DataFrame 图像中返回了一个 Matplotlib 的图表对象，这正是 pictures. add 所需要的参数类型。

5 只有在你第一次插入图片时才需要 top 参数和 left 参数。这些参数会把图表放在一个方便的地方——就在调用该函数的单元格下方的一个单元格。

6 update=True 参数能够确保重复的函数调用会更新具有指定名称的既存图片，且不会修改其位置或大小。如果不设置这个参数，则 xlwings 会指出已经在 Excel 中存在同名图片。

7 虽然并不是一定要返回点儿什么，但是返回一个字符串会很方便：你可以从返回的字符串中识别出你的绘图函数在工作表中的位置。

在 google_trends. xlsm 的 H 3 单元格中，像下面这样调用 plot 函数：

=plot (A 4: F 263,"History")

如果你的 Excel 版本支持动态数组，则用 A 4# 代替 A 4: F 263 使数据源动态化，如图 12- 9 所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/7f6944d1a08999c2b640312cd4d64f129952497047e4f7bd90facc100226480f.jpg)  
图 12-9：工作中的 plot 函数

图 12- 9：工作中的 plot 函数你可能对 get_interest_over_time 函数的工作方式感觉有点儿迷惑。要想更好地理解其中的奥妙，调试代码是一种选择。下一节会向你展示如何调试 UDF 代码。

# 12.2.5 调试 UDF

调试 UDF 的一种简单方法是使用 print 函数。如果在 xlwings 插件中启用了 ShowConsole 选项，你就可以在调用 UDF 时将变量的值打印到命令提示符中。另一种更舒服的方法是使用 VSCode 的调试器，这样你既可以在断点处暂停代码，也可以一行一行地执行代码。要使用 VSCode 调试器（或者其他 IDE 的调试器），你需要做以下两件事。

1. 在 Excel 插件中，勾选 DebugUDFs（调试 UDF）多选框。这样 Excel 就不会自动启动 Python，也就是说，就像下一点中解释的那样，你需要手动启动。

2. 手动启动 PythonUDF 服务器的最简单方法是在要调试的文件底部加上下面这两行代码。我已经在配套代码库的 google_trends. py 文件中加上了它们。

if _name_ == "_main_":    xw.serve ()

你可能还记得第 11 章中讲过，这里的 if 语句可以确保仅在以脚本形式运行该文件时才执行这段代码。也就是说，如果将其作为一个模块导入，则这段代码不会运行。添加了 serve 命令之后，在 VSCode 中按下 F 5 键使其在调试模式下运行，选择“Python 文件”。一定不要点击运行文件按钮来运行这个文件，因为这样做会无视断点。

点击第 29 行行号左侧来设置一个断点。如果不熟悉如何使用 VSCode 的调试器，请参考附录 B 中对此所做的更详细的介绍。现在重新计算 A 4 单元格，你的函数调用会在断点处

暂停，进而可以检查变量的情况。在调试过程中可以多加利用 df.info ()。激活调试控制台标签页，在底部的命令提示符中输入 df.info ()，再按下回车键确认，如图 12- 10 所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/395edeb95a18b2cd0f038e3af4997d6e6397acdc6e702b75d97d2fd30edb03a7.jpg)  
图 12-10：当代码于断点处暂停时使用调试控制台

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/e780f99a75767b7b2f7a7459891bfa971ad5f8c48986cbd1997312bca1a5e993.jpg)

# 使用 VSCode 和 Anaconda 进行调试

和第 11 章中的警告一样，当你在 Windows 中第一次运行 VSCode 调试器来调试使用了 pandas 的代码时，可能会遇到一个错误：“Exception has occurred: ImportError, Unable to import required dependencies: numpy.” 这是因为调试器在 Conda 环境还未被正常激活之前就启动了。要避免这个问题，可以点击停止图标终止调试器，然后再次按下 F 5 键，在第二次启动调试器时就没有这个错误了。

如果你让程序在断点处暂停了 90 秒以上，则 Excel 会弹出窗口表示“Microsoft Excel 正在等待另一个应用程序完成 OLE 操作”。这个提示应该不会对你的调试体验造成问题，只不过你需要在完成调试之后进行确认以让它消失。要结束调试会话，点击 VSCode 的停止按钮（参见图 12- 10），并且一定要取消勾选 xlwings 功能区插件中的 Debug UDFs 选项。如果你忘记了取消勾选，那么在下一次重新计算时，这些函数会发生错误。

本节通过 Google Trends 的案例展示了最常用的 UDF 功能。下一节会讲到包括 UDF 性能在内的一些高级主题以及 xw. sub 装饰器。

# 12.3 高级 UDF 主题

12.3 高级 UDF 主题在工作簿中大量使用 UDF 可能会造成性能问题。本节首先会展示一些基础的性能优化技巧，这些技巧与第 9 章中讲到的类似，不过是用在 UDF 上的。然后会介绍缓存，这是另一种可以用在 UDF 上的性能优化技巧。在这个过程中，我们会了解到如何让函数参数以 xlwings range 对象的形式而不是值的形式传递。最后会介绍 xw. sub 装饰器。如果你只在 Windows 中工作的话，那么它可以用来代替 RunPython 调用。

# 12.3.1 基础性能优化

本节会着眼于两种性能优化技巧：最小化跨应用程序调用以及使用原始值转换器。

# 1. 最小化跨应用程序调用

1. 最小化跨应用程序调用你可能还记得第 9 章中提到过，跨应用程序调用就是指横跨 Excel 和 Python 的调用，相对较慢，所以用到的 UDF 越少越好。因此你应该尽可能地使用数组，而选用支持动态数组的 Excel 肯定会让这部分内容更加轻松。在使用 pandas DataFrame 时没什么可以出错的地方，但是对于某些公式来说你可能无法马上就想到使用数组。考虑图 12-11 中的例子，给定的 Base Fee（基本费用）加上由 Users（用户数量）乘以 Price（价格）决定的可变费用，最终得到总利润。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/32b287e4ebcfcdde8c7086a84e98e56703e28dbf96d22690be6debaea7e4e53b.jpg)  
图 12-11：单个单元格公式（左）和基于数组的公式（右）

单个单元格公式

图 12- 11 左侧的表格在 B 9 单元格中使用了公式  $=$  revenue (\ $B$  5，\ $A9，B$  8)。这个公式随后会被应用到整个 B 9: E 13 区域。这就意味着你会有 20 个调用 revenue 函数的单个单元格公式。

基于数组的公式

图 12- 11 右侧的表格使用了公式  $=$  revenue 2（H 5，G 9：G 13，H 8：K 8）。如果你的 Excel 不支持动态数组，那么就需要在 revenue 2 函数上加上装饰器 xw. ret（expand="table")；或者

选中 H 9: K 13，然后按下 F 2 键编辑公式，用快捷键 Ctrl+Shift+Enter 确认以将数组转换为旧式 CSE 数组。与单个单元格公式不同，这个版本只会调用一次 revenue 2 函数。

你可以在例 12- 5 中看到两个 UDF 的 Python 代码，源文件可以在配套代码库的 udfs 目录下的 revenues 文件夹中找到。

# 例 12-5 revenues. py

import numpy as npimport xlwings as xw@xw.funcdef revenue (base_fee, users, price):    return base_fee + users * price

@ xw.func@xw.arg ("users", np. array, ndim=2)@xw.arg ("price", np. array) def revenue 2 (base_fee, users, price):    return base_fee + users * price

如果分别修改 B 5 单元格或 H 5 单元格中的基本费用，你会发现右边的例子会比左边的快很多。Python 函数中的区别并不大，只有装饰器的参数有区别：基于数组的版本会将 users 和 prices 以 NumPy 数组的形式读入。这里唯一要注意的是，需要在参数装饰器中设置 ndim=2 才能将 users 以二维列向量的形式读取。你可能还记得 NumPy 数组类似于 DataFrame，但没有索引或标头，且只有一种数据类型。如果你需要再仔细复习一下，可以看看第 4 章。

# 2. 使用原始值

使用原始值意味着要略过 xlwings 基于 pywin 32（xlwings 在 Windows 中的依赖项）进行的数据准备和清理工作。举例来说，这就意味着你无法再直接操作 DataFrame，因为 pywin 32 不能理解 DataFrame 的数据。但是如果你使用的是列表或者 NumPy 数组，这就不成问题了。要通过原始值使用 UDF，需要在参数装饰器或者返回装饰器中使用字符串 raw 作为 convert 参数的值。这和第 9 章在 xlwings range 对象的 options 方法中使用 raw 转换器是等效的。和之前一样，在执行写入操作时你会得到巨大的速度提升。如果不使用返回装饰器，那么下面的函数在我的计算机上要慢 1/3：

import numpy as npimport xlwings as xw

@ xw.func@xw.ret ("raw") def randn (i=1000, j=1000):    """利用 NumPy 提供的 random. random 函数生成一个服从正态分布的伪随机数数组，维度为 (i, j)    """    return np.random.randn (i, j)

你可以在配套代码库的 udfs 目录下的 raw_values 文件夹中找到对应的例子。在使用 UDF 时，还有一项简单的操作可以获得性能的提升：通过缓存结果来防止重复计算。

# 12.3.2 缓存

在调用确定型（deterministic）函数（比如，给定同样的输入总是会返回同样的输出的函数）时，你可以将结果保存在缓存中：这类函数的重复调用不再需要等待缓慢的计算过程，而是可以直接利用在缓存中已经计算好的结果。最好的办法是用一个例子来解释这种机制。基本的缓存机制可以用字典来编写：

In [7]: import timeIn [8]: cache = {}def slow_sum (a, b):    key = (a, b)    if key in cache:        return cache[key]    else:        time.sleep (2)  # 休眠两秒        result = a + b        cache[key] = result        return result

在第一次调用这个函数时，cache 是空的。此时代码会执行 else 分句并主动休眠两秒来模拟缓慢的运算过程。在运算完成后、返回结果前，它会将结果加入 cache 字典中。在同一个 Python 会话中使用同样的参数再次调用这个函数时，它会在 cache 中查找结果并立即返回，而不必再次执行缓慢的运算过程。根据参数缓存结果也被称为“记忆”（memoization）。相应地，你可以看到第一次调用函数和第二次调用函数所用的时间差：

In [9]: time    slow_sum (1, 2) Wall time: 0 nsOut[10]: 3

Python 有一个内置的 tru_cache，它能让你的工作轻松不少。tru_cache 是标准库的一部分，你可以从 functools 模块中导入它。lru 代表 least recently used（最近最少使用）缓存，这意味着在丢弃存在时间最长的缓存项之前，它最多可以保存 128 个结果（默认为 128 个）。我们可以把它用在上一节的 Google Trends 的例子中。只要是在查询历史值，就可以安全地缓存结果。这不仅会让重复调用更快，也会减少发送至谷歌的请求，从而降低谷歌将我们屏蔽的概率。也就是说，如果你在短时间内发送了大量请求，那么谷歌可能会把你屏蔽。

如果要使用缓存，就需要对 get_interest_over_time 函数进行一些必要的更改。下面是修改后的函数的前几行。

from functools import lr_u_cache

import pandas as pd from pytrends. request import TrendReq import matplotlib. pyplot as plt import xlwings as xw

@lr_cache @xw. func（call_in_wizard=False) @xw. arg（"mids"，xw. Range，doc  $\equiv$  "Machine IDs: A range of max 5 cells"）@xw. arg（"start_date"，doc  $\equiv$  "A date- formatted cell") @xw. arg（"end_date"，doc  $\equiv$  "A date- formatted cell") def get_interest_over_time（mids，start_date, end_date): """查询 GoogleTrends：在返回值中将常见编程语言的 MachineID（mid) 替换成人类可读的名称，例如，对于 MachineID"/m/05 z 1_"会返回"Python" mids  $=$  mids. value

导入 lr_u_cache 装饰器。

使用装饰器，必须将其放在 xw. func 上面。

在默认情况下，mids 是一个列表。在本例中这会造成一个问题，因为以列表为参数的函数无法进行缓存。根本的问题在于列表是可变对象，它们无法用作字典的键，可以参见附录 C 了解更多关于可变与不可变对象的内容。使用 xw. Range 转换器可以将 mids 以 xlwingsrange 对象而不是列表的形式返回，这样就解决了问题。

4 为了使剩余部分的代码依然能够工作，现在需要通过 xlwingsrange 对象的 value 属性来获取值。

# 不同 Python 版本中的缓存

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/8c1e0db359494ea7dc05b97289ad37c7aa8f4d01cfc531b47e57fbbb39889529.jpg)

如果你的 Python 版本低于 3.8，则必须在使用装饰器时带上圆括号，就像这样：@lr_u_cache ()。如果你使用的是 Python 3.9 或者更高的版本，则需要将@lr_u_cache 换成@cache，这和@lr_u_cache（maxsize=None）是一样的，也就是说缓存永远不会丢弃存在时间较长的值。cache 装饰器也需要从 functools 中导入。

xw. Range 转换器在其他一些场景中也很有用，比如在你需要获取单元格的公式而不是 UDF 的值的时候。在前面的例子中，你可以用 mids. formula 来获取单元格的公式。你可以在配套代码库的 udfs 目录下的 google_trends_cache 文件夹中找到完整的示例。

现在你已经知道如何优化 UDF 的性能，最后再来介绍一下 xw. sub 装饰器。

# 12.3.3 sub 装饰器

12.3.3 sub 装饰器第 10 章展示过如何通过激活 Use UDF Server 选项来加速 RunPython 调用。如果你只使用 Windows，则可以通过 xw. sub 装饰器来替代 RunPython 和 Use UDF Server 选项。这个装饰器可以将 Python 函数以子程序的形式导入 Excel，而不需要手动编写任何 RunPython 调用。在 Excel 中，只有子程序才能附加到按钮上，通过 xw. func 装饰器得到的 Excel 函数则不行。为了尝试一下这个装饰器，来创建一个叫作 importsub 的 quickstart 项目。和往常一样，首先通过 cd 命令移动到你想创建项目的目录下：

(base)> xlwings quickstart importsub

在文件资源管理器中，进入 importsub 文件夹，在 Excel 中打开 importsub. xlsm，在 VSCode 中打开 importsub. py。然后像例 12- 6 那样用@xw. sub 装饰 main 函数。

# 例 12-6 importsub. py（节选）

import xlwings as xw @xw. sub def main () wb  $=$  xw.Book.caller () sheet  $=$  wb. sheets[0] if sheet["A 1"]. value  $= =$  "Hello xlwings!": sheet["A 1"]. value  $=$  "Bye xlwings!" else: sheet["A 1"]. value  $=$  "Hello xlwings!"

在 xlwings 插件中点击 ImportFunctions 按钮，然后按下快捷键 Alt+F 8 查看可用的宏：除了使用 RunPython 的 SampleCall，你现在还能看到一个叫作 main 的宏。选中它并按下运行按钮后，你可以在 A 1 单元格中看到熟悉的问候语。现在你可以像第 10 章那样将 main 宏指派给一个按钮。虽然 xw. sub 装饰器可以让 Windows 中的工作更轻松，但是要记住：一旦使用了这个装饰器，你的工具就不再具备跨平台兼容性了。算上 xw. sub 之后我们就见识到了 xlwings 的所有装饰器，表 12- 1 对此进行了总结。

表 12-1：xlwings 装饰器  

<table><tr><td>装饰器</td><td>描述</td></tr><tr><td>xw. func</td><td>将这个装饰器放在所有你想要以 Excel 函数形式导入 Excel 的函数上</td></tr><tr><td>xw. sub</td><td>将这个装饰器放在所有你想要以子程序形式导入 Excel 的函数上</td></tr><tr><td>xw. arg</td><td>为参数应用转换器和选项，比如，通过 doc 参数添加文档字符串；通过把 pd. DataFrame 作为第一个参数（假定已将 pandas 导入为 pd）将单元格区域转换为 DataFrame</td></tr><tr><td>xw. ret</td><td>为返回值应用转换器和选项，比如，通过设置 index=False 忽略 DataFrame 的索引</td></tr></table>

参见 xlwings 的文档以了解有关这些装饰器的更多细节。

# 12.4 小结

本章主要讲的是编写 Python 函数并将它们作为 UDF 导入 Excel，从而可以经由单元格公式来调用这些 Python 函数。通过 GoogleTrends 这个案例研究，我们学习了如何通过 arg 装饰器和 ret 装饰器来改变函数参数和返回值的行为。最后，本章展示了一些性能优化的技巧，并介绍了 xw. sub 装饰器。如果你只在 Windows 中工作，那么可以通过 xw. sub 装饰器来替代 RunPython。使用 Python 编写 UDF 的好处在于，你可以用更易于理解和维护的 Python 代码来替代长且复杂的单元格公式。我个人比较喜欢的 UDF 用法当然是搭配 pandas DataFrame 和 Excel 新增的动态数组来使用，这种组合在处理 GoogleTrends 这类数据（行数会动态变化的 DataFrame）时会更加方便。

就这样，本书已经接近尾声了！本书体现了我对 Excel 的现代自动化和数据分析环境的理解，十分感谢你对此感兴趣！我的目的是带你进入 Python 的世界，并向你介绍各种强大的开源包，让你能够在下一个项目中使用 Python 编写代码，而不必使用 VBA 或者 PowerQuery 等 Excel 自己的解决方案，如果你需要的话，甚至可以完全脱离 Excel。我希望为你提供一些能够轻易上手的项目。读完本书后，你现在知道如何：

·用 Jupyter 笔记本和 pandas 代码替代 Excel 工作簿；·使用 OpenPyXL、xlrd、pyxlsb 或 xlwings 批量处理 Excel 工作簿，并使用 pandas 进行整合；·使用 OpenPyXL、XlsxWriter、xlwt 或 xlwings 生成 Excel 报表；·利用 xlwings 将 Excel 作为前端，通过编写 UDF 或者按下按钮连接到几乎任何数据源。

很快你就会想要学习一些本书中没有讲到的内容。我建议你时不时查看一下本书的主页以获取更新和额外的阅读材料。下面还有一些建议，你可以自行探索。

·使用 Windows 中的任务计划程序或者 macOS 和 Linux 中的 cron 作业来安排 Python 脚本定期执行。例如，可以基于你对 RESTAPI 或数据库的消费情况，在每周五生成一张 Excel 报表。·编写一个 Python 脚本，当你的 Excel 中的值满足某个条件时，脚本会发送邮件进行警告。条件可能是整合多个工作簿得到的账户余额降至某个值以下，或是工作簿的值和内部数据库中的值不一样。·编写代码找出 Excel 工作簿中的错误：检查类似于 #REF ！、 #VALUE这样的错误值 ，或者一些逻辑错误，比如要确保一条公式包含了所有应该包含的单元格。如果你开始使用 Git 之类的专业版本控制系统来跟踪你的重要工作簿，那么甚至可以在每次提交新版本时自动运行这些测试。