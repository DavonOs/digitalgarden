---
{"dg-publish":true,"dg-permalink":"books/35799208/04","permalink":"/books/35799208/04/","metatags":{"description":"本章展示了如何操作 NumPy 数组，解释了向量化和广播表达式是如何工作的。抛开这些术语不看，NumPy 数组使用起来和数学表达式十分接近，让人感觉非常直观。尽管 NumPy 十分强大，但在你试图用它来进行数据分析时，还是会遇到两个主要的问题。整个 NumPy 数组中的元素都必须是同一数据类型。举例来说，这就意味着如果你的数组中既有文本也有数字，就不能进行本章中提到的各种算术运算。只要数组中涉及文本，整个数组的数据类型就会变成 object，这个类型并不支持算术运算。用 NumPy 数组进行数据分析很难知道哪一列（或者行）代表什么意思，因为你通常都是按位置来选择列，比如 array 2[：，1]。pandas 通过在 NumPy 数组的基础上使用智能数据结构解决了这些问题。第 5 章的主题就是这些数据结构是什么以及如何使用。","og:site_name":"DavonOs","og:title":"Excel Python","og:type":"book","og:url":"https://zuji.eu.org/books/35799208/04","og:image":"https://file.ituring.com.cn/LargeCover/22038dc37469788a2ed5","og:image:width":"50","og:image:alt":"bookcover"},"created":"2025-09-24 13:27","updated":"2025-09-26 16:17"}
---


本章展示了如何操作 NumPy 数组，解释了向量化和广播表达式是如何工作的。


在你试图用 Numpy 来进行数据分析时，还是会遇到两个主要的问题。

整个 NumPy 数组中的元素都必须是同一数据类型。举例来说，这就意味着如果你的数组中既有文本也有数字，就不能进行本章中提到的各种算术运算。只要数组中涉及文本，整个数组的数据类型就会变成 object，这个类型并不支持算术运算。

用 NumPy 数组进行数据分析很难知道哪一列（或者行）代表什么意思，因为你通常都是按位置来选择列，比如 `array 2[:, 1]`。pandas 通过在 NumPy 数组的基础上使用智能数据结构解决了这些问题。
## 4.1 NumPy 入门

本节会介绍一维和二维的 NumPy 数组，以及向量化、广播和通用函数的背景知识。

### 4.1.1 NumPy 数组

正如第 3 章所描述的那样，如果要对嵌套列表进行数组运算，可以使用循环来完成。例如，要为嵌套列表中的每一个元素都加上 1，可以使用下面的嵌套列表推导式：

```python
matrix = [[1,2,3], [4,5,6], [7,8,9]]
[[i+1 foriinrow]forrowinmatrix]
>>> 
[[2,3,4],[5,6,7],[8,9,10]]
```

但这样的代码可读性很低。更关键的是，在面对更大的数组时，遍历整个数组会非常慢。如果你的用例和数组大小合适的话，那么使用 NumPy 数组进行运算会比 Python 列表快上几百倍。为了达到如此高的性能，NumPy 利用了用 C 和 Fortran（它们都是编译型语言，比 Python 要快得多）编写的代码。NumPy 数组是保存同构数据（homogenous data）的  N 维数组。“同构”意味着数组中的所有数据都必须是相同类型。最常见的情况就是处理图 4-1 所示的一维和二维的浮点数数组。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/bfda89d69b05bfd74c6f2cbbbac80fca346d9359f2320177d4a46b0a7c07047d.jpg)  
图 4-1：一维和二维的 NumPy 数组

下面来创建一个一维数组和一个二维数组，本章会一直使用这两个数组。

```
In[3]： #首先导入NumPy import numpy as np
In[4]： #使用列表构造一个一维数组 array1 = np.array ([10, 100, 1000. ]）
In[5]： #使用嵌套列表构造一个二维数组 array2 = np.array ([[1. , 2. , 3. ], [4. , 5. , 6. ]])
```

数组维度

要注意一维数组和二维数组之间的区别。一维数组只有一个轴，因此不区分行数组和列数组。这和 VBA 中的数组是类似的，但是如果你是从 MATLAB 等语言（MATLAB 中的一维数组会区分行数组和列数组）转过来的，那么可能需要花点儿时间习惯 NumPy 的做法。

即使 array 1 除了最后一个元素（浮点数）之外全是整数，但由于 NumPy 对同构的要求，这个数组的数据类型依然是 float 64，这个类型足以容纳所有的元素。要想了解一个数组的数据类型，可以访问它的 dtype 属性：

```
In[6]: array 1. dtype Out[6]: dtype ('float 64')
```

dtype 返回的是 float 64 而不是第 3 章中介绍过的 float。你可能已经猜到了，NumPy 使用的是它自己的数值数据类型，它们比 Python 的数据类型粒度要细。通常这都不是问题，

因为大部分时候 Python 和 NumPy 中的不同数据类型可以自动转换。如果你需要显式地将 NumPy 数据类型转换成 Python 的基本数据类型，只需使用对应的构造器即可（稍后我会更详细地介绍如何存取数组的元素）：

```
In[7]:float（array 1[0]） Out[7]: 10.0
```

在 NumPy 的文档中可以看到 NumPy 数据类型的完整列表。我们马上就会看到，有了 NumPy 数组，就可以以简洁的方式执行数组运算了。

### 4.1.2 向量化和广播

如果你对一个标量和 NumPy 数组求和，那么 NumPy 会执行按元素的操作。也就是说，你不用亲自遍历每一个元素。NumPy 社区称之为向量化（vectorization）。向量化可以让代码更简洁，更接近于数学记法。

```
In[8]: array 2+1 
Out[8]:array（[[2. .3. .4. ] [5. .6. .7. ]])
```

标量

标量（scalar）指的是某种 Python 基本数据类型，比如浮点型和字符串。这是为了将其和列表及字典一类的多元素数据结构，以及一维和二维的 NumPy 数组区分开来。

在处理两个数组时也是同样的道理，NumPy 会执行按元素的运算：

In[9]: array 2 \* array 2 Out[9]:array（[[1. .4. .9. ] [16. .25. .36. \|1. .4. .9. ] [16. .25. .36. ]])

如果你在算术运算中使用了两个形状不同的数组，那么 NumPy 在可能的情况下会自动将较小的数组扩展成较大的数组的形状。这就是广播（broadcasting）：

In[10]: array 2 \* array 1 Out[10]:array（[[10. .200. .3000. \|10. .200. .3000. ]] [40. .500. .6000. ]])

要求矩阵的点积，需要使用 @ 运算符：

In[11]: array 2 @ array 2. T # array 2. T 是 array 2. transpose（）的缩写形式 Out[11]:array（[[14. .32. ] [32. .77. \|14. .32. ] [32. .77. ]])

不要被本节引入的标量、向量化、广播这些术语吓到！如果你处理过 Excel 中的数组，那么这些操作也是很自然的。图 4-2 是文件 `array_calculations.xlsx` 打开后的样子，你可以在配套代码库的 x1 目录下找到它。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/c3ac01b8d8bb65e045e042fd9f4d74f11d232bf44fd704ee58842432cfd5b7e5.jpg)  
图 4-2：Excel 中的数组运算

你现在已经知道了如何对数组进行元素级别的运算，不过怎样才能对数组中的每个元素调用某个函数呢？通用函数能够解决这个问题。

### 4.1.3 通用函数

通用函数（universal function，简称 ufunc）会对 NumPy 数组中的每个元素执行操作。如果在 NumPy 数组中使用 Python 标准库 math 模块中的开平方函数，那么你会得到一个错误：

```
In[12]: import math
In[13]: math.sqrt (array 2) # 这里会发生错误 
TypeError Traceback (most recent call last)<ipython- input- 13- 5c37e8f41094> in <module>>>> 1 math.sqrt (array 2) # 这里会发生错误

TypeError: only size- 1 arrays can be converted to Python scalars
```

当然，你可以写一个嵌套循环来计算每个元素的平方根，然后再把结果构造成一个 NumPy 数组：

In[14]: np.array ([[math.sqrt (i) for i in row] for row in array 2]) Out[14]: array ([[1. , 1.41421356, 1.73205081], [2. , 2.23606798, 2.44948974\|math.sqrt (i) for i in row] for row in array 2]) Out[14]: array ([[1. , 1.41421356, 1.73205081], [2. , 2.23606798, 2.44948974\|1. , 1.41421356, 1.73205081], [2. , 2.23606798, 2.44948974]])

如果 NumPy 没有提供对应的 ufunc，并且数组足够小的话，这样写也可以。然而要是 NumPy 有这样一个 ufunc，你就该直接用它。除了更容易输入和阅读，在处理大型数组时 ufunc 会快得多：

In [15]: np.sqrt (array 2) Out[15]: array ([[1. , 1.41421356, 1.73205081], [2. , 2.23606798, 2.44948974]])

NumPy 的一些 ufunc 也可以用作数组的方法。以 sum 为例，如果你想求出每一列的总和，那么可以像下面这样做：

In [16]: array 2. sum (axis=0) # 返回一维数组 Out[16]: array ([5. , 7. , 9. ]

参数 axis=0 表示以行为轴，参数 axis=1 表示以列为轴，就像图 4- 1 中那样。省略 axis 参数会将整个数组加起来：

In [17]: array 2. sum () Out[17]: 21.0

在本书中你还会看到很多 NumPy 的 ufunc，它们也可以用在 pandas 的 DataFrame 中。

到目前为止我们一直在操作整个数组，下一节会教你如何操作数组的一部分，除此之外还会介绍一些有用的数组构造器。

## 4.2 创建和操作数组

在介绍那些方便的数组构造器（其中包括可用来创建蒙特卡罗模拟所用的伪随机数的构造器）之前，我会先教你如何存取数组的元素。在本节最后我会解释数组视图和数组副本之间的区别。

### 4.2.1 存取元素

在第 3 章中，我向你展示过如何通过索引和切片来访问列表特定的元素。在处理本章开头例子中的 matrix 这类嵌套列表时，可以使用链式索引（chained indexing）：matrix[0][0] 会得到第一行的第一个元素。不过在 NumPy 数组中，你要在一对方括号中同时提供两个维度的索引和切片参数：

numpy_array[row_selection, column_selection]

对于一维数组，上述代码简化成了 numpy_array[selection]。在选取单个元素时，你会得到一个标量，否则得到的就是一维或二维的数组。回忆一下，切片语法有一个起始索引（包含自身）和一个结束索引（不包含自身），两个索引之间有一个冒号，就像这样：start: end。如果省略起始索引和结束索引，只留下一个冒号，那么就代表二维数组的所有行或所有列。在图 4- 3 中，我把一些例子画了出来，不过你可能还需要回顾一下图 4- 1，图 4- 1 中标出了各个轴对应的索引。记住，对二维数组的行或列进行切片，得到的是一个一维数组，而不是二维列向量或行向量。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-15/dd9a4891-4e25-48b7-8140-6cdacb8609b4/5441dfff9f8ef577506e916a25f0d0582291c80feb68aa7764e208eca2662fee.jpg)  
图 4-3：选取 NumPy 数组的元素

执行如下代码来操练图 4- 3 给出的例子：

In[18]: array 1[2] #返回标量 Out[18]: 1000.0 In[19]: array 2[0，0] #返回标量 Out[19]: 1.0 In[20]: array 2[：，1:] #返回二维数组 Out[20]:array（[[2. ，3. ]， [5. ，6. \|2. ，3. ]， [5. ，6. ]]) In[21]: array 2[：，1] #返回一维数组 Out[21]:array（[2. ，5. ]） In[22]: array 2[1，: 2] #返回一维数组 Out[22]:array（[4. ，5. ]）

到目前为止，我一直是在手动构造例子中的数组，也就是说，我通过一系列列表来提供数据。不过 NumPy 为我们提供了一些方便的函数，这些函数可以用来构造数组。

### 4.2.2 方便的数组构造器

NumPy 提供了多种构造数组的方法，在第 5 章中我们会看到，这些方法也可以用于创建 pandas 的 DataFrame。arange 函数是其中一种创建数组的捷径。array 代表 array range（数组范围），它和第 3 章中介绍的 Python 内置函数 range 类似。通过 arange 和 reshape，可以快速生成指定维度的数组：

In[23]: np. arange（2\*5). reshape（2，5） #2行 ，5 列 Out[23]:array（[[0，1，2，3，4]， [5，6，7，8，9\|0，1，2，3，4]， [5，6，7，8，9]])

以蒙特卡罗模拟为例，一个常见需求是生成服从正态分布的伪随机数数组。NumPy 可以轻松做到：

In[24]: np. random. randn（2，3） #2行 ，3 列 Out[24]:array（[[- 0.30047275，- 1.19614685，- 0.13652283]， [1.05769357，0.03347978，- 1.2153504\|- 0.30047275，- 1.19614685，- 0.13652283]， [1.05769357，0.03347978，- 1.2153504]])

还有一些方便的构造器值得去发掘，比如 np. ones 和 np. zeros，它们分别可以创建全是 1 和 0 的数组。np. eye 可以创建单位矩阵。在第 5 章中我们还会遇到其中一些构造器，不过现在先来了解一下 NumPy 数组视图和副本的区别。

### 4.2.3 视图和副本

在对 NumPy 数组切片时，其返回值是视图（view）。这就意味着你是在操作原数组的一个子集，而没有发生数据的复制。因而设置视图的值也会改变原数组中的值：

In[25]: array 2 Out[25]:array（[[1.，2.，3. ]， [4.，5.，6. \|1.，2.，3. ]， [4.，5.，6. ]]) In[26]: subset  $=$  array 2[：，: 2] subset Out[26]:array（[[1.，2. ]， [4.，5. \|1.，2. ]， [4.，5. ]]) In[27]: subset[0，0]  $=$  1000 In[28]: subset Out[28]:array（[[1000. ， 2. ]， [4. ， 5. \|1000. ， 2. ]， [4. ， 5. ]]) In[29]: array 2 Out[29]:array（[[1000. ， 2. ， 3. ]， [4. ， 5. ， 6. \|1000. ， 2. ， 3. ]， [4. ， 5. ， 6. ]])

如果不想要这样的结果，那么可以把 In[26]的代码改成下面这样：

subset  $=$  array 2[：，: 2]. copy ()

对副本进行操作不会影响原数组。



