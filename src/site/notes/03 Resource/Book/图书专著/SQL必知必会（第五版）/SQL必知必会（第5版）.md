---
{"dg-publish":true,"dg-permalink":"book/35167240","permalink":"/book/35167240/","metatags":{"description":"本书是麻省理工学院、伊利诺伊大学等众多大学的参考教材，由浅入深地讲解了SQL的基本概念和语法，涉及数据的排序、过滤和分组，以及表、视图、联结、子查询、游标、存储过程和触发器等内容，实例丰富，便于查阅。本书没有过多阐述数据库基础理论，而是专门针对一线软件开发人员，直接从SQL SELECT开始，讲述实际工作环境中最常用和最必需的SQL知识，实用性极强。新版对书中的案例进行了全面的更新，并增加了章后挑战题，便于读者巩固所学知识。本·福达是世界知名的技术作家，在计算机产品开发、支持、培训和营销等方面拥有20多年的丰富经验。曾任Adobe公司开发者关系部总监。多年来，他撰写了SQL、正则表达式、JSP、WAP和Windows开发等方面的十多部技术图书，其中不少是世界畅销书，已被翻译为多种语言在全世界出版发行。","og:site_name":"DavonOs","og:title":"SQL必知必会（第5版）","og:type":"book","og:url":"https://zuji.eu.org/book/35167240","og:image":"https://wfqqreader-1252317822.image.myqcloud.com/cover/685/34336685/t6_34336685.jpg","og:image:width":"50","og:image:alt":"bookcover"}}
---


| 封面                                                                                           | 书名           | 作者               | 状态 | 评分     |
| -------------------------------------------------------------------------------------------- | ------------ | ---------------- | -- | ------ |
| ![\|50](https://wfqqreader-1252317822.image.myqcloud.com/cover/685/34336685/t6_34336685.jpg) | SQL必知必会（第5版） | 美/本·福达（BenForta） | \- | 9 ⭐⭐⭐⭐ |

{ .block-language-dataview}
[SQL必知必会（第5版）](https://weread.qq.com/web/bookDetail/f7632a30720befadf7636bb)
[数据库示例及资源支持](https://forta.com/books/0135182794/)
# 了解SQL

## 1.1 数据库基础

在手机上选取联系人，从电子邮件地址簿里查找名字时，就是在使用数据库。你 在网站上进行搜索，也是在使用数据库。你在工作中登录网络，也需要 依靠数据库验证用户名和密码。即使是在自动取款机上使用ATM卡，也 要利用数据库进行密码验证和余额查询。

基本的数据库术语

1.1.1 
数据库（database ）

以某种有组织的方式存储数据集合的容器（通常是一个文件或一组文件），最简单的办法是将数据库想象为一个文件柜。文件柜只是一个存放数据的物理位置，它不管数据是什么，也不管数据是如何组织的。


>[!attention]+ 误用导致混淆
人们常用数据库代表使用的数据库软件，这是不正确的，也因此产生了许多混淆。确切地说，数据库软件应称为数据库管理系统（DBMS）。数据库是通过DBMS创建和操纵的容器，而具体它究竟是什么，形式如何，各种数据库都不一样。

1.1.2 表

你往文件柜里放资料时，并不是随便将它们扔进某个抽屉就完事了的， 而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。

在数据库领域中，这种文件称为表。表是一种结构化的文件，可用来存储某种特定类型的数据。表可以保存顾客清单、产品目录，或者其他信息清单。

表（table ）

某种特定类型数据的结构化清单。

这里的关键一点在于，存储在表中的数据是同一种类型的数据或清单。 决不应该将顾客的清单与订单的清单存储在同一个数据库表中，否则以 后的检索和访问会很困难。应该创建两个表，每个清单一个表。

数据库中的每个表都有一个名字来标识自己。这个名字是唯一的，即数 据库中没有其他表具有相同的名字。

说明：表名

使表名成为唯一的，实际是数据库名和表名等的组合。有的数据库 还使用数据库拥有者的名字作为唯一名的一部分。也就是说，虽然在 一个数据库中不能两次使用相同的表名，但在不同的数据库中完全可 以使用相同的表名。

表具有一些特性，这些特性定义了数据在表中如何存储，包括存储什么 样的数据，数据如何分解，各部分信息如何命名等信息。描述表的这组 信息就是所谓的模式（schema）,模式可以用来描述数据库中特定的表， 也可以用来描述整个数据库（和其中表的关系）。

模式

关于数据库和表的布局及特性的信息。

1.1.3 列和数据类型

表由列组成。列存储表中某部分的信息。

列（column ）

表中的一个字段。所有表都是由一个或多个列组成的。

理解列的最好办法是将数据库表想象为一个网格，就像个电子表格那样。 网格中每一列存储着某种特定的信息。例如，在顾客表中，一列存储顾 客编号，另一列存储顾客姓名，而地址、城市、州以及邮政编码全都存 储在各自的列中。

提示：数据分解

正确地将数据分解为多个列极为重要。例如，城市、州、邮政编码 应该总是彼此独立的列。通过分解这些数据，才有可能利用特定的 列对数据进行分类和过滤（如找出特定州或特定城市的所有顾客）。 如果城市和州组合在一个列中，则按州进行分类或过滤就会很 困难。

你可以根据自己的具体需求来决定把数据分解到何种程度。例如，一 般可以把门牌号和街道名一起存储在地址里。这没有问题，除非你哪 天想用街道名来排序，这时，最好将门牌号和街道名分开。

数据库中每个列都有相应的数据类型。数据类型（datatype）定义了列可 以存储哪些数据种类。例如，如果列中存储的是数字（或许是订单中的 物品数），则相应的数据类型应该为数值类型。如果列中存储的是日期、 文本、注释、金额等，则应该规定好恰当的数据类型。

数据类型

允许什么类型的数据。每个表列都有相应的数据类型，它限制（或允 许）该列中存储的数据。

数据类型限定了可存储在列中的数据种类（例如，防止在数值字段中录 入字符值）。数据类型还帮助正确地分类数据，并在优化磁盘使用方面起 重要的作用。因此，在创建表时必须特别关注所用的数据类型。

注意：数据类型兼容

数据类型及其名称是SQL不兼容的一个主要原因。虽然大多数基本数 据类型得到了一致的支持，但许多高级的数据类型却没有。更糟的是， 偶然会有相同的数据类型在不同的DBMS中具有不同的名称。对此用 户毫无办法，重要的是在创建表结构时要记住这些差异。

1.1.4 行
表中的数据是按行存储的，所保存的每个记录存储在自己的行内。如果 将表想象为网格，网格中垂直的列为表列，水平行为表行。

例如，顾客表可以每行存储一个顾客。表中的行编号为记录的编号。

行（row ）

表中的一个记录。

说明：是记录还是行？

你可能听到用户在提到行时称其为数据库记录（record）。这两个术语 多半是可以互通的，但从技术上说，行才是正确的术语。

1.1.5 主键

表中每一行都应该有一列（或几列）可以唯一标识自己。顾客表可以使 用顾客编号，而订单表可以使用订单ID。雇员表可以使用雇员ID。书目 表则可以使用国际标准书号ISBN。

主键（primary key ）

一列（或几列），其值能够唯一标识表中每一行。 唯一标识表中每行的这个列（或这几列）称为主键。主键用来表示一个 特定的行。没有主键，更新或删除表中特定行就极为困难，因为你不能 保证操作只涉及相关的行，没有伤及无辜。

提示：应该总是定义主键

虽然并不总是需要主键，但多数数据库设计者都会保证他们创建的每 个表具有一个主键，以便于以后的数据操作和管理。

表中的任何列都可以作为主键，只要它满足以下条件：

- 任意两行都不具有相同的主键值；
- 每一行都必须具有一个主键值（主键列不允许空值NULL）;
- 主键列中的值不允许修改或更新；
- 主键值不能重用（如果某行从表中删除，它的主键不能赋给以后的新行）。

主键通常定义在表的一列上，但并不是必须这么做，也可以一起使用多 个列作为主键。在使用多列作为主键时，上述条件必须应用到所有列， 所有列值的组合必须是唯一的（但其中单个列的值可以不唯一）。

还有一种非常重要的键，称为外键，我们将在第12课中介绍。

## 1.2 什么是SQL

SQL  是结构化查询语言（Structured Query Language）的缩写，是一种专门用来与数据库沟通的语言。

设计SQL的目的是很好地完成一项任务——提供一种从数据库中读写数据的简单有效的方法。

SQL的优点

- SQL不是某个特定数据库厂商专有的语言。你几乎能与所有数据库打交道。
- SQL简单易学。它的语句全都是由有很强描述性的英语单词组成，而 且这些单词的数目不多。
- SQL看上去简单，但实际上是一种强有力的语言，灵活使用其语言元素，可以进行非常复杂和高级的数据库操作。

下面我们将开始真正学习SQL。

说明：SQL的扩展
为了提供执行特定操作的额外功能或简化方法，许多DBMS厂商通过增加语句或指令，对SQL进行了扩展。虽然这种扩展有用，但一般都是针对个别DBMS的，很少有两个厂商同时支持这种扩展。

标准SQL由ANSI标准委员会管理，从而称为ANSI SQL。所有主要的 DBMS，即使有自己的扩展，也都支持ANSI SQL。各个实现有自己的 名称，如 Oracle 的 PL/SQL、微软 SQL Server 用的 Transact-SQL 等。

本书讲授的SQL主要是ANSI SQL。在使用某种DBMS特定的SQL 时，会特别说明。

## 1.3 动手实践

本书中所有课程采用的都是真实的SQL语句和数据表，读者需要选个DBMS跟着学。

提示：该选哪个DBMS?

你需要用一种DBMS来跟着学，那么该选哪一个呢？

好消息是本书讲的SQL适用于每个主流的DBMS。因此，你主要从方 便易用角度考虑。

基本上有两种做法。一种是你在自己电脑上安装一个DBMS （以及有 关的客户端软件），这样做你用起来便利，好控制。但是对很多人来说， 要学SQL最麻烦的一关就是安装配置DBMS 了。另一种做法是通过 网络使用远程（或云端）DBMS，你不需要管理或安装任何东西。

要是准备在自己电脑上安装，其实可选的很多。我给两个建议：

- MySQL （或派生的MariaDB）是很不错的，免费，每个主流操作系 统都支持，安装简便，它也是最流行的DBMS之一。MySQL自带 一个命令行工具，你可以输入SQL命令，但最好是使用MySQL Workbench，你也把它下载安装吧（通常是要单独安装的）。

- Windows 用户可以使用 Microsoft SQL Server Express。这是强大的 SQL Server的一个免费版本，它还包括一个用户友好的客户端叫 SQL Server Management Studio。

要是准备使用远程（或云端）DBMS的话，我的建议是：

- 如果你是为工作需要而学习SQL，那么你们公司应该会有DBMS供 你使用。这样的话，你应该可以得到登录名和连接工具，可以访问 DBMS并输入和测试你的SQL语句。

- 云端DBMS是指运行在虚拟服务器上的DBMS，用起来就像自己机器上安装了 DBMS，而实际上不需要安装。所有主流的云服务厂商（如谷歌、亚马逊、微软）都提供云端DBMS。可是，在本书写作之时，设置云端DBMS （包括配置远程访问）都不太简单，经常比 自己安装个DBMS还要费事。有两个例外，Oracle的Live SQL和 IBM的云端DB2，它们提供的免费版本有Web界面，你只需要在 浏览器里输入SQL语句就可以了。

附录A解释了什么是样例表，并详述了如何获得（或创建）样例表，以 便应用于本书的每个课程中。

此外，从第2课开始，在小结部分增加了挑战题。读者有机会利用刚学 会的SQL知识，来解决这些课程中没有明示的问题。如果想要验证答案 （或者卡住了需要帮助），请访问本书网站。



# 排序检索数据
这一课讲授如何使用SELECT语句的ORDER BY子句，根据需要排序检索 出的数据。

## 3.1 排序数据

正如上一课所述，下面的SQL语句返回某个数据库表的单个列。但请看 其输出，并没有特定的顺序。

输入▼

```sql
SELECT prod_name

FROM Products;
```

输出▼

prod_name

Fish bean bag toy Bird bean bag toy Rabbit bean bag toy 8 inch teddy bear 12 inch teddy bear 18 inch teddy bear Raggedy Ann King doll Queen doll

其实，检索出的数据并不是随机显示的。如果不排序，数据一般将以它在表中出现的顺序显示，这有可能是数据最初添加到表中的顺序。但是， 如果数据随后进行过更新或删除，那么这个顺序将会受到DBMS重用回收存储空间的方式的影响。因此，如果不明确控制的话，则最终的结果不能（也不应该）依赖该排序顺序。

关系数据库设计理论认为，若不明确规定排序顺序，则不应假定检索出的数据的顺序有任何意义。

子句（clause ）

SQL语句由子句构成，有些子句是必需的，有些则是可选的。一个子句通常由一个关键字加上所提供的数据组成。子句的例子有我们在前一课看到的SELECT语句的FROM子句。

为了明确地排序用SELECT语句检索出的数据，可使用ORDER BY子句。 ORDER BY子句取一个或多个列的名字，据此对输出进行排序。请看下面的例子：

输入▼

```sql
SELECT prod_name
FROM Products
ORDER BY prod_name;
```

分析▼

除了指示DBMS软件对prod_name列以字母顺序排序数据的ORDER BY 子句外，这条语句与前面的语句相同。结果如下。

输出▼
```sql
prod_name
--------------------

12 inch teddy bear

18 inch teddy bear

8 inch teddy bear Bird bean bag toy Fish bean bag toy King doll

Queen doll

Rabbit bean bag toy Raggedy Ann
```

注意：ORDER BY子句的位置

在指定一条ORDER BY子句时，应该保证它是SELECT语句中最后一条子句。如果它不是最后的子句，将会出错。

提示：通过非选择列进行排序

通常，ORDER BY子句中使用的列将是为显示而选择的列。但是，实 际上并不一定要这样，用非检索的列排序数据是完全合法的。

## 3.2 按多个列排序

经常需要按不止一个列进行数据排序。例如，如果要显示雇员名单，可 能希望按姓和名排序（首先按姓排序，然后在每个姓中再按名排序）。如 果多个雇员有相同的姓，这样做很有用。

要按多个列排序，只须指定这些列名，列名之间用逗号分开即可（就像 选择多个列时那样）。

下面的代码检索3个列，并按其中两个列对结果进行排序——首先按价 格，然后按名称排序。

输入▼

```sql
SELECT prod_id, prod_price, prod_name
FROM Products
ORDER BY prod_price, prod_name;
```

输出▼

prod_id

prod_price

prod_name

BNBG02

3.4900

Bird bean bag toy

BNBG01

3.4900

Fish bean bag toy

BNBG03

3.4900

Rabbit bean bag toy

RGAN01

4.9900

Raggedy Ann

BR01

5.9900

8 inch teddy bear

BR02

8.9900

12 inch teddy bear

RYL01

9.4900

King doll

RYL02

9.4900

Queen doll

BR03

11.9900

18 inch teddy bear

重要的是理解在按多个列排序时，排序的顺序完全按规定进行。换句话 说，对于上述例子中的输出，仅在多个行具有相同的prod_price值时 才对产品按prod_name进行排序。如果prod_price列中所有的值都是 唯一的，则不会按prod_name排序。

## 3.3 按列位置排序

除了能用列名指出排序顺序外，ORDER BY还支持按相对列位置进行排序。为理解这一内容，我们来看个例子：

输入▼

```sql
SELECT prod_id, prod_price, prod_name FROM Products

ORDER BY 2, 3;
```

输出▼

prod_id prod_price prod_name

BNBG02

BNBG01


3.4900

3.4900


Bird bean bag toy Fish bean bag toy

BNBG03

3.4900

Rabbit bean bag toy

RGAN01

4.9900

Raggedy Ann

BR01

5.9900

8 inch teddy bear

BR02

8.9900

12 inch teddy bear

RYL01

9.4900

King doll

RYL02

9.4900

Queen doll

BR03

11.9900

18 inch teddy bear

分析▼

可以看到，这里的输出与上面的查询相同，不同之处在于ORDER BY子 句。SELECT清单中指定的是选择列的相对位置而不是列名。ORDER BY 2 表示按SELECT清单中的第二个列prod_price进行排序。ORDER BY 2, 3表示先按prod_pri ce，再按prod_name进行排序。

这一技术的主要好处在于不用重新输入列名。但它也有缺点。首先，不 明确给出列名有可能造成错用列名排序。其次，在对SELECT清单进行更 改时容易错误地对数据进行排序（忘记对ORDER BY子句做相应的改动）。 最后，如果进行排序的列不在SELECT清单中，显然不能使用这项技术。

提示：按非选择列排序

显然，当根据不出现在SELECT清单中的列进行排序时，不能采用这项 技术。但是，如果有必要，可以混合使用实际列名和相对列位置。

## 3.4 指定排序方向

数据排序不限于升序排序（从A到Z），这只是默认的排序顺序。还可以 使用ORDER BY子句进行降序（从Z到A）排序。为了进行降序排序， 必须指定DESC关键字。

下面的例子以价格降序来排序产品（最贵的排在最前面）：

输入▼

SELECT prod_id, prod_price, prod_name FROM Products

ORDER BY prod_price DESC;

输出▼

prod_id

prod_price

prod_name

BR03

11.9900

18 inch teddy bear

RYL01

9.4900

King doll

RYL02

9.4900

Queen doll

BR02

8.9900

12 inch teddy bear

BR01

5.9900

8 inch teddy bear

RGAN01

4.9900

Raggedy Ann

BNBG01

3.4900

Fish bean bag toy

BNBG02

3.4900

Bird bean bag toy

BNBG03

3.4900

Rabbit bean bag toy

如果打算用多个列排序，该怎么办？下面的例子以降序排序产品（最贵 的在最前面），再加上产品名：

输入▼

SELECT prod_id, prod_price, prod_name FROM Products

ORDER BY prod_price DESC, prod_name;

输出▼

prod_id

prod_price

prod_name

BR03

11.9900

18 inch teddy bear

RYL01

9.4900

King doll

RYL02

9.4900

Queen doll

BR02

8.9900

12 inch teddy bear

BR01

5.9900

8 inch teddy bear

RGAN01

4.9900

Raggedy Ann

BNBG02

BNBG01

BNBG03


3.4900

3.4900

3.4900


Bird bean bag toy Fish bean bag toy Rabbit bean bag toy

分析▼

DESC关键字只应用到直接位于其前面的列名。在上例中，只对prod_pri ce 歹列指定DESC，对prod_name歹列不指定。因此，prod_price歹列以降序排 序，而prod_name列（在每个价格内）仍然按标准的升序排序。

警告：在多个列上降序排序

如果想在多个列上进行降序排序，必须对每一列指定DESC关键字。

请注意，DESC是DESCENDING的缩写，这两个关键字都可以使用。与DESC 相对的是ASC （或ASCENDING）,在升序排序时可以指定它。但实际上， ASC 没有多大用处，因为升序是默认的（如果既不指定 ASC 也不指定 DESC,则假定为ASC）。

提示：区分大小写和排序顺序

在对文本性数据进行排序时，A与a相同吗？ a位于B之前，还是Z 之后？这些问题不是理论问题，其答案取决于数据库的设置方式。

在字典（dictionary）排序顺序中，A被视为与a相同，这是大多数数 据库管理系统的默认做法。但是，许多DBMS允许数据库管理员在需 要时改变这种行为（如果你的数据库包含大量外语字符，可能必须这 样做）。

这里的关键问题是，如果确实需要改变这种排序顺序，用简单的ORDER BY子句可能做不到。你必须请求数据库管理员的帮助。

## 3.5 小结

这一课学习了如何用SELECT语句的ORDER BY子句对检索出的数据进行 排序。这个子句必须是SELECT语句中的最后一条子句。根据需要，可 以利用它在一个或多个列上对数据进行排序。

## 3.6 挑战题
1. 编写SQL语句，从Customers中检索所有的顾客名称(cust_names)， 并按从Z到A的顺序显示结果。

2. 编写SQL语句，从Orders表中检索顾客ID(cust_id)和订单号 (order_num)，并先按顾客ID对结果进行排序，再按订单日期倒序 排列。

3. 显然，我们的虚拟商店更喜欢出售比较贵的物品，而且这类物品有很多。 编写SQL语句，显示Orderitems表中的数量和价格(item_price)， 并按数量由多到少、价格由高到低排序。

4. 下面的SQL语句有问题吗？(尝试在不运行的情况下指出。)

SELECT vend_name, FROM Vendors

ORDER vend_name DESC;
# 过滤数据
这一课将讲授如何使用SELECT语句的WHERE子句指定搜索条件。

## 4.1 使用WHERE子句

数据库表一般包含大量的数据，很少需要检索表中的所有行。通常只会 根据特定操作或报告的需要提取表数据的子集。只检索所需数据需要指 定搜索条件(search criteria),搜索条件也称为过滤条件(filter condition )。

在SELECT语句中，数据根据WHERE子句中指定的搜索条件进行过滤。

WHERE子句在表名(FROM子句)之后给出，如下所示：

输入^

SELECT prod_name, prod_price

FROM Products

WHERE prod_price = 3.49;

分析▼

这条语句从 products 表中检索两个列，但不返回所有行，只返回

prod_price值为3.49的行，如下所示：

输出▼

prod_name

prod_price

Fish bean bag toy Bird bean bag toy Rabbit bean bag toy

3.49

3.49

3.49

这个示例使用了简单的相等检验：检查这一列的值是否为指定值，据此 过滤数据。不过，SQL不只能测试等于，还能做更多的事情。

提示：有多少个0?

你在练习这个示例时，会发现显示的结果可能是3.49、3.490、3.4900 等。出现这样的情况，往往是因为DBMS指定了所使用的数据类型及 其默认行为。所以，如果你的输出可能与书上的有点不同，不必焦虑， 毕竟从数学角度讲，3.49和3.4900是一样的。

提示：SQL过滤与应用过滤

数据也可以在应用层过滤。为此，SQL的SELECT语句为客户端应用 检索出超过实际所需的数据，然后客户端代码对返回数据进行循环， 提取出需要的行。

通常，这种做法极其不妥。优化数据库后可以更快速有效地对数据进 行过滤。而让客户端应用（或开发语言）处理数据库的工作将会极大 地影响应用的性能，并且使所创建的应用完全不具备可伸缩性。此外， 如果在客户端过滤数据，服务器不得不通过网络发送多余的数据，这 将导致网络带宽的浪费。

注意：WHERE子句的位置

在同时使用ORDER BY和WHERE子句时，应该让ORDER BY位于 WHERE之后，否则将会产生错误（关于ORDER BY的使用，请参阅 第3课）。

## 4.2 WHERE子句操作符

我们在做相等检验时看到了第一个WHERE子句，它确定一个列是否包含 指定的值。SQL支持表4-1列出的所有条件操作符。

表4-1 WHERE子句操作符

操作符

说  明

操作符

说  明

=

等于

>

大于

< >

不等于

>=

大于等于

!=

不等于

!>

不大于

<

小于

BETWEEN

在指定的两个值之间

<=

小于等于

IS NULL

为NULL值

!<

不小于

注意：操作符兼容

表4-1中列出的某些操作符是冗余的（如＜＞与！=相同，！＜相当于＞=）。 并非所有DBMS都支持这些操作符。想确定你的DBMS支持哪些操作 符，请参阅相应的文档。

4.2.1 检查单个值
我们已经看到了检验相等的例子，现在来看看几个使用其他操作符的例子。

第一个例子是列出所有价格小于10美元的产品。

输入▼

SELECT prod_name, prod_price FROM Products

WHERE prod_price ＜ 10;

输出▼

prod_name

prod_price

Fish bean bag toy

Bird bean bag toy

Rabbit bean bag toy

8 inch teddy bear

12 inch teddy bear

Raggedy Ann

King doll

Queen doll

下一条语句检索所有价格小于等于10美元的产品（因为没有价格恰好是

10美元的产品，所以结果与前一个例子相同）：

输入▼

SELECT prod_name, prod_price FROM Products

WHERE prod_price <= 10;

4.2.2 不匹配检查
这个例子列出所有不是供应商DLL01制造的产品:

输入▼

SELECT vend_id, prod_name FROM Products

WHERE vend_id <> 'DLL01';

输出▼

vend_id

prod_name

BRS01

BRS01

BRS01

FNG01

FNG01

------------------

8 inch teddy bear

12 inch teddy bear

18 inch teddy bear King doll

Queen doll

提示：何时使用引号

如果仔细观察上述WHERE子句中的条件，会看到有的值括在单引号内， 而有的值未括起来。单引号用来限定字符串。如果将值与字符串类型的 列进行比较，就需要限定引号。用来与数值列进行比较的值不用引号。

下面是相同的例子，其中使用!=而不是＜＞操作符：

输入▼

SELECT vend_id, prod_name

FROM Products

WHERE vend_id != 'DLL01';

注意：是!=还是＜＞?

!=和。通常可以互换。但是，并非所有DBMS都支持这两种不等于操 作符。如果有疑问，请参阅相应的DBMS文档。

4.2.3 范围值检查
要检查某个范围的值，可以使用BETWEEN操作符。其语法与其他WHERE 子句的操作符稍有不同，因为它需要两个值，即范围的开始值和结束值。 例如，BETWEEN操作符可用来检索价格在5美元和10美元之间的所有产 品，或在指定的开始日期和结束日期之间的所有日期。

下面的例子说明如何使用BETWEEN操作符，它检索价格在5美元和10 美元之间的所有产品。

输入▼

输出▼

prod_name               prod_price

------------------- ----------

8 inch teddy bear

12 inch teddy bear

King doll

Queen doll

分析▼

从这个例子可以看到，在使用BETWEEN时，必须指定两个值一所需范 围的低端值和高端值。这两个值必须用AND关键字分隔。BETWEEN匹配 范围中所有的值，包括指定的开始值和结束值。

4.2.4 空值检查
在创建表时，表设计人员可以指定其中的列能否不包含值。在一个列不 包含值时，称其包含空值NULL。

NULL

无值（no value）,它与字段包含0、空字符串或仅仅包含空格不同。

确定值是否为NULL，不能简单地检查是否等于NULL。SELECT语句有一 个特殊的WHERE子句，可用来检查具有NULL值的列。这个WHERE子句 就是IS NULL子句。其语法如下：

输入▼

SELECT prod_name

FROM Products

WHERE prod_price IS NULL;

这条语句返回所有没有价格（空prod_price字段，不是价格为0）的 产品，由于表中没有这样的行，所以没有返回数据。但是，Customers 表确实包含具有NULL值的列：如果没有电子邮件地址，则cust_email 列将包含NULL值：

输入▼

SELECT cust_name

FROM Customers

WHERE cust_email IS NULL;

输出▼

cust_name

---------- Kids Place The Toy Store

提示：DBMS特有的操作符

许多DBMS扩展了标准的操作符集，提供了更高级的过滤选择。更多 信息请参阅相应的DBMS文档。

注意：NULL和非匹配

通过过滤选择不包含指定值的所有行时，你可能希望返回含NULL值的 行。但是这做不到。因为NULL比较特殊，所以在进行匹配过滤或非匹 配过滤时，不会返回这些结果。

## 4.3 小结

这一课介绍了如何用SELECT语句的WHERE子句过滤返回的数据。我 们学习了如何检验相等、不相等、大于、小于、值的范围以及 NULL 值等。

## 4.4 挑战题

1.编写SQL语句，从Products表中检索产品ID ( prod_id )和产品名 称(prod_name),只返回价格为9.49美元的产品。

2 .编写SQL语句，从Products表中检索产品ID( prod_id)和产品名 称(prod_name)，只返回价格为9美元或更高的产品。

3 .结合第3课和第4课编写SQL语句，从Orderitems表中检索出所有 不同订单号(order_num)，其中包含100个或更多的产品。

4 .编写SQL语句，返回Products表中所有价格在3美元到6美元之间 的产品的名称(prod_name)和价格(prod_price)，然后按价格对 结果进行排序。(本题有多种解决方案，我们在下一课再讨论，不过 你可以使用目前已学的知识来解决它。)
# 高级数据过滤
这一课讲授如何组合WHERE子句以建立功能更强、更高级的搜索条件。 我们还将学习如何使用NOT和IN操作符。

## 5.1 组合WHERE子句

第4课介绍的所有WHERE子句在过滤数据时使用的都是单一的条件。为 了进行更强的过滤控制，SQL允许给出多个WHERE子句。这些子句有两 种使用方式，即以AND子句或OR子句的方式使用。

操作符(operator)

用来联结或改变WHERE子句中的子句的关键字，也称为逻辑操作符

(logical operator )。

5.1.1 AND操作符
要通过不止一个列进行过滤，可以使用AND操作符给WHERE子句附加条 件。下面的代码给出了一个例子：

输入▼

FROM Products

WHERE vend_id = 'DLL01' AND prod_price <= 4;

分析▼

此SQL语句检索由供应商DLL01制造且价格小于等于4美元的所有产品 的名称和价格。这条SELECT语句中的WHERE子句包含两个条件，用AND 关键字联结在一起。AND指示DBMS只返回满足所有给定条件的行。如 果某个产品由供应商DLL01制造，但价格高于4美元，则不检索它。类 似地，如果产品价格小于4美元，但不是由指定供应商制造的也不被检 索。这条SQL语句产生的输出如下：

输出▼

prod_id

prod_price

prod_name

BNBG02

3.4900

Bird bean bag toy

BNBG01

3.4900

Fish bean bag toy

BNBG03

3.4900

Rabbit bean bag toy

AND

用在WHERE子句中的关键字，用来指示检索满足所有给定条件的行。

这个例子只包含一个AND子句，因此只有两个过滤条件。可以增加多个 过滤条件，每个条件间都要使用AND关键字。

说明：没有ORDER BY子句

为了节省空间，也为了减少你的输入，我在很多例子里省略了 ORDER BY子句。因此，你的输出完全有可能与书上的输出不一致。虽然返回 行的数量总是对的，但它们的顺序可能不同。当然，如果你愿意也可 以加上一个ORDER BY子句，它应该放在WHERE子句之后。

5.1.2 OR操作符
OR操作符与AND操作符正好相反，它指示DBMS检索匹配任一条件的 行。事实上，许多DBMS在OR WHERE子句的第一个条件得到满足的情 况下，就不再计算第二个条件了（在第一个条件满足时，不管第二个条 件是否满足，相应的行都将被检索出来）。

请看如下的SELECT语句：

输入▼

SELECT prod_id, prod_price, prod_name

FROM Products

WHERE vend_id = 'DLL01' OR vend_id = 'BRS01';

分析▼

此SQL语句检索由任一个指定供应商制造的所有产品的产品名和价格。

OR操作符告诉DBMS匹配任一条件而不是同时匹配两个条件。如果 这里使用的是AND操作符，则没有数据返回（因为会创建没有匹配行的 WHERE子句）。这条SQL语句产生的输出如下：

输出▼

prod_name

-------------------

prod_price

Fish bean bag toy

3.4900

Bird bean bag toy

3.4900

Rabbit bean bag toy

3.4900

8 inch teddy bear

5.9900

12 inch teddy bear

8.9900

18 inch teddy bear

11.9900

Raggedy Ann

4.9900

OR

WHERE子句中使用的关键字，用来表示检索匹配任一给定条件的行。

5.1.3 求值顺序
WHERE子句可以包含任意数目的AND和OR操作符。允许两者结合以进 行复杂、高级的过滤。

但是，组合AND和OR会带来了一个有趣的问题。为了说明这个问题， 来看一个例子。假如需要列出价格为10美元及以上，且由DLL01或BRS01 制造的所有产品。下面的SELECT语句使用组合的AND和OR操作符建立 了一个WHERE子句：

输入▼

SELECT prod_name, prod_price

FROM Products

WHERE vend_id = 'DLL01' OR vend_id = 'BRS01 AND prod_price >= 10;

输出▼

prod_name

prod_price

Fish bean bag toy Bird bean bag toy Rabbit bean bag toy 18 inch teddy bear Raggedy Ann

3.4900

3.4900

3.4900

11.9900

4.9900

分析▼

请看上面的结果。返回的行中有4行价格小于10美元，显然，返回的行 未按预期的进行过滤。为什么会这样呢？原因在于求值的顺序。SQL （像 多数语言一样）在处理OR操作符前，优先处理AND操作符。当SQL看到 上述WHERE子句时，它理解为：由供应商BRS01制造的价格为10美元以 上的所有产品，以及由供应商DLL01制造的所有产品，而不管其价格如何。 换句话说，由于AND在求值过程中优先级更高，操作符被错误地组合了。 此问题的解决方法是使用圆括号对操作符进行明确分组。请看下面的 SELECT语句及输出：

输入▼

SELECT prod_name, prod_price FROM Products

WHERE (vend_id = 'DLL01' OR vend_id = 'BRS01') AND prod_price >= 10;

输出▼

prod_name               prod_price

------------------- ---------- 18 inch teddy bear      11.9900

分析▼

这条SELECT语句与前一条的唯一差别是，将前两个条件用圆括号括了起 来。因为圆括号具有比AND或OR操作符更高的优先级，所以DBMS首先 过滤圆括号内的OR条件。这时，SQL语句变成了选择由供应商DLL01 或BRS01制造的且价格在10美元及以上的所有产品，这正是我们希望 的结果。

提示：在WHERE子句中使用圆括号

任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括 号明确地分组操作符。不要过分依赖默认求值顺序，即使它确实如你 希望的那样。使用圆括号没有什么坏处，它能消除歧义。

## 5.2 IN操作符

IN操作符用来指定条件范围，范围中的每个条件都可以进行匹配。IN取 一组由逗号分隔、括在圆括号中的合法值。下面的例子说明了这个操作符。

输入▼

SELECT prod_name, prod_price FROM Products

WHERE vend_id IN ('DLL01','BRS01') ORDER BY prod_name;

输出▼

prod_name

prod_price

12 inch teddy bear 18 inch teddy bear 8 inch teddy bear Bird bean bag toy Fish bean bag toy Rabbit bean bag toy Raggedy Ann

8.9900

11.9900

5.9900

3.4900

3.4900

3.4900

4.9900

分析▼

此SELECT语句检索由供应商DLL01和BRS01制造的所有产品。IN操作 符后跟由逗号分隔的合法值，这些值必须括在圆括号中。

你可能会猜测IN操作符完成了与OR相同的功能，恭喜你猜对了！下面 的SQL语句完成与上面的例子相同的工作。

输入▼

SELECT prod_name, prod_price

FROM Products

WHERE vend_id = 'DLL01' ORDER BY prod_name;

OR vend_id = 'BRS01'

输出▼

12 inch teddy bear      8.9900

18 inch teddy bear      11.9900

8 inch teddy bear       5.9900

Bird bean bag toy       3.4900

Fish bean bag toy       3.4900

Rabbit bean bag toy     3.4900

Raggedy Ann             4.9900

为什么要使用IN操作符？其优点如下。

口在有很多合法选项时，IN操作符的语法更清楚，更直观。

口在与其他AND和OR操作符组合使用IN时，求值顺序更容易管理。

口 IN操作符一般比一组OR操作符执行得更快（在上面这个合法选项很 少的例子中，你看不出性能差异）。

口 IN的最大优点是可以包含其他SELECT语句，能够更动态地建立 WHERE子句。第11课会对此进行详细介绍。

IN

WHERE子句中用来指定要匹配值的清单的关键字，功能与OR相当。

## 5.3 NOT操作符

WHERE子句中的NOT操作符有且只有一个功能，那就是否定其后所跟的 任何条件。因为NOT从不单独使用（它总是与其他操作符一起使用），所 以它的语法与其他操作符有所不同。NOT关键字可以用在要过滤的列前， 而不仅是在其后。

NOT

WHERE子句中用来否定其后条件的关键字。

下面的例子说明NOT的用法。为了列出除DLL01之外的所有供应商制造 的产品，可编写如下的代码。

输入▼

SELECT prod_name

FROM Products

WHERE NOT vend_id = 'DLL01'

ORDER BY prod_name;

输出▼

prod_name

12 inch teddy bear

18 inch teddy bear

8 inch teddy bear

King doll

Queen doll

分析▼

这里的NOT否定跟在其后的条件，因此，DBMS不是匹配vend_id为 DLL01,而是匹配非DLL01之外的所有东西。

上面的例子也可以使用<>操作符来完成，如下所示。

输入▼

SELECT prod_name

FROM Products

WHERE vend_id <> 'DLL01'

ORDER BY prod_name;

输出▼

prod_name

12 inch teddy bear 18 inch teddy bear

8 inch teddy bear King doll

Queen doll

分析▼

为什么使用NOT?对于这里的这种简单的WHERE子句，使用NOT确实 没有什么优势。但在更复杂的子句中，NOT是非常有用的。例如，在 与IN操作符联合使用时，NOT可以非常简单地找出与条件列表不匹配 的行。

说明：MariaDB中的NOT

MariaDB支持使用NOT否定IN、BETWEEN和EXISTS子句。大多数

DBMS允许使用NOT否定任何条件。

## 5.4 小结

这一课讲授如何用AND和OR操作符组合成WHERE子句，还讲授了如何 明确地管理求值顺序，如何使用IN和NOT操作符。

5.5 挑战题
1 .编写SQL语句，从Vendors表中检索供应商名称(vend_name)，仅返 回加利福尼亚州的供应商(这需要按国家［USA］和州［CA］进行过滤， 没准其他国家也存在一个加利福尼亚州)。提示：过滤器需要匹配字 符串。

2 .编写SQL语句，查找所有至少订购了总量100个的BR01、BR02或 BR03的订单。你需要返回OrderItems表的订单号(order_num)、 产品ID(prod_id)和数量，并按产品ID和数量进行过滤。提示： 根据编写过滤器的方式，可能需要特别注意求值顺序。

3 .现在，我们回顾上一课的挑战题。编写SQL语句，返回所有价格在3 美元到6美元之间的产品的名称(prod_name)和价格(prod_price)。 使用AND，然后按价格对结果进行排序。

4 .下面的SQL语句有问题吗？(尝试在不运行的情况下指出。)

SELECT vend_name

FROM Vendors

ORDER BY vend_name

WHERE vend_country = 'USA' AND vend_state = 'CA';
# 用通配符进行过滤

6.1 LIKE 操作符 49

6.2 使用通配符的技巧 55

6.3 小结 56

6.4 挑战题
# 第7 课 创建计算字段

  - 7.1 计算字段 58
  - 7.2 拼接字段 59
  - 7.3 执行算术计算 65
  - 7.4 小结 67
  - 7.5 挑战题 67
# 第8 课 使用函数处理数据 68
  - 8.1 函数 68
  - 8.2 使用函数 69
  - 8.3 小结 77
  - 8.4 挑战题 77
# 第9 课 汇总数据 78
  - 9.1 聚集函数 78
  - 9.2 聚集不同值 85
  - 9.3 组合聚集函数 86
  - 9.4 小结 87
  - 9.5 挑战题 88
# 第10 课 分组数据 89
  - 10.1 数据分组 89
  - 10.2 创建分组 90
  - 10.3 过滤分组 92
  - 10.4 分组和排序 95
  - 10.5 SELECT 子句顺序 97
  - 10.6 小结 97
  - 10.7 挑战题 98
# 第11 课 使用子查询 99
  - 11.1 子查询 99
  - 11.2 利用子查询进行过滤 99
  - 11.3 作为计算字段使用子查询 103
  - 11.4 小结 106
  - 11.5 挑战题 107
# 第12 课 联结表 108
  - 12.1 联结 108
  - 12.2 创建联结 111
  - 12.3 小结 118
  - 12.4 挑战题 118
# 第13 课 创建高级联结 . 120
  - 13.1 使用表别名 120
  - 13.2 使用不同类型的联结 121
  - 13.3 使用带聚集函数的联结 127
  - 13.4 使用联结和联结条件 129
  - 13.5 小结 129
  - 13.6 挑战题 129
# 第14 课 组合查询 131
  - 14.1 组合查询 131
  - 14.2 创建组合查询 132
  - 14.3 小结 138
  - 14.4 挑战题 139
# 第15 课 插入数据 140
  - 15.1 数据插入 140
  - 15.2 从一个表复制到另一个表 147
  - 15.3 小结 148
  - 15.4 挑战题 149
# 第16 课 更新和删除数据 150
  - 16.1 更新数据 150
  - 16.2 删除数据 152
  - 16.3 更新和删除的指导原则 154
  - 16.4 小结 155
  - 16.5 挑战题 156
# 第17 课 创建和操纵表 157
  - 17.1 创建表 157
  - 17.2 更新表 162
  - 17.3 删除表 165
  - 17.4 重命名表 165
  - 17.5 小结 166
  - 17.6 挑战题 166
# 第18 课 使用视图 167
  - 18.1 视图 167
  - 18.2 创建视图 170
  - 18.3 小结 177
  - 18.4 挑战题 177
# 第19 课 使用存储过程 178
  - 19.1 存储过程 178
  - 19.2 为什么要使用存储过程 179
  - 19.3 执行存储过程 181
  - 19.4 创建存储过程 182
  - 19.5 小结 187
# 第20 课 管理事务处理188
  - 20.1 事务处理 188
  - 20.2 控制事务处理 190
  - 20.3 小结 195
# 第21 课 使用游标 196
  - 21.1 游标 196
  - 21.2 使用游标 197
  - 21.3 小结 202
# 第22 课 高级SQL 特性 203
  - 22.1 约束 203
  - 22.2 索引 210
  - 22.3 触发器 212
  - 22.4 数据库安全 214
  - 22.5 小结 215

  附录A 样例表脚本
  附录B SQL 语句的语法
  附录C SQL 数据类型
  附录D SQL 保留字
  常用SQL 语句速查
  索 引


