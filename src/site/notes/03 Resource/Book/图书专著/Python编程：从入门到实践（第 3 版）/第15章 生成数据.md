---
{"dg-publish":true,"dg-permalink":"book/36365320/15_genrating_data","permalink":"/book/36365320/15_genrating_data/","metatags":{"description":"Python编程：从入门到实践（第3版）第15章 生成数据的学习笔记","og:site_name":"DavonOs","og:title":"第15章 生成数据","og:type":"article","og:url":"https://zuji.eu.org/book/36365320/15_genrating_data","og:image":"https://weread-1258476243.file.myqcloud.com/weread/cover/90/YueWen_34336681/t6_YueWen_34336681.jpg","og:image:width":"400","og:image:alt":"articlecover","og:locale":"zh_cn"},"tags":["learn/python"]}
---


# 第15章生成数据

数据可视化指的是通过可视化表示来探索和呈现数据集内的规律。它与数据分析紧密相关，而数据分析指的是使用代码来探索数据集内的规律和关联。数据集既可以是用一行代码就能装下的小型数值列表，也可以是数万亿字节、包含多种信息的数据。

有效的数据可视化不仅仅是以漂亮的方式呈现数据。重要的是，通过以简单而引人注目的方式呈现数据，让观看者能够明白其含义：发现数据集中 原本未知的规律和意义。

所幸，即便没有超级计算机，也能够可视化复杂的数据。鉴于Python的高效性，使用它在笔记本计算机上就能快速地探索由数百万个数据点组成的数据集。数据点并不一定是数，利用本书第一部分介绍的基本知识，也可对非数值数据进行分析。

在遗传学、天气研究、政治和经济分析等众多领域，人们常常使用Python 来完成数据密集型工作。数据科学家使用Python编写了一系列优秀的可视 化和分析工具，你可以轻易使用其中的大部分工具。一个流行的工具是 Matplotlib，它是一个数学绘图库。本章将使用它来制作简单的绘图(plot)，如折线图和散点图，还将基于随机游走的概念(根据一系列随机 决策生成图形)生成一个更有趣的数据集。

本章还将使用Plotly包来分析掷骰子的结果，这个包生成的图形非常适合在数字设备上显示——不仅能根据显示设备的尺寸自动调整大小，还具备众多交互特性，如在用户将鼠标指向图形的不同区域时，突出显示数据集的相应特征。学习使用Matplotlib和Plotly，有助于你初步掌握数据可视化技巧。

15.1	安装 Matplotlib

本章将首先使用Matplotlib来生成几个图形，为此需要像第11章安装 pytest那样使用pip安装Matplotlib （请参阅11.1节）。

要安装Matplotlib,请在终端提示符下执行如下命令：
$ python -m pip install --user matplotlib
如果你在运行程序或启动终端会话时使用的命令不是python,而是 python3,应使用类似下面的命令来安装Matplotlib :
$ python3 -m pip install --user matplotlib
要查看使用Matplotlib可绘制的各种图形，请访问Matplotlib主页并单击
Examples。 通过单击Plot types页面中的绘图，就能查看生成它们的代码。
15.2	绘制简单的折线图
下面使用Matplotlib绘制一张简单的折线图，再对其进行定制，以实现信息 更丰富的数据可视化效果。我们将使用平方数序列1、4、9、16和25来绘 制这个图形。
要创建简单的折线图，只需指定要使用的数，Matplotlib将完成余下的工 作：
mpl_squares.py
import matplotlib.pyplot as plt
squares = [1, 4, 9, 16, 25]
❶ fig, ax = plt.subplots()
ax.plot(squares)
plt.show()
首先导入pyplot模块，并给它指定别名plt,以免反复输入pyploto (在线示例大多这样做，我们也不例外。)pyplot模块包含很多用于生成 图形和绘图的函数。
其次创建一个名为squares的列表，在其中存储要用来制作图形的数据。
然后，采取Matplotlib的另一种常见做法-调用subplots()函数(见
❶)。这个函数可在一个图形(figure)中绘制一或多个绘图(plot)。变量 fig表示由生成的一系列绘图构成的整个图形。变量ax表示图形中的绘 图，在大多数情况下，使用这个变量来定义和定制绘图。
接下来调用plot()方法，它将根据给定的数据以有浅显易懂的方式绘制 绘图。plt.show()函数打开Matplotlib查看器并显示绘图，如图15-1所 示。在查看器中，既可缩放和浏览绘图，还可单击磁盘图标将绘图保存起 来。
图15-1使用Matplotlib可绘制的简单绘图
15.2.1	修改标签文字和线条粗细
图15-1所示的绘图表明数是越来越大的，但是标签文字太小、线条太细， 看不清楚。幸运的是，Matplotlib让你能够调整可视化的各个方面。
下面通过定制来改善这个绘图的可读性。首先添加图题并给坐标轴加上标 签：
mpl_squares.py
import matplotlib.pyplot as plt
squares = [1, 4, 9, 16, 25]
fig, ax = plt.subplots()
❶ ax.plot(squares, linewidth=3)
#设置图题并给坐标轴加上标签
❷ ax.set_title("Square Numbers", fontsize=24)
❸ ax.set_xlabel("Value", fontsize=14)
ax.set_ylabel("Square of Value", fontsize=14)
#设里刻度标记的样式
❹ ax.tick_params(labelsize=14)
plt.show()
参数linewidth决定了 plot()绘制的线条的粗细(见❶)。生成绘图 后，可在显示前使用很多方法修改它。set_title()方法给绘图指定标题 (见❷)。在上述代码中，多次出现的参数fontsize用于指定图中各种
文字的大小。
set_xlabel()方法和set_ylabel()方法让你能够为每条轴设置标题 (见❸)。tick_params()方法设置刻度标记的样式(见❹)，它在这里
将两条轴上的刻度标记的字号都设置为14 (labelsize=l4)。
最终的图阅读起来容易得多，如图15-2所示：标签文字更大，线条也更粗 To通常，需要尝试不同的值，才能找到最佳参数生成理想的图。
Figure 1
0.0	0.5	1.0	1.5	2.0	2.5	3.0	3.5	4.0
V^lue
66 个+Q三国
Square Numbers
图15-2现在的图阅读起来容易得多
15.2.2	校正绘图
图更容易看清后，我们发现数据绘制得并不正确：折线图的终点指出4.0的 平方为25。下面来修复这个问题。
在向plot()提供一个数值序列时，它假设第一个数据点对应的x坐标值 为0,但这里的第一个点对应的x坐标值应该为1。为了改变这种默认行 为，可给plot()同时提供输入值和输出值：
mpl_squares.py
import matplotlib.pyplot as plt
input_values = [1, 2, 3, 4, 5]
squares = [1, 4, 9, 16, 25]
fig, ax = plt.subplots()
ax.plot(input_values, squares, linewidth=3)
#设置图题并给坐标轴加上标签
--snip--
现在，plot()无须对输出值的生成方式做出假设，因此生成了正确的绘 图，如图15-3所示。
・ • ・	Figure 1
___________Square Numbers______
1.0	1.5	2.0	2.5	3,0	3.5	4.0	4.5	5.0
Value
命♦ ♦ + Q三二
图15-3根据数据正确地绘图
不仅可以在使用plot()时指定各种实参，还可以在生成绘图后使用众多 方法对其进行定制。本章后面在处理更有趣的数据集时，将继续探索这些 定制方式。
15.2.3使用内置样式
Matplotlib提供了很多已定义好的样式，这些样式包含默认的背景色、网格 线、线条粗细、字体、字号等设置，让你无须做太多定制就能生成引人瞩 目的可视化效果。要看到能在你的系统中使用的所有样式，可在终端会话 中执行如下命令：
>>> import matplotlib.pyplot as plt
>>> plt.style.available
['Solarize_Light2', '_classic_test_patch', '_mpl-gallery',
--snip--
要使用这些样式，可在调用subplots()的代码前添加如下代码行1 ：
1由于Seaborn库的变动，你会看到MatplotlibDeprecationwarning,这对代码运行和样式都 没有影响。如果不想看到这条警告，可以将本书代码中的seaborn都替换为seaborn-v0_8。
——编者注
mpl_squares.py
import matplotlib.pyplot as plt
input_values = [1, 2, 3, 4, 5]
squares = [1, 4, 9, 16, 25]
plt.style.use('seaborn')
fig, ax = plt.subplots()
--snip--
这些代码生成的绘图如图15-4所示。可用的内置样式有很多，请尝试使用 它们，找出你喜欢的。
Figure 1
g«> J。0>」enbs
图15-4内置样式 seaborn
15.2.4使用scatter()绘制散点图并设置样式
有时候，需要绘制散点图并设置各个数据点的样式。例如，你可能想用一 种颜色显示较小的值，用另一种颜色显示较大的值。在绘制大型数据集 时，还可先对每个点都设置同样的样式，再使用不同的样式重新绘制某些 点，以示突出。
要绘制单个点，可使用scatter。方法，并向它传递该点的x坐标值和 坐标值：
scatter_squares.py
y
import matplotlib.pyplot as plt
plt.style.use('seaborn')
fig, ax = plt.subplots()
ax.scatter(2, 4)
plt.show()
下面来设置图的样式，使其更有趣。我们将添加标题，给坐标轴加上标 签，并确保所有文本都足够大、能看清：
import matplotlib.pyplot as plt
plt.style.use('seaborn')
fig, ax = plt.subplots()
❶ ax.scatter(2, 4, s=200)
#设置图题并给坐标轴加上标签
ax.set_title("Square Numbers", fontsize=24)
ax.set_xlabel("Value", fontsize=14)
ax.set_ylabel("Square of Value", fontsize=14)
#设里刻度标记的样式
ax.tick_params(labelsize=14)
在❶处，调用scatter。，并使用参数s设置绘图时使用的点的尺寸。如 果此时运行scatter_squares.py,将在图中央看到一个点，如图15-5所示。
• • •
Figure 1
Square Numbers
4 15
4 10
5 0 5
0 0 9
4 43.
o=_ra> Jo0)」Enbs
3.90
385
3 80
1.900	1.925	1.950	1 975	2.000	2.025	2.050	2.075	2.100
Wlue
黄«》中Q三国
图15-5绘制单个点
15.2.5 scatter()绘制一系列点
要绘制一系列点，可向scatter。传递两个分别包含x坐标值和y坐标值 的列表，如下所示：
scatter_squares.py
import matplotlib.pyplot as plt
x_values = [1, 2, 3, 4, 5]
y_values = [1, 4, 9, 16, 25]
plt.style.use('seaborn')
fig, ax = plt.subplots()
ax.scatter(x_values, y_values, s=100)
#设置图题并给坐标轴加上标签
--snip--
列表x_values包含要计算平方值的数，列表y_values包含这些数的平 方值。在将这两个列表传递给scatter。时，Matplotlib会依次从每个列 表中读取一个值来绘制一个点。要绘制的点的坐标分别为(1, 1)、(2, 4)、(3, 9)、(4, 16)和(5, 25),最终的结果如图15-6所示。
• • ・	Figuel
Square Numbers
25	・
① n-e>M—ooJenbs
■
1.0
1.5	2.0	25	3.0	3.5	4.0	4.5	5.0
Value
命♦ + 三^
图15-6由多个点组成的散点图
15.2.6自动计算数据
手动指定列表要包含的值效率不高，在需要绘制的点很多时尤其如此。好 在可以不指定值，直接使用循环来计算。
下面是绘制1000个点的代码：
scatter_squares.py
import matplotlib.pyplot as plt
❶ x_values = range(1, 1001)
y_values = [x**2 for x in x_values]
plt.style.use('seaborn') fig, ax = plt.subplots()
❷ ax.scatter(x_values, y_values, s=10)
#设置图形标题并给坐标轴加上标签
--snip--
#设里每个坐标轴的取值范围
❸ ax.axis([0, 1100, 0, 1_100_000])
plt.show()
首先创建一个包含X坐标值的列表，其中有数1〜1000 (见❶)。接下来， 是一个生成y坐标值的列表推导式，它遍历X坐标值for x in x_values),计算其平方值(x**2),并将结果赋给列表y_values。 然后，将输入列表和输出列表传递给scatter。(见❷)。这个数据集很 大，因此将点设置得较小。
显示绘图前，使用axis()方法指定每个坐标轴的取值范围(见❸)。 axis()方法要求提供四个值：x轴和y轴各自的最小值和最大值。这里将 X轴的取值范围设置为0~1100,将y轴的取值范围设置为0~1 100 000。 结果如图15-7所示。
图15-7对Python来说，绘制1000个点与绘制5个点一样容易
15.2.7定制刻度标记
在刻度标记表示的数足够大时，Matplotlib将默认使用科学记数法。这通常 是好事，因为如果使用常规表示法，很大的数将占据很多内存。
几乎每个图形元素都是可定制的，如果你愿意，可让Matplotlib始终使用常 规表示法：
--snip--
#设置每个坐标轴的取值范围
ax.axis([0, 1100, 0, 1_100_000])
ax.ticklabel_format(style='plain')
plt.show()
ticklabel_format()方法让你能够覆盖默认的刻度标记样式。
15.2.8	定制颜色
要修改数据点的颜色，可向scatter。传递参数color并将其设置为要 使用的颜色的名称(用引号引起来)，如下所示：
ax.scatter(x_values, y_values, color='red', s=10)
还可以使用RGB颜色模式定制颜色。此时传递参数color,并将其设置为 一个元组，其中包含三个。〜1的浮点数，分别表示红色、绿色和蓝色分 量。例如，下面的代码行创建一个由浅绿色的点组成的散点图：
ax.scatter(x_values, y_values, color=(0, 0.8, 0), s=10)
值越接近0,指定的颜色越深"直越接近1,指定的颜色越浅。
15.2.9	使用颜色映射
颜色映射(colormap)是一个从起始颜色渐变到结束颜色的颜色序列。在可 视化中，颜色映射用于突出数据的规律。例如，你可能用较浅的颜色来显 示较小的值，使用较深的颜色来显示较大的值。使用颜色映射，可根据精 心设计的色标(color scale)准确地设置所有点的颜色。
pyplot模块内置了一组颜色映射。要使用这些颜色映射，需要告诉 pyplot该如何设置数据集中每个点的颜色。下面演示了如何根据每个点的 y坐标值来设置其颜色：
scatter_squares.py
--snip--
plt.style.use('seaborn')
fig, ax = plt.subplots()
ax.scatter(x_values, y_values, c=y_values, cmap=plt.cm.Blues, s=10)
#设置图题并给坐标轴加上标签
--snip--
参数c类似于参数color,但用于将一系列值关联到颜色映射。这里将参 数c设置成了一个y坐标值列表，并使用参数cmap告诉pyplot使用哪
个颜色映射。这些代码将y坐标值较小的点显示为浅蓝色，将y坐标值较 大的点显示为深蓝色，结果如图15-8所示。
otDJEnbs
图15-8使用颜色映射Blues的绘图
注意：要了解pyplot中所有的颜色映射，请访问Matplotlib主页并单 击 Documentation。在 Learning resources 部分找到 Tutorials 并单击其中 的 Introductory tutorials,向下滚动到 Colors,再单击 Choosing Colormaps in Matplotlib。
15.2.10自动保存绘图
如果要将绘图保存到文件中，而不是在Matplotlib查看器中显示它，可将 plt.show()替换为 plt.savefig():
plt.savefig('squares_plot.png', bbox_inches='tight')
第一个实参指定要以什么文件名保存绘图，这个文件将被存储到 scatter_squares.py所在的目录中。第二个实参指定将绘图多余的空白区域裁 剪掉。如果要保留绘图周围多余的空白区域，只需省略这个实参即可。你
还可以在调用savefig()时使用Path对象，将输出文件存储到系统上的 任何地方。
动手试一试
练习15.1 :立方 数的三次方称为立方。请先绘图显示前5个正整数
的立方值，再绘图显示前5000个正整数的立方值。
练习15.2 :彩色立方 给前面绘制的立方图指定颜色映射。
15.3随机游走
本节将使用Python生成随机游走数据，再使用Matplotlib以美观的形式将 这些数据呈现出来。随机游走是由一系列简单的随机决策产生的行走路 径。可以将随机游走看作一只晕头转向的蚂蚁每一步都沿随机的方向前行 所经过的路径。
在自然界、物理学、生物学、化学和经济学中，随机游走都有实际的用 途。例如，漂浮在水滴上的一粒花粉不断受到水分子的挤压而在水滴表面 移动，因为水滴中的分子运动是随机的，所以花粉在水面上的运动路径就 是随机游走。稍后编写的代码能模拟现实世界中的很多情形。
15.3.1 创建 RandomWalk 类
为了模拟随机游走，我们将创建一个名为Randomwalk的类，用来随机地 选择前进的方向。这个类需要三个属性：一个是跟踪随机游走次数的变 量，另外两个是列表，分别存储随机游走经过的每个点的x坐标值和y坐 标值。
Randomwalk类只包含两个方法：—init—()和fill_walk(),后者 计算随机游走经过的所有点。先来看看__init__()方法：
random_walk.py
❶ from random import choice
class Randomwalk:
"""一个生成随机游走数据的类"""
❷ def __init__(self, num_points=5000):
"""初始化随机游走的属性""" self.num_points = num_points
#所有随机游走都始于(0, 0)
❸	self.x_values = [0]
self.y_values = [0]
为做出随机决策，将所有可能的选择都存储在一个列表中，并在每次决策 时使用random模块中的choice（）来决定做出哪种选择（见❶）。接下 来，将随机游走包含的默认点数设置为5000 （见❷）。这个数既大到足以 生成有趣的模式，同时又足够小，可确保能够快速地模拟随机游走。然 后，创建两个用于存储x坐标值和y坐标值的列表，并让每次游走都从点 （0, 0）出发（见❸）。
15.3.2选择方向
下面使用fill_walk（）方法来生成游走包含的点。请将这个方法添加到 刚才创建的Randomwalk类之下（别忘了缩进）：
random_walk.py
def fill_walk(self):
"""计算随机游走包含的所有点"""
#不断游走，直到列表达到指定的长度
❶	while len(self.x_values) < self.num_points:
#	决定前进的方向以及沿这个方向前进的距离
❷	x_direction = choice([1, -1])
x_distance = choice([0, 1, 2, 3, 4])
❸	x_step = x_direction * x_distance
y_direction = choice([1, -1]) y_distance = choice([0, 1, 2, 3, 4])
❹	y_step = y_direction * y_distance
#	拒绝原地踏步
❹	if x_step == 0 and y_step == 0:
continue
#	计算下一个点的x坐标值和y坐标值
❻	x = self.x_values[-1] + x_step
y = self.y_values[-1] + y_step
self.x_values.append(x)
self.y_values.append(y)
首先建立一个循环，它不断运行，直到获得所有的随机游走点（见❶）。 fill_walk（）方法的主要部分告诉Python如何模拟四种游走决策：向右
走还是向左走；沿指定的方向(右或左)走多远；向上走还是向下走；沿 选定的方向(上或下)走多远。
使用choice([l, -1])给x_direction选择一个值，结果要么是表示 向右走的1,要么是表示向左走的-1 (见❷)。接下来，choice([0, 1, 2, 3, 4])随机地选择沿指定的方向走多远(这个距离被赋给变量 x_distance)。列表中的0能够模拟只沿一条轴移动的情况。
在❸和❹处，将移动方向乘以移动距离，确定沿x轴和y轴移动的距离。如 果x_step为正，将向右移动；为负将向左移动；为0将垂直移动。如果 y_step为正，将向上移动；为负将向下移动；为0将水平移动。如果 x_step和y_step都为0,则意味着原地踏步。我们拒绝二者都为0的情 况，接着执行下一次循环(见❺)。
为了获取游走中下一个点的x坐标值，将x_step与x_values中的最后 一个值相加(见❻)，对y坐标值也做相同的处理。获得下一个点的x坐标 值和y坐标值后，将它们分别追加到列表x_values和y_values的末 尾。
15.3.3	绘制随机游走图
下面的代码将随机游走的所有点都绘制出来：
rw_visual.py
import matplotlib.pyplot as plt
from random_walk import RandomWalk
#创建一个RandomWalk实例
❶ rw = RandomWalk() rw.fill_walk()
#将所有的点都绘制出来
plt.style.use('classic') fig, ax = plt.subplots()
❷ ax.scatter(rw.x_values, rw.y_values, s=15)
❸ ax.set_aspect('equal') plt.show()
首先导入pyplot模块和Randomwalk类，再创建一个Randomwalk实 例并将其存储到rw中（见❶），然后调用fill_walk（）。在❷处，将随 机游走包含的x坐标值和y坐标值传递给scatter。,并选择合适的点的 尺寸。默认情况下，Matplotlib独立地缩放每个轴，而这将水平或垂直拉伸 绘图。为避免这种问题，这里使用set_aspect（）指定两条轴上刻度的间 距必须相等（见❸）。
图15-9显示了包含5000个点的随机游走图。（本节的示意图未包含
Matplotlib查看器的界面，但你在运行rw_visual.py时会看到。）
图15-9包含5000个点的随机游走
15.3.4	模拟多次随机游走
每次随机游走都不同，探索可能生成的各种模式很有趣。要在不运行程序 多次的情况下使用前面的代码模拟多次随机游走，一种办法是将这些代码 放在一个while循环中，如下所示：
rw_visual.py
import matplotlib.pyplot as plt
from random_walk import RandomWalk
#只要程序处于活动状态，就不断地模拟随机游走 while True:
#创建一个RandomWalk实例
--snip--
plt.show()
keep_running = input("Make another walk? (y/n): ") if keep_running == 'n':
break
这些代码每模拟完一次随机游走，都会在Matplotlib查看器中显示结果，并 在不关闭查看器的情况下暂停。如果关闭查看器，程序将询问是否要再模 拟一次随机游走。如果模拟多次，你将发现会生成各种各样的随机游走： 集中在起点附近的，沿特定方向远远偏离起点的，点的分布非常不均匀 的，等等。要结束程序，请按N键。
15.3.5设*随机游走图的样式
本节将定制绘图，以突出每次游走的重要特征，并让分散注意力的元素不 那么显眼。为此，先确定要突出的元素，如游走的起点、终点和经过的路 径，再确定不需要那么显眼的元素，如刻度标记和标签。最终的结果是简 单的可视化表示，能清楚地指出每次游走经过的路径。
01.给点着色
我们将使用颜色映射来指出游走中各个点的先后顺序，并删除每个点 的黑色轮廓，让其颜色更加明显。为了根据游走中各个点的先后顺序 进行着色，传递参数c,并将其设置为一个列表，其中包含各点的先后 顺序。由于这些点是按顺序绘制的，因此给参数c指定的列表只需包 含数。〜4999,如下所示：
rw_visual.py
--snip--
while True:
#创建一个RandomWalk实例
rw = RandomWalk() rw.fill_walk()
#将所有的点都绘制出来
plt.style.use('classic')
fig, ax = plt.subplots()
❶ point_numbers = range(rw.num_points)
ax.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,
edgecolors='none', s=15)
ax.set_aspect('equal')
plt.show()
--snip—
使用range()生成一个数值列表，列表长度值等于游走包含的点的个 数(见❶)。接下来，将这个列表赋给变量poinjnumbers,以便 后面使用它来设置每个游走点的颜色。将参数c设置为 poinjnumbers,指定使用颜色映射Blues,并传递实参 edgecolors='none'以删除每个点的轮廓。最终的随机游走图从浅 蓝色渐变为深蓝色，准确地指出从起点游走到终点的路径，如图15-10 所示。
图15-10使用颜色映射Blues着色的随机游走图
02.重新绘制起点和终点
除了给随机游走的各个点着色，以指出它们的先后顺序以外，如果还 能呈现随机游走的起点和终点就好了。为此，可在绘制随机游走图后 重新绘制第一个点和最后一个点。这里让起点和终点比其他点更大并 显示为不同的颜色，以示突出：
rw_visual.py
--snip-while True:
-	-snip--
ax.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,
edgecolors='none', s=15)
ax.set_aspect('equal')
#	突出起点和终点
ax.scatter(0, 0, c='green', edgecolors='none', s=100)
ax.scatter(rw.x_values[-1], rw.y_values[-1], c='red', edgecolors='none',
s=100)
plt.show()
-	-snip--
为了突出起点，使用绿色绘制点(0, 0),并使其比其他点更大
(s=100)。为了突出终点，在游走包含的最后一个X坐标值和y坐 标值处绘制一个点，将其颜色设置为红色，并将尺寸设置为100。务必 将这些代码放在调用plt.show()的代码前面，确保在其他点的上面 绘制起点和终点。
现在运行这些代码，就能准确地知道每次随机游走的起点和终点了。 如果起点和终点不明显，请调整颜色和大小，直到明显为止。
03.隐藏坐标轴
下面来隐藏绘图的坐标轴，以免分散观看者的注意力。要隐藏坐标 轴，可使用如下代码：
rw_visual.py
--snip-while True:
--snip--
ax.scatter(rw.x_values[-1], rw.y_values[-1], c='red', edgecolors='none',
s=100)
#隐藏坐标轴
ax.get_xaxis().set_visible(False) ax.get_yaxis().set_visible(False)
plt.show()
--snip--
先使用ax.get_xaxis()方法和ax.get_yaxis()方法获取每条坐 标轴，再通过链式调用set_visible()方法让每条坐标轴都不可 见。随着对数据可视化的不断学习和实践，你会经常看到通过方法链 式调用来定制不同的可视化效果。
现在运行rw_visual.py,可以看到一系列绘图，但看不到坐标轴。
04.增加点的个数
下面来增加随机游走中的点，以提供更多的数据。为此，在创建 Randomwalk实例时增大num_points的值，并在绘图时调整每个点 的大小：
rw_visual.py
--snip--
while True:
#创建一个Randomwalk实例 rw = RandomWalk(50_000)
rw.fill_walk()
#将所有的点都绘制出来
plt.style.use('classic')
fig, ax = plt.subplots()
point_numbers = range(rw.num_points)
ax.scatter(rw.x_values, rw.y_values, c=point_numbers, cmap=plt.cm.Blues,
edgecolors='none', s=1)
--snip--
这个示例模拟了一次包含50 000个点的随机游走，并将每个点的大小 都设置为1。最终的随机游走图像云雾一般，如图15-11所示。我们使 用简单的散点图制作出了一件艺术品！
图15-11包含50 000个点的随机游走
请尝试修改上述代码，看看将游走包含的点增加到多少个以后，程序 的运行速度将变得极其缓慢或绘图将变得很难看。
05.调整尺寸以适应屏幕
当图形适应屏幕的大小时，能更有效地将数据的规律呈现出来。为了 让绘图窗口更适应屏幕的大小，可在subplots()调用中调整 Matplotlib输出的尺寸：
fig, ax = plt.subplots(figsize=(15, 9))
在创建绘图时，可向subplots()传递参数figsize,以指定生成 的图形尺寸。参数figsize是一个元组，向Matplotlib指出绘图窗口 的尺寸，单位为英寸。
Matplotlib假定屏幕的分辨率为每英寸100像素。如果上述代码指定的 绘图尺寸不合适，可根据需要调整数值。如果知道当前系统的分辨 率，可通过参数dpi向plt.subplots()传递该分辨率：
fig, ax = plt.subplots(figsize=(10, 6), dpi=128)
这有助于高效地利用屏幕空间。
动手试一试
练习15.3 :分子运动 修改rw_visual.py,将其中的ax.scatter() 替换为ax.plot()0为了模拟花粉在水滴表面的运动路径，向 plt.plot()传递 rw.x_values 和 rw.y_values,并指定实参 linewidth。请使用5000个点而不是50 000个点，以免绘图中的点 过于密集。
练习15.4 :改进的随机游走 在RandomWalk类中，x_step和 y_step是根据相同的条件生成的：从列表［1, -1］中随机地选择方 向，并从列表［0, 1, 2, 3, 4］中随机地选择距离。请修改这些列 表中的值，看看对随机游走路径有何影响。尝试使用更长的距离选择 列表(如0〜8),或者将-1从x方向或y方向列表中删除。
练习15.5 :重构fill_walk()方法很长。请新建一个名为 get_step()的方法，用于确定每次游走的距离和方向，并计算这次 游走将如何移动。然后，在fill_walk()中调用get_step()两 次：
x_step = self.get_step() y_step = self.get_step()
通过这样的重构，可缩小fill_walk()方法的规模，让它阅读和理 解起来更容易。
15.4使用Plotly模拟掷骰子
本节将使用Plotly来生成交互式图形。当需要创建要在浏览器中显示的图 形时，Plotly很有用，因为它生成的图形将自动缩放，以适应观看者的屏 幕。Plotly生成的图形还是交互式的：当用户将鼠标指向特定的元素时，将 显示有关该元素的信息。本节将使用Plotly Express来创建初始图形。Plotly Express是Plotly的一个子集，致力于让用户使用尽可能少的代码来生成绘 图。我们将先使用几行代码生成初始绘图，在确定输出正确后再像使用 Matplotlib那样对绘图进行定制。
在这个项目中，我们将对掷骰子的结果进行分析。在掷一个6面的常规骰 子时，可能出现的结果为1〜6点，且出现每种结果的可能性相同。然而， 如果同时掷两个骰子，某些点数出现的可能性将比其他点数大。为了确定 哪些点数出现的可能性最大，要生成一个表示掷骰子结果的数据集，并根 据结果绘图。
这项工作有助于模拟涉及掷骰子的游戏，其中的核心理念也适用于所有涉 及概率的游戏（如扑克牌）。此外，在随机性扮演着重要角色的众多现实 场景中，它也能发挥作用。
15.4.1	安装 Plotly
要安装Plotly,可像本章前面安装Matplotlib那样使用pip :
$ python -m pip install --user plotly $ python -m pip install --user pandas
Plotly Express依赖于pandas （一个用于高效地处理数据的库），因此需要 同时安装pandas。如果前面在安装Matplotlib时，使用的是python3之类 的命令，这里也要使用同样的命令。
要了解使用Plotly可创建什么样的图形，请访问Plotly主页并单击DOCS 下拉菜单中的GRAPHING LIBRARIES,然后单击Python图标或在
Languages 下拉菜单中选择 Python,打开“Plotly Open Source Graphing
Library for Python"。每个示例都包含源代码，让你知道这些图形是如何生 成的。
15.4.2	创建Die类
为了模拟掷一个骰子的情况，创建下面的类：
die.py
from random import randint
class Die:
"""表示一个骰子的类"""
❶ def __init__(self, num_sides=6):
"""骰子默认为6面的"""
self.num_sides = num_sides
def roll(self):
""""返回一个介于1和骰子面数之间的随机值"""
❷	return randint(1, self.num_sides)
__init__()方法接受一个可选参数。创建这个类的实例时，如果没有指 定任何实参，面数默认为6 ；如果指定了实参，则这个值将用于设置骰子的 面数(见❶)。骰子是根据面数命名的，6面的骰子名为D6, 8面的骰子名 为D8,依此类推。
roll()方法使用randint()函数来返回一个介于1和面数之间的随机数 (见❷)。这个函数可能返回起始值(1)、终止值(num_sides)或这两 个值之间的任意整数。
15.4.3	掷骰子
使用这个类来创建图形前，先来掷一个D6,将结果打印出来，并确认结果 是合理的：
die_visual.py
from die import Die
#创建一个D6
❶ die = Die()
#掷几次骰子并将结果存储在一个列表中 results = []
❷ for roll_num in range(100): result = die.roll() results.append(result)
print(results)
首先创建一个Die实例，其面数为默认值6 （见❶）。然后掷骰子100
次，并将每次的结果都存储在列表results中（见❷）。下面是一个示例 结果集：
[4,	6,	5,	6,	1,	5,	6,	3,	5,	3,	5,	3,	2,	2,	1,	3,	1,	5,	3,	6,	3,	6,	5,
4, 1,	1,	4,	2,	3,	6,	4,	2,	6,	4,	1,	3,	2,	5,	6,	3,	6,	2,	1,	1,	3,	4,	1,
4, 3,	5,	1,	4,	5,	5,	2,	3,	3,	1,	2,	3,	5,	6,	2,	5,	6,	1,	3,	2,	1,	1,	1,
6, 5,	5,	2,	2,	6,	4,	1,	4,	5,	1,	1,	1,	4,	5,	3,	3,	1,	3,	5,	4,	5,	6,	5,
4, 1,	5,	1,	2]																			
通过快速浏览这些结果可知，Die类看起来没有问题。我们看到了 1和6, 这表明返回了最大和最小的可能值；没有看到0或7,这表明结果都在正确 的范围内；还看到了 1〜6的所有数字，这表明所有可能的结果都出现了。 下面来确定各个点数都出现了多少次。
15.4.4	分析结果
为了分析掷一个D6的结果，计算每个点数出现的次数：
die_visual.py
--snip--
#掷几次骰子并将结果存储在一个列表中 results = []
❶ for roll_num in range(1000):
result = die.roll()
results.append(result)
# 结果
frequencies = []
❷ poss_results = range(1, die.num_sides+1) for value in poss_results:
❸	frequency = results.count(value)
❹	frequencies.append(frequency)
print(frequencies)
由于不再将结果打印出来，因此可将模拟掷骰子的次数增加到1000 （见
❶）。为了分析结果，创建空列表frequencies,用于存储每个点数出现 的次数。然后，生成所有可能的点数（这里为1到骰子的面数）（见
❷），遍历这些点数并计算每个点数在results中出现了多少次（见 ❸），再将这个值追加到列表frequencies的末尾（见❹）。接下来， 在可视化之前将这个列表打印出来：
[155, 167, 168, 170, 159, 181]
结果看起来是合理的：有6个值，分别对应掷D6时可能出现的每个点数； 没有任何点数出现的频率比其他点数高很多。下面来可视化这些结果。
15.4.5绘制直方图
有了所需的数据，就可以使用Plotly Express来创建图形了。只需要几行代 码：
die_visual.py
import plotly.express as px
from die import Die
--snip--
for value in poss_results:
frequency = results.count（value）
frequencies.append（frequency）
#对结果进行可视化
fig = px.bar(x=poss_results, y=frequencies) fig.show()
首先导入模块plotly.express,并按照惯例给它指定别名px。然后， 使用函数px.bar()创建一个直方图。对于这个函数，最简单的用法是只 向它传递一组x坐标值和一组y坐标值。这里传递的x坐标值为掷一个骰子 可能得到的结果，而y坐标值为每种结果出现的次数。
最后一行调用fig.show(),让Plotly将生成的直方图渲染为HTML文 件，并在一个新的浏览器选项卡中打开这个文件。结果如图15-12所示。
图15-12 Plotly Express生成的初始直方图
这个直方图非常简单，但并不完整。然而，这正是Plotly Express的用途所 在：让你编写几行代码就能查看生成的图，确定它以你希望的方式呈现了 数据。如果你对结果大致满意，可进一步定制图形元素，如标签和样式。 然而，如果你想使用其他的图表类型，也可马上做出改变，而不用花额外 的时间来定制当前的图形。请现在就尝试这样做，比如将px.bar()替换 为px.scatter()或px.line()o有关完整的图表类型清单，请单击刚
才打开的“Plotly Open Source Graphing Library for Python”页面中的 Plotly Express。
这个直方图是动态、可交互的。如果你调整浏览器窗口的尺寸，该图将自 动调整大小，以适应可用空间。如果你将鼠标指向条形，将显示与该条形 相关的数据。
15.4.6	定制绘图
确定选择的绘图是你想要的类型且数据得到准确的呈现后，便可专注于添 加合适的标签和样式了。
要使用Plotly定制绘图，一种方式是在调用生成绘图的函数（这里是 px.bar（））时传递一些可选参数。下面演示了如何指定图题并给每条坐标 轴添加标签：
die_visual.py
--snip--
#对结果进行可视化
❶ title = "Results of Rolling One D6 1,000 Times"
❷ labels = {'x': 'Result', 'y': 'Frequency of Result'} fig = px.bar(x=poss_results, y=frequencies, title=title, labels=labels)
fig.show()
首先定义图题，并将其赋给变量title （见❶）。为了定义坐标轴标签， 创建一个字典（见❷），其中的键是要添加标签的坐标轴，而值是要添加 的标签。这里给X轴指定标签“Result”，给y轴指定标签“Frequency of Result”。现在调用px.bar（）时，会向它传递可选参数title和 labels。
现在，生成的直方图将包含标题和坐标轴标签，如图15-13所示。
1-nsBa JQ AoUBnbB」L
图15-13使用Plotly创建的简单直方图
15.4.7	同时掷两个骰子
同时掷两个骰子时，得到的点数往往更多，结果分布情况也有所不同。下 面来修改前面的代码，创建两个D6以模拟同时掷两个骰子的情况。每次掷 两个骰子时，都将两个骰子的点数相加，并将结果存储在results中。请 复制die_visual.py并将其保存为dice_visual.py,再做如下修改：
dice_visual.py
import plotly.express as px
from die import Die
#创建两个D6
die_1 = Die()
die_2 = Die()
#掷骰子多次，并将结果存储到一个列表中
results = []
for roll_num in range(1000):
❶ result = die_1.roll() + die_2.roll()
results.append(result)
#分析结果
frequencies = []
❷ max_result = die_1.num_sides + die_2.num_sides
❸ poss_results = range(2, max_result+1)
for value in poss_results:
frequency = results.count(value) frequencies.append(frequency)
#可视化结果
title = "Results of Rolling Two D6 Dice 1,000 Times"
labels = {'x': 'Result', 'y': 'Frequency of Result'}
fig = px.bar(x=poss_results, y=frequencies, title=title, labels=labels)
fig.show()
创建两个Die实例后，多次投掷，并计算每次的总点数（见❶）。可能出 现的最小总点数为两个骰子的最小可能点数之和（2）,可能出现的最大总 点数为两个骰子的最大可能点数之和（12）,这个值被赋给max_result （见❷）。使用变量max_result让生成poss_results的代码容易理
解得多（见❸）。我们原本可以使用range（2, 13）,但这只适用于两个 D6。在模拟现实世界的情形时，最好编写可轻松地模拟各种情形的代码。
前面的代码让我们能够模拟掷任意两个骰子的情形，不管这些骰子有多少 面。
运行这些代码后，将看到如图15-14所示的图形。
12Z0A1
Q 127AO.1 48916
Results of Rolling Two D6 Dice 1,000 Times
上 nsOJa J。AUU ①

图15-14模拟同时掷两个6面骰子1000次的结果
该图显示了掷两个D6得到的大致结果分布情况。如你所见，总点数为2或 12的可能性最小，而总点数为7的可能性最大。这是因为在下面6种情况 下得到的总点数都为7 ： 1和6、2和5、3和4、4和3、5和2、6和1。
15.4.8进一步定制
刚才生成的绘图存在一个问题，应予以解决：尽管有11个条形，但x轴的 默认布局设置未给所有条形加上标签。虽然对大多数可视化图形来说，这 种默认设置的效果很好，但就这里而言，给所有的条形都加上标签效果更 佳。
Plotly提供了 update_layout()方法，可用来对创建的图形做各种修 改。下面演示了如何让Plotly给每个条形都加上标签：
dice_visual.py
--snip--
fig = px.bar(x=poss_results, y=frequencies, title=title, labels=labels)
#进一步定制图形
fig.update_layout(xaxis_dtick=1)
fig.show()
对表示整张图的fig对象调用update_layout()方法。这里传递了参数 xaxis_dtick,它指定x轴上刻度标记的间距。我们将这个间距设置为 1,给每个条形都加上标签。如果你再次运行dice_visual.py,将发现每个条 形都有标签了。
15.4.9同时掷两个面数不同的骰子
下面来创建一个6面骰子和一个10面骰子，看看同时掷这两个骰子50 000 次的结果如何：
dice_visual_d6d10.py
import plotly.express as px
from die import Die
#	创建一个D6和一个D10
die_1 = Die()
❶ die_2 = Die(10)
#	掷骰子多次，并将结果存储在一个列表中
results = []
for roll_num in range(50_000):
result = die_1.roll() + die_2.roll()
results.append(result)
#	分析结果
--snip--
#可视化结果
❷ title = "Results of Rolling a D6 and a D10 50,000 Times
labels = {'x': 'Result', 'y': 'Frequency of Result'}
--snip--
为了创建D10,我们在创建第二个Die实例时传递了实参10 (见❶)我们 还修改了第一个循环，模拟掷骰子50 000次而不是1000次。此外，还修改
了图题(见❷)。
图15-15显示了最终的结果。可能性最大的点数不是一个，而是5个。这是 因为最小点数和最大点数的组合都只有一种(1和1以及6和10),但面 数较少的骰子限制了得到中间点数的组合数：得到总点数7、8、9、10和 11的组合数都是6种。因此，这些总点数是最常见的结果，它们出现的可 能性相同。
527.0.0.1
127.0LQ.1 4S900
tS + ©
Results of Rolling a D6 and a DIO 50,000 Times
a-ns9a Jo AUUBnbCL)」LL.
©
图15-15同时掷一个6面般子和一个10面般子50 000次的结果
使用Plotly来模拟掷骰子的结果，能够非常自由地探索其分布情况。只需 几分钟，就可以模拟掷各种骰子很多次。
15.4.10保存图形
生成你喜欢的图形后，就可以通过浏览器将其保存为HTML文件了，不过 你也可以用代码完成这项任务。要将图形保存为HTML文件，可将 fig.show()替换为 fig.write_html():
fig.write_html('dice_visual_d6d10.html')
write_html()方法接受一个参数：要写入的文件的名称。如果你只提供 了文件名，这个文件将被保存到.py文件所在的目录中。在调用 write_html()方法时，还可以向它传递一个Path对象，让你能够将输 出文件保存到系统中的任何地方。
动手试一试
练习15.6 :两个D8编写一个程序，模拟同时掷两个8面骰子1000 次的结果。先想象一下结果会是什么样的，再运行这个程序，看看你 的直觉准不准。逐渐增加掷骰子的次数，直到系统不堪重负为止。
练习15.7：同时挪三个般子 在同时掷三个D6时，可能得到的最小点 数为3,最大点数为18。请通过可视化展示同时掷三个D6的结果。
练习15.8 :将点数相乘 在同时掷两个骰子时，通常将它们的点数相 力口，下面换个思路。请通过可视化展示将两个骰子的点数相乘的结 果。
练习15.9 :改用列表推导式 为清晰起见，本节在模拟掷骰子的结果 时，使用的是较长的for循环。如果你熟悉列表推导式，可以尝试将 这些程序中的一个或两个for循环改为列表推导式。
练习15.10 :练习使用Matplotlib和Plotly这两个库 尝试使用 Matplotlib通过可视化来模拟掷骰子的情况，并尝试使用Plotly通过可 视化来模拟随机游走的情况。要完成这个练习，需要查看这两个库的 文档。
15.5小结
在本章中，你学习了如何生成数据集以及如何进行数据可视化，包括如何 使用Matplotlib创建简单的绘图，以及如何使用散点图来探索随机游走过 程。你还学习了如何使用Plotly来创建直方图，以及如何使用直方图来探 索同时掷两个面数不同的骰子的结果。
使用代码生成数据集是一种有趣而强大的方式，可用于模拟和探索现实世 界的各种情形。在完成后面的数据可视化项目时，请注意可使用代码模拟 哪些情形。请研究新闻媒体中的可视化案例，看看其中图表的生成方式是 否与本章中的项目类似。
在第16章中，我们将从网上下载数据，并继续使用Matplotlib和Plotly来 探索这些数据。

第16章下载数据

本章将从网上下载数据，并对其进行可视化。网上的数据多得令人难以置信，其中大多未被仔细研究过。如果能够对这些数据进行分析， 就能发现别人没有发现的规律和关联。

我们将接触以两种常见格式（CSV和JSON）存储的数据并将其可视化。首先使用Python模块csv来处理以CSV格式存储的天气数据，找出两个截然不同的地区在一段时间内的最高温度和最低温度。然后使用Matplotlib根 据下载的数据创建图形，展示这两个地区的温度变化。最后使用json模块访问以GeoJSON格式存储的地震数据，并使用Plotly绘制一幅散点图， 展示这些地震的位置和强度。
阅读本章后，你将能够处理各种类型和格式的数据集，并对如何创建复杂的图形有更深入的认识。要处理各种真实的数据集，必须能够访问并可视化网络数据。

16.1	CSV文件格式
要在文本文件中存储数据，最简单的方式是将数据组织为一系列以逗号分隔的值（comma-separated values, CSV）并写入文件。这样的文件称为CSV文件。例如，下面是一行CSV格式的天气数据：
"USW00025333","SITKA AIRPORT, AK US","2021-01-01",,"44","40"
这是美国阿拉斯加州锡特卡2021年1月1日的天气数据，其中包含当天的 最高温度和最低温度，等等。CSV文件阅读起来比较麻烦，但程序能够快 速而准确地提取并处理其中的信息。
我们将首先处理少量CSV格式的锡特卡天气数据，这些数据可在本书的源 代码文件中找到。请在存储本章程序的文件夹中新建一个名为weather_data 的文件夹，再将文件sitka_weather_072021_simple.csv复制到这个文件夹 中。（下载本书的源代码文件后，就有了这个项目所需的所有文件。）
注意：这个项目使用的天气数据下载自NOAA Climate Data Online。
16.1.1	解析CSV文件头
csv模块包含在Python标准库中，可用于解析CSV文件中的数据行，让我 们能够快速提取感兴趣的值。先来查看这个文件的第一行，其中的一系列 文件头（file header, CSV文件的列标题行）指出了后续各行包含的是什么 样的信息：
sitka_highs.py
from pathlib import Path import csv
❶ path = Path('weather_data/sitka_weather_07-2021_simple.csv') lines = path.read_text().splitlines()
❷ reader = csv.reader(lines)
❸ header_row = next(reader) print(header_row)
首先，导入Path类和csv模块。然后，创建一个Path对象，它指向文 件夹weather_data中我们要使用的天气数据文件（见❶）。我们读取这个文 件，并通过把splitlines（）纳入方法链式调用来获取一个包含文件中各 行的列表，再将这个列表赋给变量lines。
接下来，创建一个reader对象（见❷），用于解析文件的各行。为了创 建reader对象，调用csv.reader（）函数并将包含CSV文件中各行的 列表传递给它。
当以reader对象为参数时，函数next（）返回文件中的下一行（从文件 开头开始）。在上述代码中，只调用了 next（） 一次，且是首次调用，因 此得到的是文件的第一行，其中包含文件头（见❸）。接着将返回的数据 赋给header_row0如你所见，header_row包含与天气相关的文件头， 指出了每行都包含哪些数据：
['STATION', 'NAME', 'DATE', 'TAVG', 'TMAX', 'TMIN']
reader对象处理文件中以逗号分隔的第一行数据，并将每项数据都作为一 个元素存储在列表中。文件头STATION表示该列中的数据是记录数据的气 象站的编码。这个文件头的位置表明，每行的第一个值都是气象站编码。 文件头NAME指出每行的第二个值都是记录数据的气象站的名称。其他文 件头则指出记录了哪些信息。当前，我们最关心的是日期（DATE）、最高 温度（TMAX）和最低温度（TMIN）。这是一个简单的数据集，只包含与温 度相关的数据。你自己下载天气数据时，可选择包含其他的值，如风速、 风向和降水量数据。
16.1.2	打印文件头及其位值
为了让文件头数据更容易理解，我们将列表中的每个文件头及其位置打印 出来：
sitka_highs.py
--snip--
reader = csv.reader(lines) header_row = next(reader)
for index, column_header in enumerate(header_row): print(index, column_header)
在循环中，对列表调用enumerate。来获取每个元素的索引及其值。
（请注意，这里删除了代码行print（header_row）,以显示更详细的版 本。）
输出如下，指出了每个文件头的索引：
0 STATION
1	NAME
2	DATE
3	TAVG
4	TMAX
5	TMIN
从中可知，日期和最高温度分别存储在第3列（索引为2）和第5列（索引 为4）中。为了研究这些数据，我们将处理sitka_weather_07-2021_simple.csv中的每行数据，并提取索引为2和4的值。
16.1.3提取并读取数据
知道需要哪些列中的数据后，我们来读取一些数据。首先，读取每日最高 温度：
sitka_highs.py
--snip--
reader = csv.reader(lines) header_row = next(reader)
#提高温
❶ highs = []
❷ for row in reader:
❸ high = int(row[4]) highs.append(high)
print(highs)
先创建一个名为highs的空列表（见❶），再遍历文件中余下的各行（见 ❷）。reader对象从刚才中断的地方继续往下读取CSV文件，每次都自 动返回当前所处位置的下一行。由于已经读取了文件头行，这个循环将从 第二行开始——从这行开始才是实际数据。每次执行循环时，都将索引为4
（TMAX列）的数据追加到highs的末尾（见❸）。在文件中，这项数据 是以字符串的格式存储的，因此在追加到highs的末尾前，要使用函数 int（）将其转换为数值格式，以便使用。
highs现在存储的数据如下：
[61, 60, 66, 60, 65, 59, 58, 58, 57, 60, 60, 60, 57, 58, 60, 61, 63,
63,	70,
64,	59, 63, 61, 58, 59, 64, 62, 70, 70, 73, 66]
提取每日最高温度并将其存储到列表中之后，就可以可视化这些数据了。
16.1.4绘制温度图
为了可视化这些温度数据，首先使用Matplotlib创建一个显示每日最高温度 的简单绘图，如下所示：
sitka_highs.py
from pathlib import Path
import csv
import matplotlib.pyplot as plt
path = Path('weather_data/sitka_weather_07-2021_simple.csv')
lines = path.read_text().splitlines()
--snip--
#根据最高温度绘图
plt.style.use('seaborn')
fig, ax = plt.subplots()
❶ ax.plot(highs, color='red')
#设1■绘图的格式
❷ ax.set_title("Daily High Temperatures, July 2021", fontsize=24)
❸ ax.set_xlabel('', fontsize=16)
ax.set_ylabel("Temperature (F)", fontsize=16)
ax.tick_params(labelsize=16)
plt.show()
将最高温度列表传给plot（）（见❶），并传递color='red'以便将数据 点绘制为红色。（这里用红色显示最高温度，用蓝色显示最低温度。）接 下来，像第15章那样设置一些其他的格式，如标题、字号和标签（见 ❷）。鉴于还没有添加日期，因此这里没有给x轴添加标签，但 ax.set_xlabel（）确实修改了字号，让默认标签更容易看清（见❸）。 图16-1显示了生成的绘图：一个简单的折线图，显示了阿拉斯加州锡特卡 2021年7月的每日最后温度。
图16-1展示阿拉斯加州锡特卡2021年7月每日最高温度的折线图

16.1.5	datetime 模块
下面学习在图中添加日期，使其更为有用。在天气数据文件中，第一个日 期在第二行：
USW00025333","SITKA AIRPORT, AK US","2021-07-01",,"61","53"
在读取该数据时，获得的是一个字符串，因此需要想办法将字符串"2021-7-1"转换为一个表示相应日期的对象。为了创建一个表示2021年7月1 日的对象，可使用datetime模块中的strptime()方法。我们在终端会 话中看看strptime()的工作原理：
>>> from datetime import datetime
>>> first_date = datetime.strptime('2021-07-01', '%Y-%m-%d')
>>> print(first_date)
2021-07-01 00:00:00
首先导入datetime模块中的datetime类，再调用strptime()方 法，并将包含日期的字符串作为第一个实参。第二个实参告诉Python如何 设置日期的格式。在这里，‘％Y-'让Python将字符串中第一个连字符前面 的部分视为四位数的年份，‘％m-'让Python将第二个连字符前面的部分视 为表示月份的两位数，‘％d'让Python将字符串的最后一部分视为月份中 的一天(1〜31)。
strptime()方法的第二个实参可接受各种以％打头的参数，并根据它们 来决定如何解读日期。表16-1列出了一些这样的参数。
表16-1 datetime模块中设置日期和时间格式的参数
	
%A	星期几，如Monday
%B	月份名，如January
%m	用数表示的月份(01〜12)
%d	用数表示的月份中的一天(01〜31)
	含义
%Y	四位数的年份，如2019
%y	两位数的年份，如19
%H	24小时制的小时数（00〜23）
%I	12小时制的小时数（01〜12）
%p	am 或 pm
%M	分钟数（00〜59）
%S	秒数（00〜61）
16.1.6	在图中添加日期
现在可对温度图进行改进了——提取日期和最高温度，并将日期作为x坐 标值：
sitka_highs.py
from pathlib import Path
import csv
from datetime import datetime
import matplotlib.pyplot as plt
path = Path('weather_data/sitka_weather_07-2021_simple.csv')
lines = path.read_text().splitlines()
reader = csv.reader(lines)
header_row = next(reader)
#提取日期和最高温度
❶ dates, highs = [], [] for row in reader:
❷ current_date = datetime.strptime(row[2], '%Y-%m-%d')
high = int(row[4])
dates.append(current_date)
highs.append(high)
#根据数据绘图
plt.style.use('seaborn')
fig, ax = plt.subplots()
❸ ax.plot(dates, highs, color='red')
#设置绘图的格式
ax.set_title("Daily High Temperatures, July 2021", fontsize=24) ax.set_xlabel('', fontsize=16)
❹ fig.autofmt_xdate()
ax.set_ylabel("Temperature (F)", fontsize=16) ax.tick_params(labelsize=16)
plt.show()
这里创建了两个空列表，用于存储从文件中提取的日期和最高温度（见
❶）。然后,将包含日期信息的数据（row[2]）转换为datetime对象
（见❷），并将其追加到列表dates的末尾。在❸处，将日期和最高温度 值传递给plot（）0在❹处，调用fig.autofmt_xdate（）来绘制倾斜的 日期标签，以免它们彼此重叠。图16-2显示了改进后的图。
Daily High Temperatures, July 2021
图16-2现在的x轴上有日期，含义更为丰富
16.1.7涵盖更长的时间
设置好图形后，我们来添加更多的数据，生成一幅更复杂的锡特卡天气 图。请将文件sitka_weather_2021_simple.csv复制到本章所用数据所在的文 件夹中，该文件包含整年的锡特卡天气数据。
现在可以创建整年的天气图了：
sitka_highs.py
-	-snip--
path = Path('weather_data/sitka_weather_2021_simple.csv')
lines = path.read_text().splitlines()
-	-snip--
#	设置绘图的格式
ax.set_title("Daily High Temperatures, 2021", fontsize=24)
ax.set_xlabel('', fontsize=16)
-	-snip--
这里修改了文件名，以使用数据文件sitka_weather_2021_simple.csv,还修 改了图题，以反映其内容的变化。图16-3显示了生成的绘图。
图16-3 一年的天气数据
16.1.8	再绘制据系列
为了让我们的图更有用，还可以添加最低温度数据。只需要从数据文件中 提取最低温度，并将它们添加到图中即可，如下所示：
sitka_highs_lows.py
-	-snip--
reader = csv.reader(lines) header_row = next(reader)
#	提取日期、最高温度和最低温度
❶ dates, highs, lows = [], [], []
for row in reader:
current_date = datetime.strptime(row[2], '%Y-%m-%d')
high = int(row[4])
❷ low = int(row[5])
dates.append(current_date) highs.append(high)
lows.append(low)
#	根据数据绘图
plt.style.use('seaborn')
fig, ax = plt.subplots()
ax.plot(dates, highs, color='red')
❸ ax.plot(dates, lows, color='blue')
#	设置绘图的格式
❹ ax.set_title("Daily High and Low Temperatures, 2021", fontsize=24)
-	-snip--
在❶处，添加空列表lows,用于存储最低温度。接下来，从每行的第6列 (row[5])提取最低温度并存储(见❷)。在❸处，添加调用plot()的 代码，以使用蓝色绘制最低温度。最后，修改图题(见❹)。图16-4显示 了这样绘制出来的图。
图16-4在一张图中包含两个数据系列
16.1.9	给图中区域着色
添加两个数据系列后，就能知道每天的温度范围了。下面来给这张图做最 后的修饰，通过着色来呈现每天的温度范围。为此，将使用 fill_between（）方法，它接受一组x坐标值和两组y坐标值，并填充两 组y坐标值之间的空间：
sitka_highs_lows.py
--snip--
#根据最低和最高温度绘图
plt.style.use('seaborn')
fig, ax = plt.subplots()
❶ ax.plot(dates, highs, color='red', alpha=0.5)
ax.plot(dates, lows, color='blue', alpha=0.5)
❷ ax.fill_between(dates, highs, lows, facecolor='blue', alpha=0.1)
--snip--
实参alpha指定颜色的透明度（见❶）。alpha值为0表示完全透明，为 1 （默认设置）表示完全不透明。通过将alpha设置为0.5,可让红色和蓝 色折线的颜色看起来更浅。
在❷处，向fill_between()传递一组x坐标值 例表dates)和两组y 坐标值(highs和lows)。实参facecolor指定填充区域的颜色，我们 还将alpha设置成了较小的值0.1,让填充区域既能将两个数据系列连接 起来，又不分散观看者的注意力。图16-5显示了最高温度和最低温度之间 的区域被填充颜色后的绘图。
Daily High and Low Temperatures, 2021
图16-5给两个数据集之间的区域着色
着色让两个数据集之间的区域变得更显眼了。
16.1.10错误检查
我们应该能够使用任何地方的天气数据来运行sitka_highs_lows.py中的代 码，但有些气象站收集的数据类型有所不同，还有些会偶尔出故障，未能 收集部分或全部应收集的数据。缺失数据可能引发异常，如果不妥善处 理，还可能会导致程序崩溃。
例如，我们来看看生成美国加利福尼亚州死亡谷的温度图时会出现什么情 况。请将文件death_valley_2021_simple.csv复制到本章所用数据所在的文件 夹中 s 并将 sitka_highs_lows.py 另存为 death_valley_highs_lows.py0
首先通过编写代码来查看这个数据文件包含的文件头:
death_valley_highs_lows.py
from pathlib import Path
import csv
path = Path('weather_data/death_valley_2021_simple.csv') lines = path.read_text().splitlines()
reader = csv.reader(lines)
header_row = next(reader)
for index, column_header in enumerate(header_row): print(index, column_header)
输出如下：
0	STATION
1	NAME
2	DATE
3	TMAX
4	TMIN
5	TOBS
与前面一样，日期也在索引2处，但最高温度和最低温度分别在索引3和4 处，因此需要修改代码中的索引，以反映这一点。另外，这个气象站没有 记录平均温度，而记录了 TOBS,即特定时间点的温度。
下面来修改death_valley_highs_lows.py,使用前面所说的索引来生成死亡谷 的天气图，看看将出现什么状况：
death_valley_highs_lows.py
--snip--
path = Path('weather_data/death_valley_2021_simple.csv') lines = path.read_text().splitlines()
--snip--
#提取日期、最高温度和最低温度
dates, highs, lows = [], [], []
for row in reader:
current_date = datetime.strptime(row[2], '%Y-%m-%d')
high = int(row[3])
low = int(row[4])
dates.append(current_date)
--snip—
我们修改了程序，使其读取死亡谷天气数据文件，还修改了索引，使其对 应于这个文件中TMAX和TMIN的位置。
运行这个程序时出现了错误：
Traceback (most recent call last):
File "death_valley_highs_lows.py", line 17, in <module> high = int(row[3])
❶ ValueError: invalid literal for int() with base 10: ''
该traceback指出，Python无法处理其中一天的最高温度，因为它无法将空 字符串（''）转换为整数（见❶）。虽然只要看一下文件 death_valley_2021_simple.csv,就知道缺失了哪一项数据，但这里不这样 做，而是直接对缺失数据的情形进行处理。
为此，在从CSV文件中读取值时加入错误检查代码，对可能出现的异常进 行处理，如下所示：
death_valley_highs_lows.py
--snip--
for row in reader:
current_date = datetime.strptime(row[2], '%Y-%m-%d')
❶ try:
high = int(row[3])
low = int(row[4])
except ValueError:
❷	print(f"Missing data for {current_date}")
❸ else:
dates.append(current_date)
highs.append(high) lows.append(low)
#根据最高温度和最低温度绘图
--snip--
#设置绘图的格式
❹ title = "Daily High and Low Temperatures, 2021\nDeath Valley, CA" ax.set_title(title, fontsize=20)
ax.set_xlabel(
--snip--
, fontsize=16)
对于每一行数据，我们都尝试从中提取日期、最高温度和最低温度（见 ❶）。只要缺失最高温度或最低温度，Python就会引发ValueError异 常。我们这样处理异常：打印一条错误消息，指出缺失数据的日期（见 ❷）。打印错误消息后，循环将接着处理下一行。如果在获取特定日期的 所有数据时没有发生错误，就运行else代码块，将数据追加到相应列表 的末尾（见❸）。这里在绘图时使用的是有关另一个地方的信息，因此修 改标题以指出这个地方。因为标题较长，所以我们缩小了字号（见❹）。
如果现在运行death_valley_highs_lows.py,将发现缺失数据的日期只有一 个：
Missing data for 2021-05-04 00:00:00
妥善地处理错误之后, 6显示了绘制出的图o
代码就能够忽略缺失数据的那天并生成绘图。图16-
Daily High and Low Temperatures, 2021 Death Valley, CA
图16-6死亡谷的每日最高温度和最低温度
将这张图与锡特卡的图进行比较可知，总体而言，死亡谷比锡特卡热，这 符合预期。同时，沙漠中的死亡谷每天的温差也更大——从着色区域的高 度可以看出这一点。
你使用的很多数据集可能会有缺失数据、格式不正确或数据本身不正确的 问题。对于这些情形，可以使用第一部分介绍的工具来处理。这里使用了 一个try-except-else代码块来处理数据缺失的问题。在有些情况下, 需要使用continue跳过一些数据，或者使用remove()或del将已提 取的数据删除。可采用任何有效的方法，只要能进行精确而有意义的可视 化就好。
动手试一试
练习16.1 :锡特卡的降雨・ 锡特卡属于温带雨林，降水量非常丰
富。在数据文件 sitka_weather_2021_full.csv 中，文件头PRCP表示的 是每日降水量，请对这列数据进行可视化。如果你想知道沙漠的降水 量有多少，可针对死亡谷完成这个练习。
练习16.2 :比较锡特卡和死亡谷的温度 在有关锡特卡和死亡谷的图 中，温度刻度表示的数据范围不同。为了准确地比较锡特卡和死亡谷 的温度范围，需要在y轴上使用相同的刻度。为此，请修改图16-5和 图16-6所示图形的y轴设置，对锡特卡和死亡谷的温度范围进行直接 比较(也可对任意两个地方的温度范围进行比较)。
练习16.3 :旧金山 旧金山的温度更接近锡特卡还是死亡谷呢？为了 找到答案，可下载一些有关旧金山的温度数据，并据此生成包含最高 温度和最低温度的绘图。
练习16.4 :自动索引 本节以硬编码的方式指定了 TMIN列和TMAX列 的索引。请根据文件头行确定这些列的索引，让程序同时适用于锡特 卡和死亡谷。另外，请根据气象站的名称自动生成图题。
练习16.5 :探索 生成一些图形，对你感兴趣的任何地方的其他天气 数据进行研究。
16.2制作全球地X散点图：GeoJSON格式
本节将首先下载一个数据集，其中记录了一个月内全球发生的所有地震， 然后制作一幅散点图，展示这些地震的位置和震级。这些数据是以 GeoJSON格式（基于JSON的地理空间信息数据交换格式）存储的，因此 要使用json模块来处理。我们将使用Plotly来创建图形，清楚地指出全球 的地震分布情况。
16.2.1	地 1RK据
在用于存储本章程序的文件夹中，新建一个文件夹并将其命名为eq_data, 再将文件eq_1_day_m1.geojson复制到这个新建的文件夹中。地震规模通常 是以里氏震级度量的，而这个文件记录了在（截至写作本节时）过去24小 时内全球发生的所有不低于1级的地震。
16.2.2	查看 GeoJSON JHg
打开文件eq_1_day_m1.geojson,我们发现内容密密麻麻，难以阅读：
{"type":"FeatureCollection","metadata":{"generated":1649052296000, {"type":"Feature","properties":{"mag":1.6,"place":"63 km SE of Ped {"type":"Feature","properties":{"mag":2.2,"place":"27 km SSE of Ca {"type":"Feature","properties":{"mag":3.7,"place":"102 km SSE of S {"type":"Feature","properties":{"mag":2.92000008,"place":"49 km SE {"type":"Feature","properties":{"mag":1.4,"place":"44 km NE of Sus --snip--
这些数据适合机器读取，而不是人来阅读。不过还是可以看到，这个文件 包含一些字典，还有一些我们感兴趣的信息，如震级和位置。
json模块提供了探索和处理JSON数据的各种工具，其中一些有助于重新 设置这个文件的格式，让我们能够更清楚地查看原始数据，继而决定如何 以编程的方式处理它们。
首先加载这些数据并以易于阅读的方式显示它们。这个数据文件很长，因 此不打印它，而是将数据写入另一个文件，从而可以打开这个文件并轻松 地滚动查看：
eq_explore_data.py
from pathlib import Path import json
#将数据作为字符串读取并转换为Python对象
path = Path('eq_data/eq_data_1_day_m1.geojson') contents = path.read_text()
❶ all_eq_data = json.loads(contents)
#将数据文件转换为更易于阅读的版本
❷ path = Path('eq_data/readable_eq_data.geojson')
❸ readable_contents = json.dumps(all_eq_data, indent=4) path.write_text(readable_contents)
首先将这个数据文件作为字符串进行读取，并使用json.loads（）将这个 文件的字符串表示转换为Python对象（见❶）。这里使用的方法与第10章 中相同。我们将整个数据集转换成一个字典，并将其赋给变量 all_eq_data。然后,定义一个新的Path对象，用于以更易于阅读的方 式存储这些数据（见❷）。json.dumps（）函数在第10章介绍过，它接受 可选参数indent （见❸），指定数据结构中嵌套元素的缩进量。
如果现在查看目录eq_data并打开其中的文件readable_eq_data.geojson,将 发现其开头部分像下面这样：
readable_eq_data.geojson
{
"type": "FeatureCollection",
❶ "metadata": {
"generated": 1649052296000,
"url":
"https://earthquake.example/earthquakes/.../1.0_day.geojson",
"title": "USGS Magnitude 1.0+ Earthquakes, Past Day",
"status": 200,
"api": "1.10.3",
"count": 160
},
❷ "features": [
--snip--
这个文件的开头是一个键为"metadata"的片段（见❶），指出了这个数 据文件的生成时间和网址。它还包含适合人类阅读的标题，以及文件中记 录了多少次地震：在过去的24小时内，发生了 160次地震。
这个GeoJSON文件的结构适合存储基于位置的数据。数据存储在一个与键 "features"相关联的列表中（见❷）。这个文件包含的是地震数据，因 此列表的每个元素都对应一次地震。这种结构虽然可能有点令人迷惑，但 很有用，让地质学家能够将有关每次地震的任意数量的信息存储在一个字 典中，再将这些字典放在一个大型列表中。
我们来看看表示特定地震的字典：
readable_eq_data.geojson
--snip--
{
"type": "Feature",
❶	"properties": {
"mag": 1.6, --snip--
❷	"title": "M 1.6 - 27 km NNW of Susitna, Alaska"
},
❸	"geometry": {
"type": "Point", "coordinates": [
❹	-150.7585,
❺	61.7591,
56.3
]
}, "id": "ak0224bju1jx"
},
键"properties"关联了大量与特定地震相关的信息（见❶）。我们关心 的主要是与键"mag"相关联的地震强度，还有地震的"title",它很好 地概述了地震的震级和位置（见❷）。
键"geometry"指出了地震发生在什么地方（见❸），我们需要根据这项 信息将地震在散点图上标出来。在与键"coordinates"相关联的列表 中，可以找到地震发生位置的经度（见❹）和纬度（见❺）。
这个文件的嵌套层级比我们编写的代码层级多，即使这让你感到迷惑，也 不用担心，Python将替你处理大部分复杂的工作。我们每次只会处理一两 个嵌套层级。我们将首先提取过去24小时内发生的每次地震对应的字典。
注意：在说到位置时，通常先说纬度再说经度，这种习惯形成的原因 可能是人类先发现了纬度，很久后才有经度的概念。然而，很多地质 学框架会先列出经度后列出纬度，因为这与数学约定（x,y）一致。
GeoJSON格式遵循（经度，纬度）的约定，但在使用其他框架时，遵循相 应的约定很重要。
16.2.3	创建地震列表
首先创建一个列表，其中包含所有地震的各种信息。
eq_explore_data.py
from pathlib import Path import json
#将数据作为字符串读取并转换为Python对象
path = Path('eq_data/eq_data_1_day_m1.geojson') contents = path.read_text()
all_eq_data = json.loads(contents)
#查看数据集中的所有地屋
all_eq_dicts = all_eq_data['features'] print(len(all_eq_dicts))
我们从字典all_eq_data中提取与键'features'相关联的数据，并将 其赋给变量all_eq_dicts。我们知道，这个文件记录了 160次地震。下 面的输出表明，我们提取了这个文件记录的所有地震：
160
注意，我们编写的代码很短。虽然格式良好的文件readable_eq_data.geojson 包含的内容超过6000行，但只需几行代码，就可读取所有的数据并将它们 存储到一个Python列表中。下面将提取所有地震的震级。
16.2.4	提取震级
有了这个包含所有地震数据的列表，就可以遍历它，从中提取所需的数据 To下面来提取每次地震的震级：
eq_explore_data.py
--snip--
all_eq_dicts = all_eq_data['features']
❶ mags = [] for eq_dict in all_eq_dicts:
❷ mag = eq_dict['properties']['mag'] mags.append(mag)
print(mags[:10])
先创建一个空列表，用于存储地震的震级，再遍历列表all_eq_dicts (见❶)。每次地震的震级都存储在相应字典的‘properties'部分的
'mag'键下(见❷)。我们依次将地震的震级存储在变量mag中，再将这 个变量追加到列表mags的末尾。
为了确定提取的数据是否正确，打印前10次地震的震级：
[1.6, 1.6, 2.2, 3.7, 2.92000008, 1.4, 4.6, 4.5, 1.9, 1.8]
接下来，只需提取每次地震的位置信息，就可以绘制地震散点图了。
16.2.5	提取位I1数据
地震的位置数据存储在"geometry"键下。在"geometry"键关联的字 典机有一个"coordinates"键，它关联到一个列表，其中的前两个值 为经度和纬度。下面演示了如何提取位置数据：
eq_explore_data.py
--snip--
all_eq_dicts = all_eq_data['features']
mags, titles, lons, lats = [], [], [], []
for eq_dict in all_eq_dicts:
mag = eq_dict['properties']['mag']
❶	title = eq_dict['properties']['title']
❷	lon = eq_dict['geometry']['coordinates'][0]
lat = eq_dict['geometry']['coordinates'][1] mags.append(mag)
titles.append(title)
lons.append(lon)
lats.append(lat)
print(mags[:10])
print(titles[:2])
print(lons[:5])
print(lats[:5])
我们创建了用于存储位置标题的列表titles,来提取字典 'properties'里的'title'键对应的值（见❶），还创建了用于存储 经度和纬度的空列表。代码eq_dict['geometry']访问与 "geometry"键相关联的字典（见❷）。第二个键（'coordinates'） 提取与'coordinates'相关联的列表，而索引0提取这个列表中的第一 个值，即地震发生位置的经度。
打印前5个经度和纬度，输出表明提取的数据是正确的：
[1.6, 1.6, 2.2, 3.7, 2.92000008, 1.4, 4.6, 4.5, 1.9, 1.8]
['M 1.6 - 27 km NNW of Susitna, Alaska', 'M 1.6 - 63 km SE of Pedro
Bay, Alaska']
[-150.7585, -153.4716, -148.7531, -159.6267, -155.248336791992]
[61.7591, 59.3152, 63.1633, 54.5612, 18.7551670074463]
有了这些数据，就可绘制地震散点图了。
16.2.6	绘制地膜散点图
有了前面提取的数据，就可以绘制简单的散点图了。这个散点图谈不上美 观，但这里只确保显示的信息正确无误就好，之后再专注于调整样式和外 观。
绘制初始散点图的代码如下：
eq_world_map.py
❶ import plotly.express as px
--snip--
❷ fig = px.scatter(
x=lons,
y=lats,
labels={'x':'献'，'y':'纬度'},
range_x二[-200, 200],
range_y=[-90, 90],
width=800,
height=800,
title='全球地!激点图'，
)
❸ fig.write_html('global_earthquakes.html')
❹ fig.show()
就像第15章那样，我们导入plotly.express并给它指定别名px （见 ❶）。然后,调用px.scatter函数配置参数，创建一个fig实例，分别 设置x轴为经度［范围是［-200, 200］（扩大空间，以便完整显示东西经 180°附近的地震散点）］、y轴为纬度（范围是［-90, 90］）,设置散点 图显示的宽度和高度均为800像素，并设置标题为“全球地震散点图”（见 ❷）。
只用14行代码，简单的散点图就配置完成了，这返回了一个fig对象。 fig.write_html方法可以将图形保存为.html文件。在文件夹中找到 global_earthquakes.html文件，用浏览器打开即可（见❸）。另外，如果使 用Jupyter Notebook,可以直接使用fig.show方法在notebook单元格中 显示散点图（见❹）。
局部效果如图16-7所示。
图16-7显示24小时内所有地腰的简单散点图
根据数据集里的信息正确地绘制了散点图后，还可以做大量的修改，使其 更有意义、更好懂。
16.2.7	指定数据的另一种方式
在配置这张图前，先来看看指定Plotly图形数据的另一种方式。当前，经 度和纬度数据是手动配置的：
--snip--		
x=lons,		
y=lats,		
labels={'x':	‘经底‘，'y'：	'纬度'},
--snip--		
这是在Plotly Express中给图形指定数据的最简单的方式之一，但在数据处 理中并不是最佳的。下面介绍给图形指定数据的一种等效方式，需要使用 pandas数据分析工具。首先创建一个DataFrame,将需要的数据封装起 来：
import pandas as pd
data = pd.DataFrame(
data=zip(lons, lats, titles, mags), columns=['经度'，'纬度'，'位置'，
‘震级’]
)
data.head()
然后，将配置参数的方式变更为
--snip-data, x='^SS', y二'纬度',
--snip--
这样，相关数据的所有信息都以键值对的形式放在一个字典中。如果在 eq_plot.py中使用这些代码，生成的绘图是一样的。相比之前的格式，这种 格式让我们能够无缝衔接数据分析，并且更轻松地对绘图进行定制。
16.2.8	定制标记的尺寸
在确定如何改进散点图的样式时，应着眼于让要传达的信息更清晰。当前 的散点图虽然显示了每次地震的位置，但没有指出震级。最好把图中的点 显示为不同的大小，以便观看者迅速发现最严重的地震发生在什么地方。
为此，根据地震的震级设置其标记的尺寸：
eq_world_map.py
fig = px.scatter( data,
x二'SST,
y二'纬度'， range_x=[-200, 200], range_y=[-90, 90], width=800,
height=800,
title='全球地震散点图'，
❶	size='1UK',
❷	size_max=10,
)
fig.write_html('global_earthquakes.html') fig.show()
Plotly Express支持对数据系列进行定制，这是以设置相应的参数来实现 的。这里使用size参数来指定散点图中每个标记的尺寸，只需要将前面 data中的'震级'字段提供给size参数即可（见❶）。另外，标记尺寸 默认为20像素，还可以通过size_max=l0将最大显示尺寸缩小到10像 素（见❷）O
如果运行这些代码，将看到类似于图16-8所示的散点图。它已经比图16-7 好多了，但还有很大的改进空间。
全球地震散点图
-200
-150
-100
-50
图16-8现在散点图显示了地奥的震级大小
这幅散点图更清晰了，但还可以做进一步的改进，同时使用颜色来表示地 震的震级。
16.2.9	定制标记的颤色
我们还可以定制标记的颜色，以呈现地震的严重程度。在执行这些修改之 前，将文件eq_data_30_day_m1.geojson复制到你的数据目录中，它包含30
天内的地震数据。使用这个更大的数据集，绘制出来的地震散点图将有趣 得多。
下面演示如何利用颜色渐变来呈现地震的震级：
eq_world_map.py
❶ path = Path('eq_data/eq_data_30_day_m1.geojson')	
❷	try: contents = path.read_text() except: contents = path.read_text(encoding='utf-8') --snip-- fig = px.scatter( data, x='经度'， y二'纬度'， range_x=[-200, 200], range_y=[-90, 90], width=800, height=800, title=’全球地震散点图'， size='震级’， size_max=10,
❸	color='HUK', ) --snip--
首先修改文件名eq_data_30_day_m1.geojson以使用30天的数据集（见 ❶）。该数据集中有些地区名称包含特殊字符，之前的代码 path.read_text（）在Linux和macOS系统中运行正常，但是在 Windows系统（默认编码是GBK）中运行时会出现 UnicodeDecodeError异常，因此需要通过try-except代码块进行异 常处理，使用 path.read_text（encoding='utf-8'）支持 UTF-8 编 码（见❷）。为了以不同的标记颜色表示震级，只需要配置color='震级 '即可。视觉映射图例的默认渐变色范围是从蓝色到红色再到黄色，数值越 小标记越蓝，而数值越大则标记越黄（见❸）。
现在运行这个程序，看到的散点图将漂亮得多，如图16-9所示。图中的颜 色指出了地震的严重程度：最严重的地震为浅黄色，在众多颜色较深的点
中显得格外醒目。通过在散点图上显示大量的地震，甚至能将板块的边界 大致呈现出来。
全球地震散点图
经度
-200
-150
-100
100
震级
-20
经度=7 30.7064
纬度=-54.6269
震级=4.8
图16-9使用不同颜色和尺寸呈现地现屋级的30天地震散点图
16.2.10	其他渐变
Plotly Express有大量的渐变可供选择。要知道有哪些渐变可供使用，可在 Python终端会话中执行下面两行加粗的代码：
>>> import plotly.express as px
>>> px.colors.named_colorscales()
['aggrnyl', 'agsunset', 'blackbody', ..., 'mygbm']
既可以尝试在这个地震散点图中使用这些渐变，也可以将它们用于连续变 化的颜色有助于呈现数据规律的数据集。
16.2.11	添加悬停文本
为了完成这幅散点图的绘制，我们将添加一些说明性文本，在你将鼠标指 向表示地震的标记时显示出来。除了默认显示的经度和纬度以外，这还将 显示震级以及地震的大致位置：
eq_world_map.py
fig = px.scatter( data,
x='经度'， y二'纬度'， range_x=[-200, 200],
range_y=[-90, 90],
width=800,
height=800,
title=’全球地震散点图'，
size='震级’， size_max=10, color='震级’，
hover_name='位厦'，
)
fig.write_html('global_earthquakes.html') fig.show()
--snip--
Plotly Express的操作非常简单，只需要将hover_name参数配置为data 的‘位置'字段即可。
现在运行这个程序，并将鼠标指向标记，将显示该地震发生在什么地方， 还有准确的震级，如图16-10所示。
全球地震散点图
20
-200
-100
50
100
150

图16-10悬停文本包含有关地腰的摘要信息
太令人震惊了！通过编写大约40行代码，我们就绘制了一幅漂亮的全球地 震活动散点图，展示了地球的板块结构。Plotly提供了众多定制图形外观和 行为的方式，使用它提供的众多选项，可让图形准确地显示你所需的信 息。

动手试一试
练习16.6 :重构 在从all_eq_dicts中提取数据的循环中，使用了变量来存储震级、经度、纬度和标题，再将这些值分别追加到相应列表的末尾。这旨在清晰地演示如何从GeoJSON文件中提取数据，但并 非必须这样做。你也可以不使用这些临时变量，而是直接从eq_dict 中提取这些值，并将它们追加到相应的列表末尾。这样做将缩短这个 循环的循环体，使其只包含4行代码。
练习16.7 :自动生成标题 本节中的图形使用的是通用标题“全球地震 散点图”。你也可以不这样做，而是将数据集的名称(title,它位于 GeoJSON文件的metadata部分)用作散点图的标题。为此，可提取 这个值并将其赋给变量title。
练习16.8 :最近发生的地厦 可参考本书在线资源下载包含最近1小 时、1天、7天和30天内地震信息的数据集。下载一个这样的数据集 之后，请绘制一幅散点图来展示最近发生的地震。
练习16.9 :全球火灾 在本章的源代码文件中，有一个名为
world_fires_1 _day.csv的文件，其中包含全球各地的火灾信息，这些信 息包括经度、纬度和火灾强度(brightness)。使用16.1节介绍的数据 处理技术以及本节介绍的散点图绘制技术，绘制一幅散点图展示哪些 地方发生了火灾。
16.3小结
在本章中，你学习了如何使用现实世界中的数据集，包括如何处理CSV和 GeoJSON文件，以及如何提取感兴趣的数据。利用以往的天气数据，你更 深入地学习了如何使用Matplotlib,包括如何使用datetime模块，以及如 何在同一个图形中绘制多个数据系列。你还学习了如何使用Plotly绘制呈 现地震数据的散点图，以及如何定制散点图的样式。
有了使用CSV和JSON文件的经验后，你就几乎能够处理要分析的任何数 据了。大多数在线数据集能以这两种格式中的一种或两种下载。熟悉了这 两种格式，再学习使用其他格式的数据会更加轻松。
在下一章中，你将编写自动从网上采集数据并对其进行可视化的程序。如 果你只是将编程作为业余爱好，学会这些技能可以做很多有趣的事；如果 你有志于成为专业程序员，就必须掌握这些技能。

# 第17章使用API
本章介绍如何编写一个独立的程序，对获取的数据进行可视化。这个 程序将使用应用程序接口 (application program interface, API)自动请 求网站的特定信息，并对这些信息进行可视化。这样编写的程序始终 使用最新的数据进行可视化，因此即便数据实时更新，图形呈现的信 息也是最新的。
17.1	簸 API
API是网站的一部分，用于与程序进行交互。这些程序使用非常具体的 URL请求特定的信息，而这种请求称为API调用。请求的数据将以程序易 于处理的格式（如JSON或CSV）返回。使用外部数据源的应用程序（如 集成了社交媒体网站的应用程序）大多依赖API调用。
17.1.1	Git 和 GitHub
本章会对来自GitHub的信息进行可视化。你也许了解，GitHub是一个让程 序员能够协作开发项目的网站。我们将使用GitHub的API来请求有关该网 站中Python项目的信息，再使用Plotly生成交互式的图形，以呈现这些项 目的受欢迎程度。
GitHub的名字源自Git,后者是一个分布式版本控制系统，帮助人们管理为 项目所做的工作，避免一个人所做的修改影响其他人的工作。当你在项目 中实现新功能时，Git会跟踪你对每个文件所做的修改。确定代码可行后， 你可以提交所做的修改，而Git将记录项目最新的状态。如果你犯了错，想 撤销所做的修改，可借助Git轻松地回退到以前的任意一个可行状态。（要 更深入地了解如何使用Git进行版本控制，请参阅附录Do ） GitHub上的 项目都存储在仓库（repository）中，后者包含与项目相关联的一切：代 码、项目参与者的信息、问题或bug报告，等等。
在GitHub上，用户不仅可以给喜欢的项目加星（star）来表示支持，还可 以关注自己可能想使用的项目。在本章中，我们将编写一个程序，自动下 载GitHub上星数最多的Python项目的信息，并对这些信息进行可视化。
17.1.2	使用API调用请求数据
GitHub的API让你能够通过API调用请求各种信息。要知道API调用是什 么样的，请在浏览器的地址栏中输入如下地址并按回车键：
https://api.github.com/search/repositories?q=language:python+sort:stars
这个API调用返回GitHub当前托管了多少个Python项目，以及有关最受 欢迎的Python仓库的信息。下面来仔细地研究这个API调用。开头的 https://api.github.com/ 是 GitHub 的 API 地址。接下来的 search/repositories 让 API 搜索 GitHub 上的所有仓库。
repositories后面的问号指出需要传递一个参数。参数q表示查询，而 等号（=）让我们能够开始指定查询（q=）。接着，通过
language:python指出只想获取主要语言为Python的仓库的信息。最后 的+sort:stars指定将项目按星数排序。
下面显示了响应的前几行。
{
❶ "total_count": 8961993,
❷ "incomplete_results": true,
❸ "items": [
{
"id": 54346799,
"node_id": "MDEwOlJlcG9zaXRvcnk1NDM0Njc5OQ==",
"name": "public-apis",
"full_name": "public-apis/public-apis", --snip--
从响应可知，该URL并不适合人工输入，因为它采用了适合程序处理的格 式。
在本书编写期间，GitHub总共有将近900万个Python项目（见
❶）o "incomplete_results"的值为true,表明GitHub没有处理完 这个查询（见❷）。为确保API能够及时地响应所有用户，GitHub对每个 查询的运行时间都进行了限制。在这里，GitHub找出了一些最受欢迎的 Python仓库，但由于时间不够，没能找出所有的Python仓库，稍后我们将 修复这个问题。接下来的列表显示了返回的"items",其中包含GitHub 上最受欢迎的Python项目的详细信息（见❸）。
17.1.3	安装 Requests
Requests包让Python程序能够轻松地向网站请求信息并检查返回的响应。 要安装Requests,可使用pip :
$ python -m pip install --user requests
如果你在运行程序或启动终端会话时使用的是命令python3,请使用下面 的命令来安装Requests包：
$ python3 -m pip install --user requests
17.1.4	AhS API 响应
下面来编写一个程序，自动执行API调用并处理结果：
python_repos.py
import requests
#	执行API调用并查看响应
❶ url = "https://api.github.com/search/repositories" url += "?q=language:python+sort:stars+stars:>10000"
❷ headers = {"Accept": "application/vnd.github.v3+json"}
❸ r = requests.get(url, headers=headers)
❹ print(f"Status code: {r.status_code}")
#	将响应转换为字典
❺ response_dict = r.json()
#	处理结果
print(response_dict.keys())
首先，导入requests模块。然后,将API调用的URL赋给变量url
（见❶）。这个URL很长，因此分成了两行：第一行是该URL的主要部 分，第二行是查询字符串。这里在前面使用的查询字符串的基础上添加了 条件stars:>10000,让GitHub只查找获得超过10 000颗星的Python仓 库。这应该让GitHub有足够的时间返回完整的结果。
最新的GitHub API版本为第3版，因此通过指定headers显式地要求使 用这个版本的API并返回JSON格式的结果（见❷）。然后,使用 requests 调用 API （见❸）。
我们调用get（）并将变量url和headers传递给它，再将响应对象存储 在变量r中。响应对象包含一个名为status_code的属性，指出请求是 否成功（状态码200表示请求成功）。我们打印status_code,以核实调 用是否成功（见❹）。前面已经让这个API返回JSON格式的信息了，因 此使用json（）方法将这些信息转换为一个Python字典（见❺），并将结 果赋给变量response_dict0
最后，打印response_dict中的键。输出如下：
Status code: 200
dict_keys（［'total_count', 'incomplete_results', 'items'］）
状态码为200,由此知道请求成功了。响应字典只包含三个
键：'total_count'、'incomplete_results'和'items'o 下面来 看看响应字典内部是什么样的。
17.1.5	处理响应字典
将API调用返回的信息存储到字典里后，就可处理其中的数据了。生成一 些概述这些信息的输出是一种不错的方式，可帮助我们确认收到了期望的 信息，进而开始研究感兴趣的信息：
python_repos.py
import requests
#	执行API调用并存储响应
-	-snip--
#	将响应转换为字典
response_dict = r.json()
❶ print(f"Total repositories: {response_dict['total_count']}")
print(f"Complete results: {not response_dict['incomplete_results']}")
#	探索有关仓库的信息
❷ repo_dicts = response_dict['items']
print(f"Repositories returned: {len(repo_dicts)}")
#	研究第库
❸ repo_dict = repo_dicts[0]
❹ print(f"\nKeys: {len(repo_dict)}")
❺ for key in sorted(repo_dict.keys()):
print(key)
为了探索响应字典，首先打印与'total_count'相关联的值，它指出 API调用返回了多少个Python仓库（见❶）。我们还查看了与 'incomplete_results'相关联的值，以便知道GitHub是否有足够的时 间处理完这个查询。这里没有直接打印这个值，而打印与之相反的值：如 果为True,就表明收到了完整的结果集。
与'items'关联的值是个列表，其中包含很多字典，而每个字典都包含有 关一个Python仓库的信息。我们将这个字典列表赋给repo_dicts （见 ❷），再打印repo_dicts的长度，以获悉获得了多少个仓库的信息。
为更深入地了解返回的有关每个仓库的信息，我们先提取repo_dicts中 的第一个字典，并将其赋给repo_dict （见❸），再打印这个字典包含的 键数，看看其中有多少项信息（见❹）。最后，打印这个字典的所有键， 看看其中包含哪些信息（见❺）。
输出让我们对实际包含的数据有更清晰的认识：
Status code: 200
❶ Total repositories: 248
❷ Complete results: True Repositories returned: 30
❸ Keys: 78 allow_forking archive_url archived
--snip--url
visiblity
watchers
watchers_count
在本书编写期间，只有248个Python仓库获得的星星超过10 000颗（见 ❶）。如你所见，GitHub有足够的时间处理完这个API调用（见❷）。在 这个响应中，GitHub返回了前30个满足查询条件的仓库的信息。如果要获 得更多仓库的信息，可请求额外的数据页。
GitHub的API返回有关仓库的大量信息：repo_dict包含78个键（见 ❸）。通过仔细查看这些键，能大致知道可提取有关项目的哪些信息。
（要准确地获悉API将返回哪些信息，要么阅读文档，要么像这里一样使 用代码来查看。）
下面来提取repo_dict中与一些键相关联的值：
python_repos.py
--snip--
#研究第一个仓库
repo_dict = repo_dicts[0]
print("\nSelected information about first repository:")
❶ print(f"Name: {repo_dict['name']}")
❷ print(f"Owner: {repo_dict['owner']['login']}")
❸ print(f"Stars: {repo_dict['stargazers_count']}") print(f"Repository: {repo_dict['html_url']}")
❹ print(f"Created: {repo_dict['created_at']}")
❺ print(f"Updated: {repo_dict['updated_at']}") print(f"Description: {repo_dict['description']}")
这里打印了与表示第一个仓库的字典中的很多键相对应的值。首先，打印 项目的名称（见❶）。项目所有者由一个字典表示，因此使用键owner来 访问表示所有者的字典，再使用键login来获取所有者的登录名（见 ❷）。接下来，打印项目获得了多少颗星（见❸），还有项目的GitHub仓 库的URL。然后，显示项目的创建时间（见❹）和最后一次更新的时间
（见❺）。最后，打印对仓库的描述。
输出类似于下面这样：
Status code: 200
Total repositories: 248
Complete results: True
Repositories returned: 30
Selected information about first repository:
Name: public-apis
Owner: public-apis
Stars: 191493
Repository: https://github.com/public-apis/public-apis
Created: 2016-03-20T23:49:42Z
Updated: 2022-05-12T06:37:11Z
Description: A collective list of free APIs
从上述输出可知，在本书编写期间，GitHub上星数最高的Python项目为 public-apis, 其所有者是一家名为public-apis的组织，有将近200 000位 GitHub用户给这项目加星了。可以看到这个项目的仓库的URL,项目的创 建时间为2016年3月，且最近更新了。最后，描述指出了项目public-apis 包含程序员可能感兴趣的一系列免费API。
17.1.6概述最受欢迎的仓库
在对这些数据进行可视化时，我们想涵盖多个仓库。下面就来编写一个循 环，打印API调用返回的每个仓库的特定信息，以便能够在图形中包含这 些信息：
python_repos.py
--snip--
#研究有关仓库的信息
repo_dicts = response_dict['items']
print(f"Repositories returned: {len(repo_dicts)}")
❶ print("\nSelected information about each repository:")
❷ for repo_dict in repo_dicts:
print(f"\nName: {repo_dict['name']}")
print(f"Owner: {repo_dict['owner']['login']}")
print(f"Stars: {repo_dict['stargazers_count']}") print(f"Repository: {repo_dict['html_url']}") print(f"Description: {repo_dict['description']}")
首先，打印一条说明性消息（见❶）。然后，遍历repo_dicts中的所有 字典（见❷）。在这个循环中，打印每个项目的名称、所有者、星数、在 GitHub上的URL以及描述：
Status code: 200
Total repositories: 248
Complete results: True
Repositories returned: 30
Selected information about each repository:
Name: public-apis
Owner: public-apis
Stars: 191494
Repository: https://github.com/public-apis/public-apis
Description: A collective list of free APIs
Name: system-design-primer
Owner: donnemartin
Stars: 179952
Repository: https://github.com/donnemartin/system-design-primer
Description: Learn how to design large-scale systems. Prep for the system
design interview. Includes Anki flashcards.
--snip--
Name: PayloadsAllTheThings
Owner: swisskyrepo
Stars: 37227
Repository: https://github.com/swisskyrepo/PayloadsAllTheThings
Description: A list of useful payloads and bypass for Web Application Security
and Pentest/CTF
在上述输出中，有些有趣的项目可能值得一看。但不要在输出的内容上花 费太多时间，因为即将创建的图形能让你更容易地看清结果。
17.1.7监控API的速率限制
大多数API存在速率限制，即在特定时间内可执行的请求数存在限制。要 获悉是否接近了 GitHub的限制，请在浏览器中输入
https://api.github.com/rate_limit,你将看到类似于下面的响应：
{
"resources": {
--snip--
❶ "search": {
❷	"limit": 10,
❸	"remaining": 9,
❹	"reset": 1652338832,
"used": 1,
"resource": "search
},
--snip--
我们关心的信息是搜索API的速率限制（见❶）。从❷处可知，限值为每 分钟10个请求，而在当前的这一分钟内，还可执行9个请求（见❸）。与 键reset对应的值是配额将被重置的Unix时间或新纪元时间（从1970年 1月1日零点开始经过的秒数）（见❹）。在用完配额后，我们将收到一条 简单的响应消息，得知已到达API的限值。到达限值后，必须等待配额重 置。
注意：很多API要求，在通过注册获得API密钥（访问令牌）后，才 能执行API调用。在本书编写期间，GitHub没有这样的要求，但获得 访问令牌后，配额将高得多。
17.2使用Plotly可视化仓库
下面使用收集到的数据来创建图形，以展示GitHub上Python项目的受欢迎 程度。我们将创建一个交互式条形图，其中条形的高度表示项目获得了多 少颗星，而单击条形将进入相应项目在GitHub上的主页。
请复制前面编写的python_repos_visual.py,并将副本修改成下面这样：
python_repos_visual.py
import requests
import plotly.express as px
#	执行API调用并查看响应
url = "https://api.github.com/search/repositories"
url += "?q=language:python+sort:stars+stars:>10000"
headers = {"Accept": "application/vnd.github.v3+json"}
r = requests.get(url, headers=headers)
❶ print(f"Status code: {r.status_code}")
#	处理结果 response_dict = r.json()
❷ print(f"Complete results: {not response_dict['incomplete_results']}")
#	处理有关仓库的信息
repo_dicts = response_dict['items']
❸ repo_names, stars = [], []
for repo_dict in repo_dicts:
repo_names.append(repo_dict['name'])
stars.append(repo_dict['stargazers_count'])
#	可视化
❹ fig = px.bar(x=repo_names, y=stars) fig.show()
先导入Plotly Express,再像前面那样执行API调用。然后，打印API调用 响应的状态，以确定是否出现了问题（见❶）。在处理结果时，我们也打 印一条消息，确认收到了完整的结果集（见❷）。然而，其他的print（） 调用都被删除了，这是因为我们确定获得了所需的数据，可跳过探索阶 段。
接下来，创建两个空列表，用于存储要在图形中呈现的数据(见❸)。我 们需要每个项目的名称(repo_names),用于给条形添加标签，还需要 知道项目获得了多少颗星(stars),以确定条形的高度。在循环中，将 每个项目的名称和星数分别附加到这两个列表的末尾。
只需要两行代码就可以生成初始图形(见❹)，这符合Plotly Express的理 念：让你能够尽快地看到可视化效果，确定没问题后再改进其外观。这里 使用px.bar()函数创建了一个条形图。在调用这个函数时，我们将参数 x和y分别设置成了列表repo_names和stars。
生成的图形如图17-1所示。从中可知，开头几个项目的受欢迎程度比其他 项目高得多，但所有这些项目在Python生态系统中都很重要。
图17-1 GitHub上最受欢迎的Python项目
17.2.1设置图形的样式
Plotly提供了众多定制图形以及设置其样式的方式，可在确定信息被正确地 可视化后使用。下面对px.bar()调用做些修改，并对创建的fig对象做
进一步的调整。
首先设置图形的样式一一添加图形的标题并给每条坐标轴添加标题：
python_repos_visual.py
--snip--
#可视化
title = "Most-Starred Python Projects on GitHub"
labels = {'x': 'Repository', 'y': 'Stars'}
fig = px.bar(x=repo_names, y=stars, title=title, labels=labels)
❶ fig.update_layout(title_font_size=28, xaxis_title_font_size=20, yaxis_title_font_size=20)
fig.show()
像第15章和第16章一样，我们添加了图形的标题，并给每条坐标轴都添 加了标题。然后，使用fig.update_layout()方法修改一些图形元素
(见❶)。在给图形元素命名时，Plotly用下划线分隔元素名称的不同部 分。熟悉Plotly文档后，你将发现，不同的图形元素的命名和修改方式是 一致的。这里将图形标题的字号设置成了 28,并将坐标轴标题的字号设置 为20o最终结果如图17-2所示。
• • • E < >	0	12Z0A1	6	④否 + 。
0 127.0lD.1：55249
a @+。E? 3 X « n
Most-Starred Python Projects on GitHub
图17-2给图形添加了名称，并给坐标轴添加了标签
17.2.2添加定制工具提示
在Plotly中，将鼠标指向条形将显示它表示的信息。这通常称为工具提示 (tooltip)。在这里，当前显示的是项目获得了多少颗星。下面来添加定制 工具提示，以显示项目的描述和所有者。
为生成这样的工具提示，需要再提取一些信息：
python_repos_visual.py
--snip--
#处理有关仓库的信息
repo_dicts = response_dict['items']
❶ repo_names, stars, hover_texts = [], [], []
for repo_dict in repo_dicts:
repo_names.append(repo_dict['name'])
stars.append(repo_dict['stargazers_count'])
❷
#创建悬停文本
owner = repo_dict['owner']['login']
description = repo_dict['description']
❸ hover_text = f"{owner}<br />{description}" hover_texts.append(hover_text)
#可视化
title = "Most-Starred Python Projects on GitHub"
labels = {'x': 'Repository', 'y': 'Stars'}
❹ fig = px.bar(x=repo_names, y=stars, title=title, labels=labels, hover_name=hover_texts)
fig.update_layout(title_font_size=28, xaxis_title_font_size=20, yaxis_title_font_size=20)
fig.show()
首先，定义一个新的空列表hover_texts, 用于存储要给各个项目显示的 文本（见❶）。在处理数据的循环中，提取每个项目的所有者和描述（见 ❷）。Plotly允许在文本元素中使用HTML代码，这让我们在创建由项目所 有者和描述组成的字符串时，能够在这两部分之间添加换行符（＜br /＞）
（见❸）。然后，我们将这个字符串追加到列表hover_texts的末尾。
在px.bar（）调用中，添加参数hover_name并将其设置为 hover_texts （见❹）。Plotly在创建每个条形时，都将提取这个列表中 的文本，并在观看者将鼠标指向条形时显示它们。图17-3显示了一个定制 工具提示。
图17-3将鼠标指向条形，还将显示项目的描述和所有者
17.2.3添加可单击的链接
Plotly允许在文本元素中使用HTML,这让你能够轻松地在图形中添加链 接。下面将x轴标签作为链接，让观看者能够访问项目在GitHub上的主 页。为此，需要提取URL并使用它们来生成x轴标签：
python_repos_visual.py
--snip--
#处理有关仓库的信息
repo_dicts = response_dict['items']
❶ repo_links, stars, hover_texts = [], [], []
for repo_dict in repo_dicts:
#将A库名转换为链接
repo_name = repo_dict['name']
❷	repo_url = repo_dict['html_url']
❸	repo_link = f"<a href='{repo_url}'>{repo_name}</a>
repo_links.append(repo_link)
stars.append(repo_dict['stargazers_count'])
--snip--
#可视化
title = "Most-Starred Python Projects on GitHub"
labels = {'x': 'Repository', 'y': 'Stars'}
fig = px.bar(x=repo_links, y=stars, title=title, labels=labels, hover_name=hover_texts)
fig.update_layout(title_font_size=28, xaxis_title_font_size=20, yaxis_title_font_size=20)
fig.show()
这里修改了列表的名称（从repo_names改为repo_links）,更准确地 指出了其中存放的是哪种信息（见❶）。然后，从repo_dict中提取项目 的URL,并将其赋给临时变量repo_url （见❷）。接下来，创建一个指 向项目的链接（见❸），为此使用了 HTML标签<a>,其格式为<a href='URL'>link text</a>。然后，将这个链接追加到列表 repo_links 的末尾。
在调用px.bar（）时，将列表repo_links用作图形的x坐标值。虽然生 成的图形与之前相同，但观看者可单击图形底端的项目名，以访问相应项 目在GitHub上的主页。至此，我们对API获取的数据进行了可视化，得到 的图形是可交互的，包含丰富的信息！
17.2.4定制标记颜色
创建图形后，可使用以update_打头的方法来定制其各个方面。前面使用 了 update_layout（）方法，而update_traces（）则可用来定制图形 呈现的数据。
我们将条形改为更深的蓝色并且是半透明的：
--snip--
fig.update_layout(title_font_size=28, xaxis_title_font_size=20, yaxis_title_font_size=20)
fig.update_traces(marker_color='SteelBlue', marker_opacity=0.6)
fig.show()
在Plotly中，trace指的是图形上的一系列数据。update_traces()方法 接受大量的参数，其中以marker_打头的参数都会影响图形上的标记。这 里将每个标记的颜色都设置成了 'SteelBlue'。你可将参数 marker_color设置为任何有具体名称的CSS颜色。我们还将每个标记的 不透明度都设置成了 0.6。不透明度值1.0表示完全不透明，而0表示完全 透明。
17.2.5 深入了解 Plotly 和 GitHub API
虽然Plotly提供了内容丰富、条理清晰的文档，但是可能让你觉得无从下 手。因此，要深入了解Plotly,最好先阅读文章Plotly Express in Python。这 篇文章概述了使用Plotly Express可创建的所有图表类型，其中还包含一些 链接，指向各种图表的详细介绍。
如果要深入地了解如何定制Plotly图形，可阅读文章Styling Plotly Express Figures in Python。这篇文章深入介绍了本书第15~17章提及的定制方式。
要深入地了解GitHub API,可参阅其文档。这样可知道如何从GitHub中提 取各种信息。要更深入地了解本章项目介绍的内容，可参阅该文档的 Search部分。如果有GitHub账户，除了其他仓库的公开信息以外，你还可 以提取有关自己的信息。
17.3 Hacker News API
为了探索如何使用其他网站的API调用，我们来看看Hacker News网站。
在这个网站上，用户分享编程和技术方面的文章，并就这些文章展开积极 的讨论。Hacker News的API让你能够访问有关该网站上所有文章和评论的 信息，并且不要求通过注册获得密钥。
下面的API调用返回本书编写期间Hacker News上最热门文章的信息：
https://hacker-news.firebaseio.com/v0/item/31353677.json
如果在浏览器中输入这个URL,你会发现响应的文章信息位于一对花括号 内，表明这是一个字典。如果不调整格式，这样的响应信息难以阅读。下 面像第16章中的地震项目那样，通过json.dumps()方法来处理这个 URL的内容，以便对返回的信息进行探索：
hn_article.py
import requests
import json
#	执行API调用并存储响应
url = "https://hacker-news.firebaseio.com/v0/item/31353677.json" r = requests.get(url)
print(f"Status code: {r.status_code}")
#	探索数据的结构
response_dict = r.json()
response_string = json.dumps(response_dict, indent=4)
❶ print(response_string)
这里的所有代码都在前两章中使用过，你应该不会感到陌生。主要的差别 在于，这里的响应字符串不是很长，因此在设置格式后直接打印(见 ❶)，而没有将其写入文件。
输出是一个字典，其中包含有关ID为31353677的文章的信息：
	{	"by": "sohkamyung",
❶		"descendants": 302, "id": 31353677,
❷		"kids": [ 31354987, 31354235, --snip-- ], "score": 785, "time": 1652361401,
❸		"title": "Astronomers reveal first image of the black hole at the heart of our galaxy", "type": "story",
❹	}	"url": "https://public.nrao.edu/news/.../"
这个字典包含很多键。与键'descendants'对应的值是文章被评论的次 数（见❶）。与键'kids'对应的值包含文章下所有评论的ID （见❷）。
每个评论本身也可能有评论，因此文章的descendant的数量可能比其kid的 数量多。这个字典中还包含当前文章的标题（见❸）和URL （见❹）。
下面的URL返回一个列表，其中包含Hacker News上当前排名靠前的文章 的ID :
https://hacker-news.firebaseio.com/v0/topstories.json
通过这个调用，可获悉当前有哪些文章位于 Hacker News 主页上，再生成 一系列类似于前面的API调用。使用这种方法，可概述当前位于Hacker News 主页上的每篇文章：
hn_submissions.py
from operator import itemgetter
import requests
#	执行API调用并查看响应
❶ url = "https://hacker-news.firebaseio.com/v0/topstories.json"
r = requests.get（url）
print（f"Status code: {r.status_code}"）
#处理有关每篇文章的信息
❷ submission_ids = r.json()
❸ submission_dicts = []
for submission_id in submission_ids[:5]:
#对于每篇文章，都执行一个API调用
❹ url = f"https://hacker-
news.firebaseio.com/v0/item/{submission_id}.json"
r = requests.get(url)
print(f"id: {submission_id}\tstatus: {r.status_code}") response_dict = r.json()
#对于每篇文章，都创建一个字典
❺ submission_dict = {
'title': response_dict['title'],
'hn_link': f"https://news.ycombinator.com/item?id= {submission_id}",
'comments': response_dict['descendants'],
}
❻ submission_dicts.append(submission_dict)
❼ submission_dicts = sorted(submission_dicts,
key=itemgetter('comments'),
reverse=True)
❽ for submission_dict in submission_dicts:
print(f"\nTitle: {submission_dict['title']}")
print(f"Discussion link: {submission_dict['hn_link']}") print(f"Comments: {submission_dict['comments']}")
首先，执行一个API调用，并打印响应的状态（见❶）。这个API调用返 回一个列表，其中包含 Hacker News上当前最热Pl的500篇文章的ID。接 下来，将响应对象转换为Python列表（见❷），并将其赋给 submission_ids。后面将使用这些ID来创建一系列字典，其中每个字 典都包含一篇文章的信息。
我们创建了一个名为submission_dicts的空列表，用于存储前面所说 的字典（见❸）。接下来，遍历前30篇文章的ID。对于每篇文章，都执行 一个API调用，其中的URL包含submission_id的当前值（见❹）。我 们打印请求的状态和文章的ID,以便知道请求是否成功。
接下来，为当前处理的文章创建一个字典（见❺），并在其中存储文章的 标题、链接和评论数。然后,将submission_dict追加到 submission_dicts 的末尾（见❻）。
Hacker News 上的文章是根据总体得分排名的，而总体得分取决于很多因 素，包括被推荐的次数、评论数和发表时间。我们要根据评论数（键 'comments'对应的值）对字典列表submission_dicts进行排序，为 此使用operator模块中的函数itemgetter（）（见❷）。我们向这个函 数传递了键'comments',因此它从这个列表的每个字典中提取与键 'comments'对应的值。这样，sorted（）函数将根据这些值对列表进行 排序。我们将列表按降序排列，即评论最多的文章位于最前面。
对列表排序后遍历它（见❽），并打印每篇热P1文章的三项信息：标题、 链接和评论数。
Status code: 200
id:	31390506	status:	200
id:	31389893	status:	200
id:	31390742	status:	200
--snip--
Title: Fly.io: The reclaimer of Heroku's magic
Discussion link: https://news.ycombinator.com/item?id=31390506
Comments: 134
Title: The weird Hewlett Packard FreeDOS option
Discussion link: https://news.ycombinator.com/item?id=31389893
Comments: 64
Title: Modern JavaScript Tutorial
Discussion link: https://news.ycombinator.com/item?id=31390742
Comments: 20
--snip--
无论使用哪个API来访问和分析信息，流程都与此类似。有了这些数据， 就可以进行可视化，指出最近哪些文章引发了最激烈的讨论。基于这种方 式，应用程序能够为用户提供网站（如Hacker News）的定制化阅读体验。 要更深入地了解通过Hacker News API可访问哪些信息，请参阅其文档页 面。
注意：Hacker News有时允许一些公司发布特殊的招聘帖子，并禁止对 这些帖子进行评论。如果你在运行这里的程序时，遇到这样的帖子， 将出现KeyError错误。如果这种错误会引发问题，可将创建
submission_dict的代码放在try-except代码块中，从而忽略这 样的帖子。
动手试一试
练习17.1 :其他语言 修改python_repos.py中的API调用，使其在生 成的图形中显示其他语言最受欢迎的项目。请尝试语言JavaScript、 Ruby、C、Java、Perl、Haskell 和 Go0
练习17.2 :最活跃的讨论 使用hn_submissions.py中的数据，创建一 个条形图，显示Hacker News上当前哪些文章下的讨论最活跃。条形 的高度应对应于文章的评论数。条形的标签应包含文章的标题，并且 充当文章的链接。如果创建图形时出现KeyError错误，请使用 try-except代码块来忽略特殊的招聘帖子。
练习 17.3 :测试 python_repos.py 在 python_repos.py 中，我们打印了 status_code的值，以核实API调用是否成功。请编写一个名为 test_python_repos.py 的程序,它使用 pytest 来断言 status_code 的值为200。想想还可做出哪些断言，如返回的条目（item）数符合预 期，仓库总数超过特定的值，等等。
练习17.4 :进一步探索 查看Plotly以及GitHub API或Hacker News
API的文档，根据从中获得的信息来定制本节绘制的图形的样式，或提 取并可视化其他数据。
17.4小结
在本章中，你学习了如何使用API来编写独立的程序，以自动采集所需的 数据并进行可视化。你不仅使用了 GitHub API来探索GitHub上星数最多的 Python项目，还大致了解了 Hacker News API,学到了如何使用Requests包 来自动执行API调用，以及如何处理调用的结果。本章还简要地介绍了一 些Plotly设置，可用其进一步定制生成的图形的外观。