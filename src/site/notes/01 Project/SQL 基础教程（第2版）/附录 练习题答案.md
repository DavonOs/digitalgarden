---
{"dg-publish":true,"dg-permalink":"books/27055712/appendix","permalink":"/books/27055712/appendix/","metatags":{"description":"","og:site_name":"DavonOs","og:title":"附录 练习题答案","og:type":"article","og:url":"https://zuji.eu.org/books/27055712/appendix","og:image":"https://file.ituring.com.cn/LargeCover/1712477631b07b9f5895","og:image:width":"200","og:image:alt":"articlecover","og:locale":"zh_cn"},"dgShowInlineTitle":true,"created":"2025-09-10 14:54","updated":"2025-09-11 08:25"}
---


※ 本附录中程序（SQL 语句）的答案并非唯一，还存在其他满足条件的解答方法。※ 代码清单中的“→”是为了配合页面显示所进行的换行操作。

1.1

CREATE TABLE Addressbook (

CREATE TABLE Addressbook (  regist_no INTEGER NOT NULL,  name VARCHAR (128) NOT NULL,  address VARCHAR (256) NOT NULL,  tel_no CHAR (10)  mail_address CHAR (20)  PRIMARY KEY (regist_no));

1.2

# PostgreSQL MySQL

ALTER TABLE Addressbook ADD COLUMN postal_code CHAR (8) NOT NULL;

# Oracle

ALTER TABLE Addressbook ADD (postal_code CHAR (8)) NOT NULL;

# SQL Server

ALTER TABLE Addressbook ADD postal_code CHAR (8) NOT NULL;

# DB 2

无法添加。

在 DB 2 中，如果要为添加的列设置 NOT NULL 约束，需要像下面这样指定默认值，或者删除 NOT NULL 约束，否则就无法添加新列。

# DB 2 修正版

ALTER TABLE Addressbook ADD COLUMN postal_code CHAR (8) NOT NULL DEFAULT 'C 000- 000';

1.3 DROP TABLE Addressbook;

1.4 删除后的表无法使用命令进行恢复。请使用习题 1.1 答案中的 CREATE TABLE 语句再次创建所需的表。

# 2.1

SELECT product_name, regist_date FROM Product WHERE regist_date >= '2009- 04- 28';

# 执行结果

product_name | regist_date T 恤衫 2009- 09- 20 打孔器 2009- 09- 11 菜刀 2009- 09- 20 叉子 2009- 09- 20 圆珠笔 2009- 11- 11

2.2  $① \sim ③$  中的 SQL 语句都无法选取出任何一条记录。

# 2.3 SELECT 语句  $①$

SELECT product_name, sale_price, purchase_price FROM Product WHERE sale_price >= purchase_price + 500;

# SELECT 语句  $②$

SELECT product_name, sale_price, purchase_price FROM Product WHERE sale_price - 500 >= purchase_price;

# 2.4

SELECT product_name, product_type, sale_price * 0.9 - purchase_price AS profit FROM Product WHERE sale_price * 0.9 - purchase_price > 100 AND ( product_type = '办公用品' OR product_type = '厨房用具');

# 执行结果

product_name | product_type | profit 打孔器 | 办公用品 | 130.0 高压锅 | 厨房用具 | 1120.0

3.1 存在以下 3 个错误。

1. 使用了字符类型的列（product_name）作为 SUM 函数的参数。

>>解答 SUM 函数只能使用数值类型的列作为参数。

2. WHERE 子句写在了 GROUP BY 子句之后。>>解答 WHERE 子句必须写在 GROUP BY 子句之前。

3. SELECT 子句中存在 GROUP BY 子句中未指定的列（product_id）。

>>解答

使用 GROUP BY 子句时，书写在 SELECT 子句中的列有很多限制。GROUP BY 子句中未指定的列不能书写在 SELECT 子句之中。

此外，虽然在 SELECT 子句和 FROM 子句之间添加注释在语法上没有问题，但因为这样会使 SQL 语句难以阅读，所以请不要这样书写。

在 WHERE 子句中指定 regist_date 的大小关系作为条件并没有什么问题。

# 3.2

SELECT product_type, SUM (sale_price), SUM (purchase_price) FROM Product GROUP BY product_type HAVING SUM (sale_price) > SUM (purchase_price) * 1.5;

>>解答

因为该 SELECT 语句是在按照商品种类进行分组之后，指定各组所对应的条件，所以使用了 HAVING 子句。条件为“大于 1.5 倍”，而不是“大于等于 1.5 倍”，因此条件表达式为“>”而不是“>=”。

# 3.3

SELECT * FROM Product ORDER BY regist_date DESC, sale_price;

>>解答

使用 ORDER BY 子句指定排列顺序之后，肯定有一列会按照升序或者降序进行排列。本习题中是登记日期（NULL 排在开头还是末尾会根据 DBMS 不同而不同，无需考虑）。因此我们能够推断出首先是按照登记日期的降序进行排序的。

接下来，对于日期相同的记录，例如同为“2009- 09- 20”的 3 条记录，可以看出是按照销售单价的升序进行排序的。

4.1 1 行也选取不出来。

>>解答

A 先生使用 BEGIN TRANSACTION 启动了事务处理，然后开始执行 INSERT 语句。因此，在 A 先生使用 COMMIT 确定该更新之前，B 先生等其他用户都无法看到 A 先生进行更新的结果。这就是基于 ACID 特性中的 I，也就是独立性（Isolation）的现象。当然，由于 A 先生在 COMMIT 之前能看到自己进行过的更新，因此如果 A 先生执行 SELECT * FROM Product; 的话，会得到 3 条记录。

顺便提一下，如果想要确认该现象，并不需要两个人。只需使用电脑打开两个窗口连接同一个数据库，一个人就能完成两个人的工作了。

4.2 因为商品编号列违反了主键约束，所以会发生错误，1 行也插入不了。

>>解答

如果该 INSERT 能够正常执行的话，Product（商品）表的状态应该会像下面这样变为 6 行数据。

Product（商品）表  

<table><tr><td>商品编号</td><td>商品名称</td><td>商品种类</td><td>销售单价</td><td>进货单价</td><td>登记日期</td></tr><tr><td>0001</td><td>T 恤衫</td><td>衣服</td><td>1000</td><td>500</td><td>2009-09-20</td></tr><tr><td>0002</td><td>打孔器</td><td>办公用品</td><td>500</td><td>320</td><td>2009-09-11</td></tr><tr><td>0003</td><td>运动 T 恤</td><td>衣服</td><td>4000</td><td>2800</td><td></td></tr><tr><td>0001</td><td>T 恤衫</td><td>衣服</td><td>1000</td><td>500</td><td>2009-09-20</td></tr><tr><td>0002</td><td>打孔器</td><td>办公用品</td><td>500</td><td>320</td><td>2009-09-11</td></tr><tr><td>0002</td><td>运动 T 恤</td><td>衣服</td><td>4000</td><td>2800</td><td></td></tr></table>

但是，显然上述记录违反了商品编号列的主键约束（不能存在主键重复的记录）。违反该约束带来的后果就是无法执行更新操作，这就是 ACID 特性中的 C——一致性（Consistency）。

# 4.3

INSERT INTO ProductMargin (product_id, product_name, sale_price, purchase_price, margin) SELECT product_id, product_name, sale_price, purchase_price, sale_price - purchase_price FROM Product;

# >>解答

Product（商品）表和 ProductMargin（商品利润）表中定义完全相同的列 product_id（商品编号）、product_name（商品名称）、sale_price（销售单价）、purchase_price（进货单价），可以通过 SELECT 语句直接从 Product（商品）表取出插入到 ProductMargin（商品利润）表中。只有 Product（商品）表中没有的 margin（利润）列的值需要根据 purchase_price 进货单价和 sale_price 销售单价进行计算。

4.4 1.

- - 下调销售单价 UPDATE ProductMarginSET sale_price = 3000 WHERE product_id = '0003';

2.

- - 重新计算利润 UPDATE ProductMarginSET margin = sale_price 
- purchase_priceWHERE product_id = '0003';

# 5.1

- - 创建视图的语句 CREATE VIEW ViewPractice 5_1 ASSELECT product_name, sale_price, regist_dateFROM ProductWHERE sale_price >= 1000 AND regist_date = '2009-09-20';

# 5.2 会发生错误。

# >>解答

对视图的更新归根结底是对视图所对应的表进行更新。因此，该 INSERT 语句实质上和下面的 INSERT 语句相同。

INSERT INTO Product (product_id, product_name, product_type, sale_price, purchase_price, regist_date) VALUES (NULL, '刀子', NULL, 300, NULL, '2009- 11- 02');

product_id（商品编号）product_name（商品名称）product_type（商品种类）3 列在表定义时都被赋予了 NOTNULL 约束。因此，向 product_id（商品编号）以及 product_type（商品种类）中插入 NULL 的 INSERT 语句是无法执行的。

并且，INSERT 语句中只对 product_name（商品名称）、sale_price（销售单价）、regist_date（登记日期）3 列进行了赋值，所以剩余的列都会被自动插入 NULL，于是就发生了错误。

# 注 1

其实 product_id（商品编号）是被赋予了主键约束，但其中默认包含了 NOTNULL 约束。

5.3

SELECT product_id, product_name, product_type, sale_price, {SELECT AVG (sale_price) FROM Product) AS sale_price_all FROM Product;

$\geq \geq$  解答一

使用标量子查询来计算销售单价的平均值。由于平均销售单价是 2097.5 这样一个单值，可以确定为标量值，因此可以书写在 SELECT 子句之中。

但是有没有读者会想到如下 SELECT 语句呢？

SELECT product_id, product_name, product_type, sale_price, AVG (sale_price) AS sale_price_all FROM Product;

上述 SELECT 语句会发生错误。原因在于 AVG 是一个聚合函数。正如 3- 2 节说明的那样，使用聚合函数时对书写在 SELECT 子句中的要素有很多限制。使用了这种错误方法的读者请重新阅读一下 3- 2 节中“常见错误①——在 SELECT 子句中书写了多余的列”部分的内容。

# 注 2

虽然在 MySQL 中该 SELECT 语句不会发生错误，但毕竟这只是基于 MySQL 特定需求的结果，无法在其他的 DBMS 中使用，并且得到的结果也完全不同。

# 5.4

- - 创建视图的语句 CREATE VIEW AvgPriceByType ASSELECT product_id, product_name, product_type, sale_price, (SELECT AVG (sale_price) FROM Product P 2 WHERE P 1. product_type = P 2. product_typeGROUP BY P 2. product_type) AS avg_sale_priceFROM Product P 1;

- - 删除视图的语句 DROP VIEW AvgPriceByType;

# $\geq \geq$  解答

在视图中包含的列中，除了 avg_sale_price 之外的 4 列（product_id、product_name、product_type、sale_price）在 Product 表中都存在，因此可以直接读取。但是，最后的 avg_sale_price（平均销售单价）则必须使用关联子查询进行结算。使用标量子查询和关联子查询也可以创建出上述视图。

# 6.1  $①$  的答案

<table><tr><td colspan="2">product_name | purchase_price</td></tr><tr><td>打孔器</td><td>320</td></tr><tr><td>擦菜板</td><td>790</td></tr></table>

# $\geq \geq$  解答

对于  $①$  的结果应该没有什么疑问。因为要选取的是进货单价（purchase_price）为 500 日元、2800 日元、5000 日元之外的商品（product_name），所以会得到 320 日元的打孔器和 790 日元的擦菜板两条记录。此外，不仅是 IN，通常的谓词都无法与 NULL 进行比较，因此进货单价（purchase_price）为 NULL 的叉子和圆珠笔都没有出现在结果之中。

# $(2)$  的答案：无法取出任何记录

product_name | purchase_price

# >>解答一

$②$  的结果有必要说明一下。  $(2)$  的 SQL 仅仅是在  $①$  的 NOTIN 的参数中增加了 NULL。并且  $①$  的结果中已经排除了进货单价 (purchase_price) 为 NULL 的记录，因此大家可能会觉得  $(2)$  的结果也是如此。但让人吃惊的是  $(2)$  的 SQL 却无法选取出任何记录。不仅仅是进货单价为 NULL 的记录，连从  $①$  中选取出的打孔器和擦菜板也不见了。

其实这是 SQL 中最危险的陷阱。NOTIN 的参数中包含 NULL 时结果通常会为空，也就是无法选取出任何记录。

为什么会得到这样的结果呢？其中的理由十分复杂，属于中级学习的范畴，因此本书中不会详细介绍。这里希望大家了解的是 NOTIN 的参数中不能包含 NULL。不仅仅是指定 NULL 的情况，使用子查询作为 NOTIN 的参数时，该子查询的返回值也不能是 NULL。请大家一定要遵守这一规定。

# 注①

想要了解为什么 NOTIN 会得到这样结果的读者，可以参考拙著《逢人 C 学 SQL 徹底指南書》（翔泳社）中 1- 3 节的内容。

6.2

SELECT SUM (CASE WHEN sale price  $< = 1000$  THEN 1 ELSE 0 END) AS low price, SUM (CASE WHEN sale price BETWEEN 1001 AND 3000 THEN 1 ELSE 0 END) AS mid price, SUM (CASE WHEN sale price  $> = 3001$  THEN 1 ELSE 0 END) AS high price FROM Product;

# >>解答一

大家发现了吗？这与我们在 6- 3 节中的“CASE 表达式的书写位置”中学过的使用 CASE 表达式进行行列变换是相似的问题。如果能够使用 CASE 表达式创建出 3 个分类条件的话，之后就可以将其与聚合函数进行组合了。只有计算中间额度商品的条件中的 BETWEEN 需要注意一下。

# 注②

此处的“中间额度”是笔者创造出来的词语，大家应该能理解其中的含义。

7.1 如下所示，会将 Product 表中的 8 行记录原封不动地选取出来。

执行结果  

<table><tr><td>product_id</td><td>product_name</td><td>product_type</td><td>sale_price</td><td>purchase_price</td><td>regist_date</td></tr><tr><td>0001</td><td>T 恤衫</td><td>衣服</td><td>1000</td><td>500</td><td>2009-09-20</td></tr><tr><td>0002</td><td>打孔器</td><td>办公用品</td><td>500</td><td>320</td><td>2009-09-11</td></tr><tr><td>0003</td><td>运动 T 恤</td><td>衣服</td><td>4000</td><td>2800</td><td></td></tr><tr><td>0004</td><td>菜刀</td><td>厨房用具</td><td>3000</td><td>2800</td><td>2009-09-20</td></tr><tr><td>0005</td><td>高压锅</td><td>厨房用具</td><td>6800</td><td>5000</td><td>2009-01-15</td></tr><tr><td>0006</td><td>叉子</td><td>厨房用具</td><td>500</td><td>790</td><td>2009-09-20</td></tr><tr><td>0007</td><td>擦菜板</td><td>厨房用具</td><td>880</td><td>790</td><td>2008-04-28</td></tr><tr><td>0008</td><td>圆珠笔</td><td>办公用品</td><td>100</td><td>2009-11-11</td><td></td></tr></table>

>>解答

可能有些读者会对此感到惊讶：“同时使用 UNION 和 INTERSECT 时，不是 INTERSECT 会优先执行吗？”当然，从执行顺序上来说确实是从 INTERSECT 开始的，但是在此之前，由于对同一张表使用了 UNION 或者 INTERSECT，因此结果并不会发生改变。也就是说，由于 UNION 或者 INTERSECT 未使用 ALL，会排除掉重复的记录，因此对同一张表来说，无论执行多少次操作，原表也不会发生改变。

7.2 SELECT 语句如下所示。

SELECT COALESCE (SP. shop_id,'不确定') AS shop_id, COALESCE (SP. shop_name,'不确定') AS shop_name, P.product_id, P.product_name, P.sale_price FROM ShopProduct SP RIGHT OUTER JOIN Product P ON SP. product_id = P.product_id ORDER BY shop_id;

>>解答

大家想起这个名字有点奇怪的 COALESCE 函数了吗？该函数可以将 NULL 变换为其他的值。虽然名字有些古怪，但使用却很频繁。特别是在希望改变外部连接结果中的 NULL 时，该函数是唯一的选择，因此希望大家能够牢记。

# 8.1 结果如下。

<table><tr><td>product_id</td><td>product_name</td><td>sale_price</td><td>current_max_price</td><td></td></tr><tr><td>0001</td><td>T 恤衫</td><td>1000</td><td>1000</td><td>←(1000) 的最大值</td></tr><tr><td>0002</td><td>打孔器</td><td>500</td><td>1000</td><td>←(1000, 500) 的最大值</td></tr><tr><td>0003</td><td>运动 T 恤</td><td>4000</td><td>4000</td><td>←(1000, 500, 4000) 的最大值</td></tr><tr><td>0004</td><td>菜刀</td><td>3000</td><td>4000</td><td>←(1000, 500, 4000, 3000) 的最大值</td></tr></table>

<table><tr><td>0005</td><td>高压锅</td><td>6800</td><td>6800</td></tr><tr><td>0005</td><td>叉子</td><td>500</td><td>6800</td></tr><tr><td>0007</td><td>擦菜板</td><td>880</td><td>6800</td></tr><tr><td>0008</td><td>圆珠笔</td><td>100</td><td>6800</td></tr></table>

>>解答

本题中 SELECT 语句的含义是“按照商品编号（product_id）的升序进行排序，计算出截至当前行的最高销售单价”。因此，在显示出最高销售单价的同时，窗口函数的返回结果也会变化。这恰好和奥运会等竞技体育的最高记录不断变化相似。随着商品编号越来越大，计算最大值的对象范围也不断扩大。就像随着时代变迁，运动员数量也会逐渐增加，要选出“历代第一”也会越来越难。

8.2  $①$  和  $(2)$  两种方法都可以实现

$①$  regist_date 为 NULL 时，显示“1 年 1 月 1 日”

SELECT regist_date, product_name, sale_price, SUM (sale_price) OVER (ORDER BY COALESCE (regist_date,CAST ('0001- 01- 01' AS DATE))) AS current_sum_price FROM Product;

# $②$  regist_date 为 NULL 时，将该记录放在最前显示

SELECT regist_date, product_name, sale_price, SUM (sale_price) OVER (ORDER BY regist_date NULLS FIRST) AS current - sum_price FROM Product;

两组答案的结果都如下所示

<table><tr><td>regist_date</td><td>product_name</td><td>sale_price</td><td>current_sum_price</td></tr><tr><td rowspan="2">2008-04-28</td><td>运动 T 恤</td><td>4000</td><td>4000</td></tr><tr><td>擦菜板</td><td>880</td><td>4880</td></tr><tr><td>2009-01-15</td><td>高压锅</td><td>6800</td><td>11680</td></tr><tr><td>2009-09-11</td><td>打孔器</td><td>500</td><td>12180</td></tr><tr><td>2009-09-20</td><td>T 恤衫</td><td>1000</td><td>16680</td></tr><tr><td>2009-09-20</td><td>菜刀</td><td>3000</td><td>16680</td></tr><tr><td>2009-09-20</td><td>叉子</td><td>500</td><td>16680</td></tr><tr><td>2009-11-11</td><td>圆珠笔</td><td>100</td><td>16780</td></tr></table>

>>解答

首先来看一下  $①$  ，这种方法比较简单。使用 COALESCE 函数可以将 NULL 转换为“1 年 1 月 1 日（公历）”。这样得到的结果就比其他任何日期都早了（即使同为“1

年 1 月 1 日”也没有关系）。这种“欺骗”DBMS 的方法恐怕很多读者都想到了吧。这也是在所有 DBMS 中通用的方法。

接下来我们再来看一下  $(2)$  ，其中包含了本书并未介绍的使用 NULLS FIRST 选项的方法。通过在 ORDER BY 子句中指定该选项，可以显式地给 DBMS 下达指令，在排序时将 NULL 放在最前面。目前该方法也是在支持窗口函数的 DBMS 中通用的方法。

本书之所以并未提及上述功能，是因为该功能并不是标准 SQL 支持的功能，而是依存于 DBMS 的实现。关于 NULL 的顺序，标准 SQL 中只规定要“排列在开头或者末尾”，至于到底是开头还是末尾，以及显式地指定的方法，都依存于 DBMS 的实现。

因此，大家需要注意，这些功能随时都有可能因为某个 DBMS 的需求改变而无法继续使用。

9.1

import java. sql.\*;

public class DBIns{ public static void main (String[] args) throws Exception { /\*1）PostgreSQL 的连接信息\*/ Connection con; Statement st; String url  $=$  "jdbc:postgresql://localhost: 5432/shop"; String user  $=$  "postgres"; String password  $=$  "test"; /\*2）定义 JDBC 驱动\*/ Class.forName ("org. postgresql. Driver"); /\*3）连接 PostgreSQL\*/ con  $=$  DriverManager.getConnection (url, user, password); st  $=$  con. createStatement（); /\*4）执行 INSERT 语句并显示结果\*/ int inscnt  $= 0$  重 inscnt  $=$  st.executeUpdate ("INSERT INTO Product VALUES ('0001', T 恤衫，'衣服'，1000，500，'2009- 09- 20")"); System.out.println (inscnt  $^+$  "行已经插入"）; inscnt  $=$  st.executeUpdate ("INSERT INTO Product VALUES ('0002'，打机器'，'办公用品'，500，320，'2009- 09- 11")）; System.out.println (inscnt  $^+$  "行已经插入"）; inscnt  $=$  st.executeUpdate ("INSERT INTO Product VALUES ('0003'，运动 T 恤，'衣服'，4000，2800，NULL)"); System.out.println (inscnt  $^+$  "行已经插入"）;

inscnt  $=$  st.executeUpdate ("INSERT INTO Product VALUES（0004'，'菜刀'，'厨房用具'，3000，2800，'2009- 09- 20'")；System. out. println（inscnt  $^+$  "行已经插入"）；inscnt  $=$  st.executeUpdate ("INSERT INTO Product VALUES（0005'，'高压锅'，'厨房用具'，6800，5000，'2009- 01- 15'")；System. out. println（inscnt  $^+$  "行已经插入"）；inscnt  $=$  st.executeUpdate ("INSERT INTO Product VALUES（0006'，'叉子'，'厨房用具'，500，NULL，'2009- 09- 20'")；System. out. println（inscnt  $^+$  "行已经插入"）；inscnt  $=$  st.executeUpdate ("INSERT INTO Product VALUES（0007'，'擦菜板'，'厨房用具'，880，790，'2009- 04- 28'")；System. out. println（inscnt  $^+$  "行已经插入"）；inscnt  $=$  st.executeUpdate ("INSERT INTO Product VALUES（0008'，'圆珠笔'，'办公用品'，100，NULL，'2009- 11- 11'")；System. out. println（inscnt  $^+$  "行已经插入"）；/\*5）断开与 PostgreSQL 的连接\*/con. close（); 1

表示下一行接续本行，只是由于版面所限而换行。

# 编译

C:\PostgreSQL\java\jdk\bin\javaicDBIns. java

执行

C:\PostgreSQL\java\jdk\bin\java - cp C:\PostgreSQL\jdbc\*;. DBIns

# $\geq \geq$  解答一

执行成功后，会在命令提示符窗口显示如下 8 行信息。

# 执行结果

1 行已经插入  1 行已经插入  1 行已经插入  1 行已经插入  1 行已经插入  1 行已经插入  1 行已经插入

可以通过执行 SELECT 语句来确认数据是否已经插入 Product 表中。

另外，在命令行窗口显示信息的语句[System.out.println (inscnt + "行已经插入")；]即使不写也不会影响插入功能的实现，写出来是为了在发生错误时方便调查。

9.2

import java. sql.\*; public class DBUpd{ public static void main (String[] args) throws Exception { /\*1）PostgreSQL 的连接信息\*/ Connection con; Statement st; String url  $=$  "jdbc:postgresql://localhost: 5432/shop"; String user  $=$  "postgres"; String password  $=$  "test"; /\*2）定义 JDBC 驱动\*/ Class.forName ("org. postgresql. Driver"); /\*3）连接 PostgreSQL\*/ con  $=$  DriverManager.getConnection (url, user, password); st  $=$  con. createStatement（); /\*4）执行 UPDATE 语句\*/ int inscnt  $= 0$  · Inscnt  $=$  st.executeUpdate ("UPDATE Product SET product_name  $=$  'Y 恤衫 WHERE product_id  $=$  '0001'"); System. out. println（inscnt  $^+$  "行已经更新"）; /\*5）断开与 PostgreSQL 的连接\*/ con. close（); 1

表示下一行接续本行，只是由于版面所限而换行。

# 编译

C:\PostgreSQL\java\jdk\bin\javac DBUpd. java

执行

C:\PostgreSQL\java\jdk\bin\java - cp C:\PostgreSQLjdbc\*;. DBUpd

# $\geq \geq$  解答

执行成功后，会在命令提示符窗口显示如下 1 行信息。

# 执行结果

1 行已经更新

执行 UPDATE 语句时，和执行 INSERT 一样，使用的是 executeUpdate 方法。后面的部分就是把 UPDATE 语句作为参数来执行。
