---
{"dg-publish":true,"dg-permalink":"books/27055712/07","permalink":"/books/27055712/07/","metatags":{"description":"","og:site_name":"DavonOs","og:title":"第7章 集合运算","og:type":"article","og:url":"https://zuji.eu.org/books/27055712/07","og:image":"https://file.ituring.com.cn/LargeCover/1712477631b07b9f5895","og:image:width":"200","og:image:alt":"articlecover","og:locale":"zh_cn"},"dgShowInlineTitle":true,"created":"2025-09-10 14:51","updated":"2025-09-11 08:25"}
---

# 表的加减法

# 学习重点

学习重点- 集合运算就是对满足同一规则的记录进行的加减等四则运算。- 使用 UNION（并集）、INTERSECT（交集）、EXCEPT（差集）等集合运算符来进行集合运算。- 集合运算符可以去除重复行。- 如果希望集合运算符保留重复行，就需要使用 ALL 选项。

# 什么是集合运算

# KEYWORD

集合运算集合记录的集合集合运算符

本章将会和大家一起学习集合运算操作。集合在数学领域表示“（各种各样的）事物的总和”，在数据库领域表示记录的集合。具体来说，表、视图和查询的执行结果都是记录的集合。

截至目前，我们已经学习了从表中读取数据以及插入数据的方法。所谓集合运算，就是对满足同一规则的记录进行的加减等四则运算。通过集合运算，可以得到两张表中记录的集合或者公共记录的集合，又或者其中某张表中的记录的集合。像这样用来进行集合运算的运算符称为集合运算符。

本节将会为大家介绍表的加减法，下一节将会和大家一起学习进行“表联结”的集合运算符及其使用方法。

# 表的加法 -UNION

# KEYWORD

$\bullet$  UNION（并集）

首先为大家介绍的集合运算符是进行记录加法运算的 UNION（并集）。

在学习具体的使用方法之前，我们首先添加一张表，该表的结构与之前我们使用的 Product（商品）表相同，只是表名变为 Product 2（商品 2）（代码清单 7- 1）。

# 代码清单 7-1 创建表 Product 2（商品 2）

CREATE TABLE Product 2 (product_id CHAR (4) NOT NULL, product_name VARCHAR (100) NOT NULL, product_type VARCHAR (32) NOT NULL, sale_price INTEGER , purchase_price INTEGER , regist_date DATE PRIMARY KEY (product_id));

接下来，我们将代码清单 7- 2 中的 5 条记录插入到 Product 2 表中。商品编号（product_id）为“0001”~“0003”的商品与之前 Product 表中的商品相同，而编号为“0009”的“手套”和“0010”的“水壶”是 Product 表中没有的商品。

# 代码清单 7-2 将数据插入到表 Product 2（商品 2）中

# SQL Server PostgreSQL

BEGIN TRANSACTION; INSERT INTO Product 2 VALUES ('0001', 'T 恤衫', '衣服', 1000, 500, '2008- 09- 20'); INSERT INTO Product 2 VALUES ('0002', '打孔器', '办公用品', 500, '2009- 09- 11'); INSERT INTO Product 2 VALUES ('0003', '运动 T 恤', '衣服', 4000, '2800, NULL'); INSERT INTO Product 2 VALUES ('0009', '手套', '衣服', 800, 500, NULL); INSERT INTO Product 2 VALUES ('0010', '水壶', '厨房用具', 2000, '2009- 09- 20'); COMMIT;

表示下一行接续本行，只是由于版面所限而换行。

# 特定的 SQL

不同的 DBMS 的事务处理的语法也不尽相同。代码清单 7- 2 中的 DML 语句在 MySQL 中执行时，需要将①部分更改为“START TRANSACTION;”。在 Oracle 和 DB 2 中执行时，无需用到①的部分（请删除）。详细内容请大家参考 4- 4 节中的“创建事务”。

这样我们的准备工作就完成了。接下来，就让我们对上述两张表进行“Product 表+Product 2 表”的加法计算吧。语法请参考代码清单 7- 3。

# 代码清单 7-3 使用 UNION 对表进行加法运算

SELECT product_id, product_name FROM Product UNION SELECT product_id, product_name FROM Product 2;

# 执行结果

<table><tr><td>product_id</td><td>product_name</td></tr><tr><td>0001</td><td>T 恤衫</td></tr><tr><td>0002</td><td>打孔器</td></tr><tr><td>0003</td><td>运动 T 恤</td></tr><tr><td>0004</td><td>菜刀</td></tr><tr><td>0005</td><td>高压锅</td></tr><tr><td>0006</td><td>叉子</td></tr><tr><td>0007</td><td>擦菜板</td></tr><tr><td>0008</td><td>圆珠笔</td></tr><tr><td>0009</td><td>手套</td></tr><tr><td>0010</td><td>水壶</td></tr></table>

上述结果包含了两张表中的全部商品。可能有些读者会发现，这就是我们在学校学过的集合中的并集运算，通过文氏图会看得更清晰（图 7- 1)。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/f06d6867ec151203a2eceb78ceeda7c43bf090061a69cdbbb9009336ad846e25.jpg)  
图 7-1 使用 UNION 对表进行加法（并集）运算的图示

※括号内的数字代表了商品的编号。

商品编号为“0001”~“0003”的 3 条记录在两个表中都存在，因此大家可能会认为结果中会出现重复的记录，但是 UNION 等集合运算符通常都会除去重复的记录。

# 法则 7-1

集合运算符会除去重复的记录。

# 集合运算的注意事项

其实结果中也可以包含重复的记录，在介绍该方法之前，还是让我们先来学习一下使用集合运算符时的注意事项吧。不仅限于 UNION，之后将要学习的所有运算符都要遵守这些注意事项。

# 注意事项  $(1)$  ——作为运算对象的记录的列数必须相同

例如，像下面这样，一部分记录包含 2 列，另一部分记录包含 3 列时会发生错误，无法进行加法运算。

- 列数不一致时会发生错误 SELECT product_id, product_nameFROM ProductUNIONSELECT product_id, product_name, sale_priceFROM Product 2;

# 注意事项  $(2)$  ——作为运算对象的记录中列的类型必须一致

从左侧开始，相同位置上的列必须是同一数据类型。例如下面的 SQL 语句，虽然列数相同，但是第 2 列的数据类型并不一致（一个是数值类型，一个是日期类型），因此会发生错误。

实际上，在有些 DBMS 中，即使数据类型不同，也可以通过隐式类型转换来完成操作。但由于并非所有的 DBMS 都支持这样的用法，因此还是希望大家能够使用恰当的数据类型来进行运算。

- 数据类型不一致时会发生错误 SELECT product_id, sale_priceFROM ProductUNIONSELECT product_id, regist_dateFROM Product 2;

一定要使用不同数据类型的列时，可以使用 6- 1 节中的类型转换函数 CAST。

# 注意事项  $(3)$  ——可以使用任何 SELECT 语句，但 ORDER BY 子句只能在最后使用一次

通过 UNION 进行并集运算时可以使用任何形式的 SELECT 语句，之前学过的 WHERE、GROUP BY、HAVING 等子句都可以使用。但是 ORDER BY 只能在最后使用一次（代码清单 7- 4）。

# 代码清单 7-4 ORDER BY 子句只在最后使用一次

SELECT product_id, product_name

FROM Product WHERE product_type = '厨房用具' UNION SELECT product_id, product_name FROM Product 2 WHERE product_type = '厨房用具' ORDER BY product_id;

# 执行结果

product_id|product_name 0004 菜刀 0005 高压锅 0006 叉子 0007 擦菜板 0010 水壶

# 包含重复行的集合运算 ALL 选项

# KEYWORD

ALL 选项

接下来给大家介绍在 UNION 的结果中保留重复行的语法。其实非常简单，只需要在 UNION 后面添加 ALL 关键字就可以了。这里的 ALL 选项，在 UNION 之外的集合运算符中同样可以使用（代码清单 7- 5）。

# 代码清单 7-5 保留重复行

SELECT product_id, product_name FROM Product UNION ALL SELECT product_id, product_name FROM Product 2;

# 执行结果

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/8d97bdf14cbf6fa457cdc7f87a338cf905fa0a8aceb14df1e9f52b49f7cf6ae0.jpg)

# 法则 7-2

在集合运算符中使用 ALL 选项，可以保留重复行。

# 选取表中公共部分 INTERSECT

# KEYWORD

INTERSECT（交集）

# 注①

因为 MySQL 尚不支持 INTERSECT，所以无法使用。

下面将要介绍的集合运算符在数的四则运算中并不存在，不过也不难理解，那就是选取两个记录集合中公共部分的 INTERSECT（交集）?。

让我们赶快来看一下吧。其语法和 UNION 完全一样（代码清单 7- 6）。

# 代码清单 7-6 使用 INTERSECT 选取出表中公共部分

<table><tr><td>Oracle</td><td>SQL Server</td><td>DB 2</td><td>PostgreSQL</td></tr><tr><td colspan="4">SELECT product_id, product_name
FROM Product
INTERSECT
SELECT product_id, product_name
FROM Product 2
ORDER BY product_id;</td></tr></table>

# 执行结果

<table><tr><td>product_id | product_name</td><td></td></tr><tr><td>0001</td><td>T 恤衫</td></tr><tr><td>0002</td><td>打孔器</td></tr><tr><td>0003</td><td>运动 T 恤</td></tr></table>

大家可以看到，结果中只包含两张表中记录的公共部分。该运算的文氏图如下所示（图 7- 2）。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/cbbd9f084b8cb220628334cd802b37a24f476cc1d1f6a7c00ed69dc0e29022f8.jpg)  
图 7-2 使用 INTERSECT 选取出表中公共部分的图示

与使用 AND 可以选取出一张表中满足多个条件的公共部分不同，INTERSECT 应用于两张表，选取出它们当中的公共记录。

其注意事项与 UNION 相同，我们在“集合运算的注意事项”和“保留重复行的集合运算”中已经介绍过了。希望保留重复行时同样需要使用 INTERSECT ALL。

# 记录的减法 -EXCEPT

# KEYWORD

EXCEPT（差集）

# 注①

只有 Oracle 不使用 EXCEPT，而是使用其特有的 MINUS 运算符。使用 Oracle 的用户，请用 MINUS 代替 EXCEPT。此外，MySQL 还不支持 EXCEPT，因此也无法使用。

最后要给大家介绍的集合运算符就是进行减法运算的 EXCEPT（差集）①，其语法也与 UNION 相同（代码清单 7- 7）。

# 代码清单 7-7 使用 EXCEPT 对记录进行减法运算

# SQL Server DB 2 PostgreSQL

SELECT product_id, product_name FROM Product EXCEPT SELECT product_id, product_name FROM Product 2 ORDER BY product_id;

# 特定的 SQL

在 Oracle 中执行代码清单 7- 7 或者代码清单 7- 8 中的 SQL 时，请将 EXCEPT 改为 MINUS。

- Oracle 中使用 MINUS 而不是 EXCEPT SELECT ... FROM ... MINUS SELECT ... FROM ...;

# 执行结果

product_id | product_name 0004 | 菜刀 0005 | 高压锅 0006 | 叉子 0007 | 橙菜板 0008 | 圆珠笔

大家可以看到，结果中只包含 Product 表中记录除去 Product 2 表中记录之后的剩余部分。该运算的文氏图如图 7- 3 所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/0fb7684de7d2ada0dfcf1e9de8c6775a0358d9b0b7b93b4573ddda800e9e0bfd.jpg)  
图 7-3 使用 EXCEPT 对记录进行减法运算的图示

EXCEPT 有一点与 UNION 和 INTERSECT 不同，需要注意一下。那就是在减法运算中减数和被减数的位置不同，所得到的结果也不相同。4 + 2 和 2 + 4 的结果相同，但是 4 - 2 和 2 - 4 的结果却不一样。因此，我们将之前 SQL 中的 Product 和 Product 2 互换，就能得到代码清单 7- 8 中的结果。

# 代码清单 7-8 被减数和减数位置不同，得到的结果也不同

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/8d5dc568960d08382baa881f3f243cced02b9ce6fd75421e8a891b6cd97ba02f.jpg)

# 执行结果

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/0ce2fdcd85a54ea3a9be6afb1cd8ab5ab5a5c089d8517f31046abdf3f65a5c38.jpg)

上述运算的文氏图如图 7- 4 所示。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/a33481c3d76535a5bf00bb1a295328212cab3b3a18d6fc86e8fc3e1f7deb9806.jpg)  
图 7-4 使用 EXCEPT 对记录进行减法运算的图示（从 Product 2 中除去 Product 中的记录）

到此，对 SQL 提供的集合运算符的学习已经结束了。可能有些读者会想“唉？怎么没有乘法和除法呢？”关于乘法的相关内容，我们将在下一节详细介绍。此外，SQL 中虽然也存在除法，但由于除法是比较难理解的运算，属于中级内容，因此我们会在本章末尾的专栏中进行一些简单的介绍，感兴趣的读者请参考专栏“关系除法”（7- 2 节）。

# 7-2

# 第 7 章集合运算

# 联结（以列为单位对表进行联结）

# 学习重点

学习重点- 联结（JOIN）就是将其他表中的列添加过来，进行“添加列”的集合运算。UNION 是以行（纵向）为单位进行操作，而联结则是以列（横向）为单位进行的。- 联结大体上分为内联结和外联结两种。首先请大家牢牢掌握这两种联结的使用方法。- 请大家一定要使用标准 SQL 的语法格式来写联结运算，对于那些过时的或者特定 SQL 中的写法，了解一下即可，不建议使用。

# 什么是联结

前一节我们学习了 UNION 和 INTERSECT 等集合运算，这些集合运算的特征就是以行方向为单位进行操作。通俗地说，就是进行这些集合运算时，会导致记录行数的增减。使用 UNION 会增加记录行数，而使用 INTERSECT 或者 EXCEPT 会减少记录行数。

# 注①

根据表中数据的不同，也存在行数不发生变化的情况。

# KEYWORD

联结（JOIN）

但是这些运算不会导致列数的改变。作为集合运算对象的表的前提就是列数要一致。因此，运算结果不会导致列的增减。

本节将要学习的联结（JOIN）运算，简单来说，就是将其他表中的列添加过来，进行“添加列”的运算（图 7- 5）。该操作通常用于无法从一张表中获取期望数据（列）的情况。截至目前，本书中出现的示例基本上都是从一张表中选取数据，但实际上，期望得到的数据往往会分散在不同的表之中。使用联结就可以从多张表（3 张以上的表也没关系）中选取数据了。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/dcff4c8b6ead28669374a5c1ac1da2b6f82799fd2b44851af947a2c176dbcd11.jpg)  
图 7-5 联结的图示

SQL 的联结根据其用途可以分为很多种类，这里希望大家掌握的有两种，内联结和外联结。接下来，我们就以这两种联结为中心进行学习。

# 内联结——INNER JOIN

# KEYWORD

$\bullet$  内联结（INNER JOIN）

首先我们来学习内联结（INNER JOIN），它是应用最广泛的联结运算。大家现在可以暂时忽略“内”这个字，之后会给大家详细说明。

本例中我们会继续使用 Product 表和第 6 章创建的 ShopProduct 表。下面我们再来回顾一下这两张表的内容。

表 7-1 Product（商品）表  

<table><tr><td>product_id
(商品编号)</td><td>product_name
(商品名称)</td><td>product_type
(商品种类)</td><td>sale_price
(销售单价)</td><td>purchase_price
(进货单价)</td><td>regist_date
(登记日期)</td></tr><tr><td>0001</td><td>T 恤衫</td><td>衣服</td><td>1000</td><td>500</td><td>2009-09-20</td></tr><tr><td>0002</td><td>打孔器</td><td>办公用品</td><td>500</td><td>320</td><td>2009-09-11</td></tr><tr><td>0003</td><td>运动 T 恤</td><td>衣服</td><td>4000</td><td>2800</td><td></td></tr><tr><td>0004</td><td>菜刀</td><td>厨房用具</td><td>3000</td><td>2800</td><td>2009-09-20</td></tr><tr><td>0005</td><td>高压锅</td><td>厨房用具</td><td>6800</td><td>5000</td><td>2009-01-15</td></tr><tr><td>0006</td><td>叉子</td><td>厨房用具</td><td>500</td><td></td><td>2009-09-20</td></tr><tr><td>0007</td><td>擦菜板</td><td>厨房用具</td><td>880</td><td>790</td><td>2008-04-28</td></tr><tr><td>0008</td><td>圆珠笔</td><td>办公用品</td><td>100</td><td></td><td>2009-11-11</td></tr></table>

表 7-2 ShopProduct（商店商品）表  

<table><tr><td>shop_id
(商店编号)</td><td>shop_name
(商店名称)</td><td>product_id
(商品编号)</td><td>quantity
(数量)</td></tr><tr><td>000 A</td><td>东京</td><td>0001</td><td>30</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>50</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>15</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>30</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>120</td></tr><tr><td>000 B</td><td>名古屋</td><td>0004</td><td>20</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>10</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>40</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>20</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>50</td></tr></table>

（续）  

<table><tr><td>shop_id
(商店编号)</td><td>shop_name
(商店名称)</td><td>product_id
(商品编号)</td><td>quantity
(数量)</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>90</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>70</td></tr><tr><td>000 D</td><td>福冈</td><td>0001</td><td>100</td></tr></table>

对这两张表包含的列进行整理后的结果如表 7- 3 所示。

表 7-3 两张表及其包含的列  

<table><tr><td></td><td>Product</td><td>ShopProduct</td></tr><tr><td>商品编号</td><td>○</td><td>○</td></tr><tr><td>商品名称</td><td>○</td><td></td></tr><tr><td>商品种类</td><td>○</td><td></td></tr><tr><td>销售单价</td><td>○</td><td></td></tr><tr><td>进货单价</td><td>○</td><td></td></tr><tr><td>登记日期</td><td>○</td><td></td></tr><tr><td>商店编号</td><td></td><td>○</td></tr><tr><td>商店名称</td><td></td><td>○</td></tr><tr><td>数量</td><td></td><td>○</td></tr></table>

如上表所示，两张表中的列可以分为如下两类。

$④$  两张表中都包含的列  $\rightarrow$  商品编号 $③$  只存在于一张表内的列  $\rightarrow$  商品编号之外的列

所谓联结运算，一言以蔽之，就是“以  $④$  中的列作为桥梁，将  $③$  中满足同样条件的列汇集到同一结果之中”，具体过程如下所述。

从 ShopProduct 表中的数据我们能够知道，东京店（000 A）销售商品编号为 0001、0002 和 0003 的商品，但这些商品的商品名称（product_name）和销售单价（sale_price）在 ShopProduct 表中并不存在，这些信息都保存在 Product 表中。大阪店和名古屋店的情况也是如此。

下面我们就试着从 Product 表中取出商品名称（product_name）和销售单价（sale_price），并与 ShopProduct 表中的内容进行结合，

所得到的结果如下所示。

执行结果  

<table><tr><td>shop_id</td><td>shop_name</td><td>product_id</td><td>product_name</td><td>sale_price</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>打孔器</td><td>500</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>运动 T 恤</td><td>4000</td></tr><tr><td>000 A</td><td>东京</td><td>0001</td><td>T 恤衫</td><td>1000</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>擦菜板</td><td>880</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>打孔器</td><td>500</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>运动 T 恤</td><td>4000</td></tr><tr><td>000 B</td><td>名古屋</td><td>0004</td><td>菜刀</td><td>3000</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>叉子</td><td>500</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>擦菜板</td><td>880</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>叉子</td><td>500</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>运动 T 恤</td><td>4000</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>菜刀</td><td>3000</td></tr><tr><td>000 D</td><td>福冈</td><td>0001</td><td>T 恤衫</td><td>1000</td></tr></table>

能够得到上述结果的 SELECT 语句如代码清单 7- 9 所示。

# 代码清单 7-9 将两张表进行内联结

SQL Server DB 2 PostgreSQL MySQL SELECT SP. shop_id, SP. shop_name, SP. product_id, P.product_name, P.sale_price FROM ShopProduct AS SP INNER JOIN Product AS P ON SP. product_id = P.product_id;

表示下一行接续本行，只是由于版面所限而换行。

# 特定的 SQL

在 Oracle 的 FROM 子句中不能使用 AS（会发生错误）。因此，在 Oracle 中执行代码清单 7- 9 时，请将①的部分变为“FROM ShopProduct SP INNER JOIN Product P”。

关于内联结，请大家注意以下三点。

# 内联结要点  $①$  FROM 子句

第一点要注意的是，之前的 FROM 子句中只有一张表，而这次我们同时使用了 ShopProduct 和 Product 两张表。

FROM ShopProduct AS SP INNER JOIN Product AS P

使用关键字 INNER JOIN 就可以将两张表联结在一起了。SP 和 P 分别是这两张表的别名，但别名并不是必需的。在 SELECT 子句中直

接使用 ShopProduct 和 product_id 这样的表的原名也没有关系，但由于表名太长会影响 SQL 语句的可读性，因此还是希望大家能够习惯使用别名。

# 注①

在 FROM 子句中使用表的别名时，像 Product AS P 这样使用 AS 是标准 SQL 正式的语法。但是在 Oracle 中使用 AS 会发生错误。因此，在 Oracle 中使用时，需要注意不要在 FROM 子句中使用 AS。

# 法则 7-3

进行联结时需要在 FROM 子句中使用多张表。

# KEYWORD

ON 子句

# 内联结要点  $(2)$  ——ON 子句

第二点要注意的是 ON 后面的联结条件。

ON SP. product_id = P.product_id

# KEYWORD

联结键

我们可以在 ON 之后指定两张表联结所使用的列（联结键），本例中使用的是商品编号（product_id）。也就是说，ON 是专门用来指定联结条件的，它能起到与 WHERE 相同的作用。需要指定多个键时，同样可以使用 AND、OR。在进行内联结时 ON 子句是必不可少的（如果没有 ON 会发生错误），并且 ON 必须书写在 FROM 和 WHERE 之间。

# 法则 7-4

进行内联结时必须使用 ON 子句，并且要书写在 FROM 和 WHERE 之间。

举个比较直观的例子，ON 就像是连接河流两岸城镇的桥梁一样（图 7- 6）。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/27c8e8fac4265cb7099e48303c903e89b0081673208f04fe7903dbf99bfd9811.jpg)  
图 7-6 使用 ON 进行两表加法运算（和集）的图示

联结条件也可以使用 “=” 来记述。在语法上，还可以使用  $< =$  和 BETWEEN 等谓词。但因为实际应用中九成以上都可以用 “=” 进行联结，所以开始时大家只要记住使用 “=” 就可以了。使用 “=” 将联结键关联起来，就能够将两张表中满足相同条件的记录进行“联结”了。

# 内联结要点  $(3)$  —SELECT 子句

第三点要注意的是，在 SELECT 子句中指定的列。

SELECT SP. shop_id, SP. shop_name, SP. product_id, P.product_name, P.sale_price

表示下一行接续本行，只是由于版面所限而换行。

在 SELECT 子句中，像 SP. shop_id 和P.sale_price 这样使用“<表的别名  $>.<$  列名  $>^{n}$  的形式来指定列。和使用一张表时不同，由于多表联结时，某个列到底属于哪张表比较容易混乱，因此采用了这样的防范措施。从语法上来说，只有那些同时存在于两张表中的列（这里是 product_id）必须使用这样的书写方式，其他的列像 shop_id 这样直接书写列名也不会发生错误。但是就像前面说的那样，为了避免混乱，还是希望大家能够在使用联结时按照“<表的别名  $>.<$  列名  $>^{n}$  的格式来书写 SELECT 子句中全部的列。

# 法则 7-5

使用联结时 SELECT 子句中的列需要按照“<表的别名  $>.<$  列名  $>^{n}$  的格式进行书写。

# 内联结和 WHERE 子句结合使用

如果并不想了解所有商店的情况，例如只想知道东京店（000 A）的信息时，可以像之前学习的那样在 WHERE 子句中添加条件，这样我们就可以从代码清单 7- 9 中得到的全部商店的信息中选取出东京店的记录了。

# 代码清单 7-10 内联结和 WHERE 子句结合使用

SQL Server DB 2 PostgreSQL MySQL SELECT SP. shop_id, SP. shop_name, SP. product_id, P.product_name, P.sale_price FROM ShopProduct AS SP INNER JOIN Product AS P ON SP. product_id = P.product_id WHERE SP. shop_id = '000 A';

表示下一行接续本行，只是由于版面所限而换行。

# 特定的 SQL

在 Oracle 中执行代码清单 7- 10 时，请将  $①$  的部分变为“FROM ShopProduct SP INNER JOIN Product P”（删掉 FROM 子句中的 AS）。

执行结果  

<table><tr><td>shop_id</td><td>shop_name</td><td>product_id</td><td>product_name</td><td>sale_price</td></tr><tr><td>000 A</td><td>东京</td><td>0001</td><td>T 恤衫</td><td>1000</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>打孔器</td><td>500</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>运动 T 恤</td><td>4000</td></tr></table>

像这样使用联结运算将满足相同规则的表联结起来时，WHERE、GROUP BY、HAVING、ORDER BY 等工具都可以正常使用。我们可以将联结之后的结果想象为新创建出来的一张表（表 7- 4)，对这张表使用 WHERE 子句等工具，这样理解起来就容易多了吧。

当然，这张“表”只在 SELECT 语句执行期间存在，SELECT 语句执行之后就会消失。如果希望继续使用这张“表”，还是将它创建成视图吧。

表 7-4 通过联结创建出的表（ProductJoinShopProduct）的图示  

<table><tr><td>shop_id
(编号)</td><td>shop_name
商品名称)</td><td>product_id
(商品编号)</td><td>product_name
(商品名称)</td><td>sale_price
(销售单价)</td></tr><tr><td>000 A</td><td>东京</td><td>0001</td><td>T 恤衫</td><td>1000</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>打孔器</td><td>500</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>运动 T 恤</td><td>40000</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>打孔器</td><td>500</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>运动 T 恤</td><td>40000</td></tr><tr><td>000 B</td><td>名古屋</td><td>0004</td><td>菜刀</td><td>3000</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>叉子</td><td>500</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>擦菜板</td><td>880</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>运动 T 恤</td><td>40000</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>菜刀</td><td>3000</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>叉子</td><td>500</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>擦菜板</td><td>880</td></tr><tr><td>000 D</td><td>福冈</td><td>0001</td><td>T 恤衫</td><td>1000</td></tr></table>

# 外联结——OUTER JOIN

# KEYWORD

外联结（OUTER JOIN）

内联结之外比较重要的就是外联结（OUTER JOIN）了。我们再来回顾一下前面的例子。在前例中，我们将 Product 表和 ShopProduct

表进行内联结，从两张表中取出各个商店销售的商品信息。其中，实现“从两张表中取出”的就是联结功能。

外联结也是通过 ON 子句的联结键将两张表进行联结，并从两张表中同时选取相应的列的。基本的使用方法并没有什么不同，只是结果却有所不同。事实胜于雄辩，还是让我们先把之前内联结的 SELECT 语句（代码清单 7- 9）转换为外联结试试看吧。转换的结果请参考代码清单 7- 11。

# 代码清单 7-11 将两张表进行外联结

SQL Server DB 2 PostgreSQL MySQL SELECT SP. shop_id, SP. shop_name, SP. product_id, P.product_name, P.sale_price FROM ShopProduct AS SP RIGHT OUTER JOIN Product AS P ON SP. product_id = P.product_id;

表示下一行接续本行，只是由于版面所限而换行。

# 特定的 SQL

在 Oracle 中执行代码清单 7- 11 时，请将  $①$  的部分变为“FROM ShopProductSP RIGHT OUTER JOIN Product P"（删除掉 FROM 子句中的 AS）。

执行结果  

<table><tr><td>shop_id</td><td>shop_name</td><td>product_id</td><td>product_name</td><td>sale_price</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>打孔器</td><td>500</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>运动 T 恤</td><td>4000</td></tr><tr><td>000 A</td><td>东京</td><td>0001</td><td>T 恤衫</td><td>1000</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>叉子</td><td>500</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>打孔器</td><td>500</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>运动 T 恤</td><td>4000</td></tr><tr><td>000 B</td><td>名古屋</td><td>0004</td><td>菜刀</td><td>3000</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>擦菜板</td><td>880</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>叉子</td><td>500</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>擦菜板</td><td>880</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>运动 T 恤</td><td>4000</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>菜刀</td><td>3000</td></tr><tr><td>000 D</td><td>福冈</td><td>0001</td><td>T 恤衫</td><td>1000</td></tr><tr><td></td><td></td><td>0005</td><td>高压锅</td><td>6800</td></tr><tr><td></td><td></td><td>0008</td><td>圆珠笔</td><td>100</td></tr></table>

# 外联结要点  $①$  ——选取出单张表中全部的信息

与内联结的结果相比，不同点显而易见，那就是结果的行数不一样。内联结的结果中有 13 条记录，而外联结的结果中有 15 条记录，增加的 2 条记录到底是什么呢？

这正是外联结的关键点。多出的 2 条记录是高压锅和圆珠笔，这 2 条记录在 ShopProduct 表中并不存在，也就是说，这 2 种商品在任何商店中都没有销售。由于内联结只能选取出同时存在于两张表中的数据，因此只在 Product 表中存在的 2 种商品并没有出现在结果之中。

相反，对于外联结来说，只要数据存在于某一张表当中，就能够读取出来。在实际的业务中，例如想要生成固定行数的单据时，就需要使用外联结。如果使用内联结的话，根据 SELECT 语句执行时商店库存状况的不同，结果的行数也会发生改变，生成的单据的版式也会受到影响，而使用外联结能够得到固定行数的结果。

虽说如此，那些表中不存在的信息我们还是无法得到，结果中高压锅和圆珠笔的商店编号和商店名称都是 NULL（具体信息大家都不知道，真是无可奈何）。外联结名称的由来也跟 NULL 有关，即“结果中包含原表中不存在（在原表之外）的信息”。相反，只包含表内信息的联结也就被称为内联结了。

# $\bullet$  外联结要点  $(2)$  ——每张表都是主表吗？

# KEYWORD

$\bullet$  LEFT 关键字  $\bullet$  RIGHT 关键字

外联结还有一点非常重要，那就是要把哪张表作为主表。最终的结果中会包含主表内所有的数据。指定主表的关键字是 LEFT 和 RIGHT。顾名思义，使用 LEFT 时 FROM 子句中写在左侧的表是主表，使用 RIGHT 时右侧的表是主表。代码清单 7- 11 中使用了 RIGHT，因此，右侧的表，也就是 Product 表是主表。

我们还可以像代码清单 7- 12 这样进行改写，意思完全相同。

# 代码清单 7-12 改写后外联结的结果完全相同

SQL Server DB 2 PostgreSQL MySQL SELECT SP. shop_id, SP. shop_name, SP. product_id, P.product_name, P.sale_price FROM Product AS P LEFT OUTER JOIN ShopProduct AS SP ON SP. product_id = P.product_id;

表示下一行接续本行，只是由于版面所限而换行。

# 特定的 SQL

在 Oracle 中执行代码清单 7- 12 时，请将  $(1)$  的部分变为“FROM ShopProduct SP LEFT OUTER JOIN Product P”（删除掉 FROM 子句中的 AS）。

大家可能会犹豫到底应该使用 LEFT 还是 RIGHT，其实它们的功能没有任何区别，使用哪一个都可以。通常使用 LEFT 的情况会多一些，但也并没有非使用这个不可的理由，使用 RIGHT 也没有问题。

# 法则 7-6

法则 7- 6 外联结中使用 LEFT、RIGHT 来指定主表。使用二者所得到的结果完全相同。

# 3 张以上的表的联结

通常联结只涉及 2 张表，但有时也会出现必须同时联结 3 张以上的表的情况。原则上联结表的数量并没有限制，下面就让我们来看一下 3 张表的联结吧。

首先我们创建一张用来管理库存商品的表（表 7- 5）。假设商品都保存在 P 001 和 P 002 这 2 个仓库之中。

表 7-5 InventoryProduct（库存商品）表  

<table><tr><td>inventory_id
(仓库编号)</td><td>product_id
(商品编号)</td><td>inventory_quantity
(库存数量)</td></tr><tr><td>P 001</td><td>0001</td><td>0</td></tr><tr><td>P 001</td><td>0002</td><td>120</td></tr><tr><td>P 001</td><td>0003</td><td>200</td></tr><tr><td>P 001</td><td>0004</td><td>3</td></tr><tr><td>P 001</td><td>0005</td><td>0</td></tr><tr><td>P 001</td><td>0006</td><td>99</td></tr><tr><td>P 001</td><td>0007</td><td>999</td></tr><tr><td>P 001</td><td>0008</td><td>200</td></tr><tr><td>P 002</td><td>0001</td><td>10</td></tr><tr><td>P 002</td><td>0002</td><td>25</td></tr><tr><td>P 002</td><td>0003</td><td>34</td></tr><tr><td>P 002</td><td>0004</td><td>19</td></tr><tr><td>P 002</td><td>0005</td><td>99</td></tr><tr><td>P 002</td><td>0006</td><td>0</td></tr><tr><td>P 002</td><td>0007</td><td>0</td></tr><tr><td>P 002</td><td>0008</td><td>18</td></tr></table>

创建该表及插入数据的 SQL 语句请参考代码清单 7- 13。

# 代码清单 7-13 创建 InventoryProduct 表并向其中插入数据

- - DDL：创建表 CREATE TABLE InventoryProduct ( inventory_id CHAR (4) NOT NULL, product_id CHAR (4) NOT NULL, inventory_quantity INTEGER NOT NULL, PRIMARY KEY (inventory_id, product_id));

SQL Server PostgreSQL- - DML：插入数据 BEGIN TRANSACTION;

INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 001', '0001', 0); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 001', '0002', 120); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 001', '0003', 200); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 001', '0004', 3); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 001', '0005', 0); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 001', '0006', 99); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 001', '0007', 999); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 001', '0008', 200); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 002', '0001', 10); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 002', '0002', 25); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 002', '0003', 34); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 002', '0004', 19); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 002', '0005', 99); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 002', '0006', 0); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 002', '0007', 0); INSERT INTO InventoryProduct (inventory_id, product_id, inventory_quantity) VALUES ('P 002', '0008', 18);

表示下一行接续本行，只是由于版面所限而换行。

# 特定的 SQL

特定的 SQL 不同的 DBMS 的事务处理的语法也不尽相同。代码清单 7- 13 中的 DML 语句在 MySQL 中执行时，需要将  $(1)$  部分更改为“START TRANSACTION”，在 Oracle 和 DB 2 中执行时，无需用到  $(1)$  的部分（请删除）。详细内容请大家参考 4- 4 节中的“创建事务”。

下面我们从上表中取出保存在 P 001 仓库中的商品数量，并将该列添加到代码清单 7- 11 所得到的结果中。联结方式为内联结（外联结的使用方法完全相同），联结键为商品编号（product_id）（代码清单 7- 14）。

# 代码清单 7-14 对 3 张表进行内联结

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/455904a0cd0e239c39a258a8ed6ebfec5a5054ab10847eb8e1583b83e0c73d4e.jpg)

表示下一行接续本行，只是由于版面所限而换行。

# 特定的 SQL

特定的 SQL 在 Oracle 中执行代码清单 7- 14 时，请将  $(1)$  的部分变为“FROM ShopProduct SP INNER JOIN Product P”，将  $(2)$  的部分变为“INNER JOIN InventoryProduct IP”（删除掉 FROM 子句中的 AS）。

执行结果  

<table><tr><td>shop_id</td><td>shop_name</td><td>product_id</td><td>product_name</td><td>sale_price</td><td>inventory_quantity</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>打孔器</td><td>500</td><td>120</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>运动 T 恤</td><td>4000</td><td>200</td></tr><tr><td>000 A</td><td>东京</td><td>0001</td><td>T 恤衫</td><td>1000</td><td>0</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>擦菜板</td><td>880</td><td>999</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>打孔器</td><td>500</td><td>120</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>运动 T 恤</td><td>4000</td><td>200</td></tr><tr><td>000 B</td><td>名古屋</td><td>0004</td><td>菜刀</td><td>3000</td><td>3</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>叉子</td><td>500</td><td>99</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>擦菜板</td><td>880</td><td>999</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>叉子</td><td>500</td><td>99</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>运动 T 恤</td><td>4000</td><td>200</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>菜刀</td><td>3000</td><td>3</td></tr><tr><td>000 D</td><td>福冈</td><td>0001</td><td>T 恤衫</td><td>1000</td><td>0</td></tr></table>

在代码清单 7- 11 内联结的 FROM 子句中，再次使用 INNER JOIN

将 InventoryProduct 表也添加了进来。

FROM ShopProduct AS SP INNER JOIN Product AS P ON SP. product_id = P.product_id INNER JOIN InventoryProduct AS IP ON SP. product_id = IP. product_id

通过 ON 子句指定联结条件的方式也没有发生改变，使用等号将作为联结条件的 Product 表和 ShopProduct 表中的商品编号（product_id）联结起来。由于 Product 表和 ShopProduct 表已经进行了联结，因此这里无需再对 Product 表和 InventoryProduct 表进行联结了（虽然也可以进行联结，但结果并不会发生改变）。

即使想要把联结的表增加到 4 张、5 张……使用 INNER JOIN 进行添加的方式也是完全相同的。

# 交叉联结——CROSS JOIN

# KEYWORD

交叉联结（CROSS JOIN）

接下来和大家一起学习第 3 种联结方式——交叉联结（CROSS JOIN）。其实这种联结在实际业务中并不会使用（笔者使用这种联结的次数也屈指可数），那为什么还要在这里进行介绍呢？这是因为交叉联结是所有联结运算的基础。

交叉联结本身非常简单，但是其结果有点麻烦。下面我们就试着将 Product 表和 ShopProduct 表进行交叉联结（代码清单 7- 15）。

# 代码清单 7-15 将两张表进行交叉联结

SQL Server DB 2 PostgreSQL MySQL SELECT SP. shop_id, SP. shop_name, SP. product_id, P.product_name FROM ShopProduct AS SP CROSS JOIN Product AS P;

# 特定的 SQL

在 Oracle 中执行代码清单 7- 15 时，请将①的部分变为“FROM ShopProduct SP CROSS JOIN Product P;”（删除掉 FROM 子句中的 AS）。

执行结果  

<table><tr><td>shop_id</td><td>shop_name</td><td>product_id</td><td>product_name</td></tr><tr><td>000 A</td><td>东京</td><td>0001</td><td>T 恤衫</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>T 恤衫</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>T 恤衫</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>T 恤衫</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>T 恤衫</td></tr><tr><td>000 B</td><td>名古屋</td><td>0004</td><td>T 恤衫</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>T 恤衫</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>T 恤衫</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>T 恤衫</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>T 恤衫</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>T 恤衫</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>T 恤衫</td></tr><tr><td>000 D</td><td>福冈</td><td>0001</td><td>T 恤衫</td></tr><tr><td>000 A</td><td>东京</td><td>0001</td><td>打孔器</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>打孔器</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>打孔器</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>打孔器</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>打孔器</td></tr><tr><td>000 B</td><td>名古屋</td><td>0004</td><td>打孔器</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>打孔器</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>打孔器</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>打孔器</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>打孔器</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>打孔器</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>打孔器</td></tr><tr><td>000 C</td><td>大阪</td><td>0001</td><td>运动 T 恤</td></tr><tr><td>000 A</td><td>东京</td><td>0001</td><td>运动 T 恤</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>运动 T 恤</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>运动 T 恤</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>运动 T 恤</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>运动 T 恤</td></tr><tr><td>000 B</td><td>名古屋</td><td>0004</td><td>运动 T 恤</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>运动 T 恤</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>运动 T 恤</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>运动 T 恤</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>运动 T 恤</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>运动 T 恤</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>运动 T 恤</td></tr><tr><td>000 D</td><td>福冈</td><td>0001</td><td>运动 T 恤</td></tr><tr><td>000 A</td><td>东京</td><td>0001</td><td>菜刀</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>菜刀</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>菜刀</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>菜刀</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>菜刀</td></tr><tr><td>000 B</td><td>名古屋</td><td>0004</td><td>菜刀</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>菜刀</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>菜刀</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>菜刀</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>菜刀</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>菜刀</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>菜刀</td></tr><tr><td>000 D</td><td>福冈</td><td>0001</td><td>菜刀</td></tr></table>

<table><tr><td>000 A</td><td>东京</td><td>0001</td><td>高压锅</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>高压锅</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>高压锅</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>高压锅</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>高压锅</td></tr><tr><td>000 B</td><td>名古屋</td><td>0004</td><td>高压锅</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>高压锅</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>高压锅</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>高压锅</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>高压锅</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>高压锅</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>高压锅</td></tr><tr><td>000 D</td><td>福冈</td><td>0001</td><td>高压锅</td></tr><tr><td>000 A</td><td>东京</td><td>0001</td><td>叉子</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>叉子</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>叉子</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>叉子</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>叉子</td></tr><tr><td>000 B</td><td>名古屋</td><td>0004</td><td>叉子</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>叉子</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>叉子</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>叉子</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>叉子</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>叉子</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>叉子</td></tr><tr><td>000 D</td><td>福冈</td><td>0001</td><td>叉子</td></tr><tr><td>000 A</td><td>东京</td><td>0001</td><td>擦菜板</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>擦菜板</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>擦菜板</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>擦菜板</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>擦菜板</td></tr><tr><td>000 B</td><td>名古屋</td><td>0004</td><td>擦菜板</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>擦菜板</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>擦菜板</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>擦菜板</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>擦菜板</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>擦菜板</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>擦菜板</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>擦菜板</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>擦菜板</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>擦菜板</td></tr><tr><td>-000 D</td><td>福冈</td><td>0001</td><td>圆珠笔</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>圆珠笔</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>圆珠笔</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>圆珠笔</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>圆珠笔</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>圆珠笔</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>圆珠笔</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>圆珠笔</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>圆珠笔</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>圆珠笔</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>圆珠笔</td></tr><tr><td>000 D</td><td>福冈</td><td>0001</td><td>圆珠笔</td></tr></table>

# KEYWORD

CROSS JOIN（笛卡儿积）

可能大家会惊讶于结果的行数，但我们还是先来介绍一下语法结构吧。对满足相同规则的表进行交叉联结的集合运算符是 CROSS JOIN（笛卡儿积）。进行交叉联结时无法使用内联结和外联结中所使用的 ON 子句，这是因为交叉联结是对两张表中的全部记录进行交叉组合，因此结果中的记录数通常是两张表中行数的乘积。本例中，因为 ShopProduct 表存在 13 条记录，Product 表存在 8 条记录，所以结果中就包含了 $13\times 8 = 104$  条记录。

可能这时会有读者想起前面我们提到过集合运算中的乘法会在本节中进行详细学习，这就是上面介绍的交叉联结。

内联结是交叉联结的一部分，“内”也可以理解为“包含在交叉联结结果中的部分”。相反，外联结的“外”可以理解为“交叉联结结果之外的部分”。

交叉联结没有应用到实际业务之中的原因有两个。一是其结果没有实用价值，二是由于其结果行数太多，需要花费大量的运算时间和高性能设备的支持。

# 联结的特定语法和过时语法

之前我们学习的内联结和外联结的语法都符合标准 SQL 的规定，可以在所有 DBMS 中执行，因此大家可以放心使用。但是如果大家之后从事系统开发工作的话，一定会碰到需要阅读他人写的代码并进行维护的情况，而那些使用特定和过时语法的程序就会成为我们的麻烦。

SQL 是一门特定语法及过时语法非常多的语言，虽然之前本书中也多次提及，但联结是其中特定语法的部分，现在还有不少年长的程序员和系统工程师仍在使用这些特定的语法。

例如，将本节最初介绍的内联结的 SELECT 语句（代码清单 7- 9）替换为过时语法的结果如下所示（代码清单 7- 16）。

# 代码清单 7-16 使用过时语法的内联结（结果与代码清单 7-9 相同）

SELECT SP. shop_id, SP. shop_name, SP. product_id, P.product_name, P.sale_price FROM ShopProduct SP, Product P WHERE SP. product_id = P.product_id AND SP. shop_id = '000 A';

表示下一行接续本行，只是由于版面所限而换行。

这样的书写方式所得到的结果与标准语法完全相同，并且这样的语法可以在所有的 DBMS 中执行，并不能算是特定的语法，只是过时了而已。

但是，由于这样的语法不仅过时，而且还存在很多其他的问题，因此不推荐大家使用，理由主要有以下三点。

第一，使用这样的语法无法马上判断出到底是内联结还是外联结（又或者是其他种类的联结）。

第二，由于联结条件都写在 WHERE 子句之中，因此无法在短时间内分辨出哪部分是联结条件，哪部分是用来选取记录的限制条件。

第三，我们不知道这样的语法到底还能使用多久。每个 DBMS 的开发者都会考虑放弃过时的语法，转而支持新的语法。虽然并不是马上就不能使用了，但那一天总会到来的。

虽然这么说，但是现在使用这些过时语法编写的程序还有很多，到目前为止还都能正常执行。我想大家很可能会碰到这样的代码，因此还是希望大家能够了解这些知识。

# 法则 7-7

对于联结的过时语法和特定语法，虽然不建议使用，但还是希望大家能够读懂。

# 专栏

# 关系除法

本章中我们学习了以下 4 个集合运算符。

- UNION（并集）- EXCEPT（差集）- INTERSECT（交集）- CROSS JOIN（笛卡儿积）

# KEYWORD

关系除法

虽然交集是一种独立的集合运算，但实际上它也是“只包含公共部分的特殊 UNION”。剩下的 3 个在四则运算中也有对应的运算。但是，除法运算还没有介绍。

难道集合运算中没有除法吗？当然不是，除法运算是存在的。集合运算中的除法通常称为关系除法。关系是数学领域中对表或者视图的称谓，但是并没有定义像 UNION 或者 EXCEPT 这样专用的运算符。如果要定义，估计应该是 DIVIDE（除）吧。但截至目前并没有 DBMS 使用这样的运算符。

为什么只有除法运算不使用运算符（只有除法）对被除数进行运算呢？其中的理由有点复杂，还是让我们先来介绍一下“表的除法”具体是一种什么样的运算吧。

我们使用表 7- A 和表 7- B 两张表作为示例用表。

表 7-ASkills（技术）表：关系除法中的除数  

<table><tr><td>skill</td></tr><tr><td>Oracle</td></tr><tr><td>UNIX</td></tr><tr><td>Java</td></tr></table>

表 7-BEmpSkills（员工技术）表：关系除法中的被除数  

<table><tr><td>emp</td><td>skill</td></tr><tr><td>相田</td><td>Oracle</td></tr><tr><td>相田</td><td>UNIX</td></tr><tr><td>相田</td><td>Java</td></tr><tr><td>相田</td><td>C#</td></tr><tr><td>神崎</td><td>Oracle</td></tr><tr><td>神崎</td><td>UNIX</td></tr><tr><td>神崎</td><td>Java</td></tr><tr><td>平井</td><td>UNIX</td></tr><tr><td>平井</td><td>Oracle</td></tr><tr><td>平井</td><td>PHP</td></tr><tr><td>平井</td><td>Perl</td></tr><tr><td>平井</td><td>C++</td></tr><tr><td>若田部</td><td>Perl</td></tr><tr><td>渡来</td><td>Oracle</td></tr></table>

创建上述两张表并向其中插入数据的 SQL 语句请参考代码清单 7- A。

# 代码清单 7-A 创建 Skills/EmpSkills 表并插入数据

```sql- - DDL: 创建表 CREATE TABLE Skills (skill VARCHAR (32), PRIMARY KEY (Skill)); CREATE TABLE EmpSkills (emp VARCHAR (32), skill VARCHAR (32), PRIMARY KEY (emp, skill));```

# SQL Server PostgreSQL

- - DML: 插入数据 BEGIN TRANSACTION;

INSERT INTO Skills VALUES ('Oracle'); INSERT INTO Skills VALUES ('UNIX'); INSERT INTO Skills VALUES ('Java'); INSERT INTO EmpSkills VALUES ('相田', 'Oracle'); INSERT INTO EmpSkills VALUES ('相田', 'UNIX'); INSERT INTO EmpSkills VALUES ('相田', 'Java'); INSERT INTO EmpSkills VALUES ('相田', 'C#'); INSERT INTO EmpSkills VALUES ('神崎', 'Oracle'); INSERT INTO EmpSkills VALUES ('神崎', 'UNIX'); INSERT INTO EmpSkills VALUES ('神崎', 'Java'); INSERT INTO EmpSkills VALUES ('平井', 'UNIX'); INSERT INTO EmpSkills VALUES ('平井', 'Oracle'); INSERT INTO EmpSkills VALUES ('平井', 'PHP'); INSERT INTO EmpSkills VALUES ('平井', 'Perl'); INSERT INTO EmpSkills VALUES ('平井', 'C++'); INSERT INTO EmpSkills VALUES ('若田部', 'Perl'); INSERT INTO EmpSkills VALUES ('渡来', 'Oracle');

COMMIT;

# 特定的 SQL

不同的 DBMS 的事务处理的语法也不尽相同。代码清单 7- A 中的 DML 语句在 MySQL 中执行时，需要将①部分更改为“START TRANSACTION;”，在 Oracle 和 DB 2 中执行时，无需用到①的部分（请删除）。

详细内容请大家参考 4- 4 节中的“创建事务”。

EmpSkills 表中保存了某个系统公司员工所掌握的技术信息。例如，从该表中我们可以了解到相田掌握了 Oracle、UNIX、Java、C #这4种技术 。

下面我们来思考一下如何从该表中选取出掌握了 Skills 表中所有 3 个领域的技术的员工吧（代码清单 7- B）。

# 代码清单 7-B 选取出掌握所有 3 个领域的技术的员工

SELECT DISTINCT emp FROM EmpSkills ES 1 WHERE NOT EXISTS (SELECT skill FROM Skills EXCEPT SELECT skill FROM EmpSkills ES 2 WHERE EP 1. emp = ES 2. emp);

这样我们就得到了包含相田和神崎 2 人的结果。虽然平井也掌握了 Orcale 和 UNIX，但很可惜他不会使用 Java，因此没有选取出来。

# 执行结果（关系除法中的商）

emp 神崎相田

这样的结果满足了除法运算的基本规则。肯定有读者会产生这样的疑问：“到底上述运算中什么地方是除法运算呢？”实际上这和数值的除法既相似又有所不同，大家从与除法相对的乘法运算的角度去思考就能得到答案了。

除法和乘法是相辅相成的关系，除法运算的结果（商）乘以除数就能得到除法运算前的被除数了。例如对于  $20\div 4 = 5$  来说，就是 5（商）  $\times 4 ($  除数）  $= 20 ($  被除数）（图 7- A）。

关系除法中这样的规则也是成立的。通过商和除数相乘，也就是交叉联结，就能够得到作为被除数的集合了。

# 注①

虽然不能恢复成完整的被除数，但是这里我们也不再追究了。

# 图 7-A 除法运算和乘法运算相辅相成的关系图

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/73a87399e169dc910ab94bc6c0cdce6a155ad9d8ed0b156d87bbece38d23ebfb.jpg)

# 被除数

如上所述，除法运算是集合运算中最复杂的运算，但是其在实际业务中的应用十分广泛，因此希望大家能在达到中级以上水平时掌握其使用方法。此外，想要详细了解 SQL 中除法运算实现方法的读者，可以参考拙著《達人心理学 SQL 徹底指南書》（翔泳社）中的 1- 4 节和 1- 7 节。

# 练习题

7.1 请说出下述 SELECT 语句的结果

- - 使用本章中的 Product 表 SELECT *FROM ProductUNIONSELECT *FROM ProductINTERSECTSELECT *FROM ProductORDER BY product_id;

7.2 7- 2 节的代码清单 7- 11 中列举的外联结的结果中，高压锅和圆珠笔 2 条记录的商店编号（shop_id）和商店名称（shop_name）都是 NULL。请使用字符串“不确定”替换其中的 NULL。期望结果如下所示。

执行结果  

<table><tr><td colspan="5">shop_id | shop_name | product_id | product_name | sale_price</td></tr><tr><td>000 A</td><td>东京</td><td>0002</td><td>打孔器</td><td>500</td></tr><tr><td>000 A</td><td>东京</td><td>0003</td><td>运动 T 恤</td><td>4000</td></tr><tr><td>000 A</td><td>东京</td><td>0001</td><td>T 恤衫</td><td>1000</td></tr><tr><td>000 B</td><td>名古屋</td><td>0006</td><td>叉子</td><td>500</td></tr><tr><td>000 B</td><td>名古屋</td><td>0002</td><td>打孔器</td><td>500</td></tr><tr><td>000 B</td><td>名古屋</td><td>0003</td><td>运动 T 恤</td><td>4000</td></tr><tr><td>000 B</td><td>名古屋</td><td>0004</td><td>菜刀</td><td>3000</td></tr><tr><td>000 B</td><td>名古屋</td><td>0007</td><td>擦菜板</td><td>880</td></tr><tr><td>000 C</td><td>大阪</td><td>0006</td><td>叉子</td><td>500</td></tr><tr><td>000 C</td><td>大阪</td><td>0007</td><td>擦菜板</td><td>880</td></tr><tr><td>000 C</td><td>大阪</td><td>0003</td><td>运动 T 恤</td><td>4000</td></tr><tr><td>000 C</td><td>大阪</td><td>0004</td><td>菜刀</td><td>3000</td></tr><tr><td>000 D</td><td>福冈</td><td>0001</td><td>T 恤衫</td><td>1000</td></tr><tr><td>不确定</td><td>不确定</td><td>0005</td><td>高压锅</td><td>6800</td></tr><tr><td>不确定</td><td>不确定</td><td>0008</td><td>圆珠笔</td><td>100</td></tr></table>

将商店编号和商店名称输出为“不确定”
