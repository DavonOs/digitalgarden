---
{"dg-publish":true,"dg-permalink":"books/27055712/04","permalink":"/books/27055712/04/","metatags":{"description":"","og:site_name":"DavonOs","og:title":"第4章 数据更新","og:type":"article","og:url":"https://zuji.eu.org/books/27055712/04","og:image":"https://file.ituring.com.cn/LargeCover/1712477631b07b9f5895","og:image:width":"200","og:image:alt":"articlecover","og:locale":"zh_cn"},"tags":["program/sql"],"dgShowInlineTitle":true,"created":"2025-09-10 14:46","updated":"2025-09-11 08:25"}
---

# 数据的插入（INSERT 语句的使用方法）

# 学习重点

> [!todo]+ 学习重点
> - 使用 INSERT 语句可以向表中插入数据（行）。原则上，INSERT 语句每次执行一行数据的插入。
> - 将列名和值用逗号隔开，分别括在（）内，这种形式称为清单。
> - 对表中所有列进行 INSERT 操作时可以省略表名后的列清单。
> - 插入 NULL 时需要在 VALUES 子句的值清单中写入 NULL。
> - 可以为表中的列设定默认值（初始值），默认值可以通过在 CREATE TABLE 语句中为列设置 DEFAULT 约束来设定。
> - 插入默认值可以通过两种方式实现，即在 INSERT 语句的 VALUES 子句中指定 DEFAULT 关键字（显式方法），或省略列清单（隐式方法）。
> - 使用 INSERT... SELECT 可以从其他表中复制数据。

# 什么是 INSERT

1- 4 节给大家介绍了用来创建表的 CREATE TABLE 语句。通过 CREATE TABLE 语句创建出来的表，可以被认为是一个空空如也的箱子。只有把数据装入到这个箱子后，它才能称为数据库。用来装入数据的 SQL 就是 INSERT（插入）（图 4- 1）。

本节将会和大家一起学习 INSERT 语句。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/80a78bacac310ad3e3e7f022e72ec03765b5eb74d201ebad29ac88877619ea05.jpg)
图 4-1 INSERT（插入）的流程

要学习 INSERT 语句，我们得首先创建一个名为 ProductIns 的表。请大家执行代码清单 4- 1 中的 CREATE TABLE 语句。该表除了为 sale_price 列（销售单价）设置了 DEFAULT 0 的约束之外，其余内容与之前使用的 Product（商品）表完全相同。DEFAULT 0 的含义将会在随后进行介绍，大家暂时可以忽略。

代码清单 4-1 创建 ProductIns 表的 CREATE TABLE 语句

<table><tr><td>CREATE TABLE ProductIns
(product_id</td><td>CHAR (4)</td><td>NOT NULL,</td></tr><tr><td>product_name</td><td>VARCHAR (100)</td><td>NOT NULL,</td></tr><tr><td>product_type</td><td>VARCHAR (32)</td><td>NOT NULL,</td></tr><tr><td>sale_price</td><td>INTEGER</td><td>DEFAULT 0,</td></tr><tr><td>purchase_price</td><td>INTEGER</td><td>,</td></tr><tr><td>regist_date</td><td>DATE</td><td>,</td></tr><tr><td>PRIMARY KEY (product_id));</td><td></td><td></td></tr></table>

如前所述，这里仅仅是创建出了一个表，并没有插入数据。接下来，我们就向 ProductIns 表中插入数据。

# INSERT 语句的基本语法

1- 5 节中讲到向 CREATE TABLE 语句创建出的 Product 表中插入数据的 SQL 语句时，曾介绍过 INSERT 语句的使用示例，但当时的目的只是为学习 SELECT 语句准备所需的数据，并没有详细介绍其语法。下面就让我们来介绍一下 INSERT 语句的语法结构。

INSERT 语句的基本语法如下所示

# 语法 4-1 INSERT 语句

INSERT INTO <表名>（列 1，列 2，列 3，……） VALUES（值 1，值 2，值 3，……）；

例如，我们要向 ProductIns 表中插入一行数据，各列的值如下所示。

<table><tr><td>product_id
(商品编号)</td><td>product_name
(商品名称)</td><td>product_type
(商品种类)</td><td>sale_price
(销售单价)</td><td>purchase_price
(进货单价)</td><td>regist_date
(登记日期)</td></tr><tr><td>0001</td><td>T 恤衫</td><td>衣服</td><td>1000</td><td>500</td><td>2009-09-20</td></tr></table>

此时使用的 INSERT 语句可参见代码清单 4- 2。

代码清单 4-2 向表中插入一行数据

INSERT INTO ProductIns (product_id, product_name, product_type, sale_price, purchase_price, regist_date) VALUES ('0001', 'T 恤衫', '衣服', 1000, 500, '2009- 09- 20');

表示下一行接续本行，只是由于版面所限而换行。

由于 product_id 列（商品编号）和 product_name 列（商品名称）是字符型，所以插入的数据需要像 '0001' 这样用单引号括起来。日期型的 regist_date（登记日期）列也是如此。

将列名和值用逗号隔开，分别括在（）内，这种形式称为清单。代码清单 4- 2 中的 INSERT 语句包含如下两个清单。


# KEYWORD

●清单

●列清单

●值清单

列清单  $\longrightarrow$  (product_id, product_name, product_type, sale_price, purchase_price, regist_date) 值清单  $\longrightarrow$  ('0001', 'T 恤衫', '衣服', 1000, 500, '2009- 09- 20')

# 注②

当然，表名后面的列清单和 VALUES 子句中的值清单的列数必须保持一致。如下所示，列数不一致时会出错，无法插入数据。

但是使用默认值时列数无需完全一致。相关内容将会在随后的“插入默认值”中进行介绍。

- - VALUES 子句中的值清单缺少一列

INSERT INTO ProductIns (product_id, product_name, product_type, sale_price, purchase_price, regist_date) VALUES ('0001', 'T 恤衫', '衣服', 1000, 500);

表示下一行接续本行，只是由于版面所限而换行。

# 注③

插入多行的情况，请参考专栏“多行 INSERT”。

此外，原则上，执行一次 INSERT 语句会插入一行数据。因此，插入多行时，通常需要循环执行相应次数的 INSERT 语句。

# 法则 4-1

原则上，执行一次 INSERT 语句会插入一行数据。

# 专栏

# 多行 INSERT

法则 4- 1 中介绍了“执行一次 INSERT 语句会插入一行数据”的原则。虽然在大多数情况下该原则都是正确的，但它也仅仅是原则而已，其实很多 RDBMS 都支持一次插入多行数据，这样的功能称为多行 INSERT（multirowINSERT）。

# KEYWORD

●多行 INSERT

其语法请参见代码清单 4- A，将多条 VALUES 子句通过逗号进行分隔排列。

# 代码清单 4-A 通常的 INSERT 和多行 INSERT

# 通常的 INSERT

INSERT INTO ProductIns VALUES（'0002'，'打孔器'， '办公用品'，500，320，'2009- 09- 11'）； INSERT INTO ProductIns VALUES（'0003'，'运动 T 恤'， '衣服'，4000，2800，NULL）； INSERT INTO ProductIns VALUES（'0004'，'菜刀'， '厨房用具'，3000，2800，'2009- 09- 20'）； - - 多行 INSERT（Oracle 以外） INSERT INTO ProductIns VALUES（'0002'，'打孔器'， '办公用品'，500，320，'2009- 09- 11'） （'0003'，'运动 T 恤'， '衣服'，4000，2800，NULL） （'0004'，'菜刀'， '厨房用具'，3000，2800，'2009- 09- 20'）；

表示下一行接续本行，只是由于版面所限而换行。

该语法很容易理解，并且减少了书写语句的数量，非常方便。但是，使用该语法时请注意以下几点。

首先，INSERT 语句的书写内容及插入的数据是否正确。若不正确会发生 INSERT 错误，但是由于是多行插入，和特定的单一行插入相比，想要找出到底是哪行哪个地方出错了，就变得十分困难。

其次，多行 INSERT 的语法并不适用于所有的 RDBMS。该语法适用于 DB 2、SQL、SQLServer、PostgreSQL 和 MySQL，但不适用于 Oracle。

# 特定的 SQL

Oracle 使用如下语法来巧妙地完成多行 INSERT 操作。

# Oracle 中的多行 INSERT

INSERT ALL INTO ProductIns VALUES（'0002'，'打孔器'， '办公用品'，500，320，'2009- 09- 11'） INTO ProductIns VALUES（'0003'，'运动 T 恤'， '衣服'，4000，2800，NULL） INTO ProductIns VALUES（'0004'，'菜刀'， '厨房用具'，3000，2800，'2009- 09- 20'） SELECT * FROM DUAL;

表示下一行接续本行，只是由于版面所限而换行。

# 注 1

在书写没有参照表的 SELECT 语句时，写在 FROM 子句中的表。它并没有实际意义，也不保存任何数据，同时也不能作为 INSERT 和 UPDATE 的对象。

DUAL 是 Oracle 特有（安装时的必选项）的一种临时表。因此“SELECT * FROM DUAL”部分也只是临时性的，并没有实际意义。

# 列清单的省略

列清单的省略对表进行全列 INSERT 时，可以省略表名后的列清单。这时 VALUES 子句的值会默认按照从左到右的顺序赋给每一列。因此，代码清单 4- 3 中的两个 INSERT 语句会插入同样的数据。

# 代码清单 4-3 省略列清单

- - 包含列清单 INSERT INTO ProductIns (product_id, product_name, product_type, sale_price, purchase_price, regist_date) VALUES ('0005', '高压锅', '厨房用具', 6800, 5000, '2009-01-15');

- - 省略列清单 INSERT INTO ProductIns VALUES ('0005', '高压锅', '厨房用具', 6800, 5000, '2009-01-15');

表示下一行接续本行，只是由于版面所限而换行。

# 插入 NULL

插入 NULLINSERT 语句中想给某一列赋予 NULL 值时，可以直接在 VALUES 子句的值清单中写入 NULL。例如，要向 purchase_price 列（进货单价）中插入 NULL，就可以使用代码清单 4- 4 中的 INSERT 语句。

# 代码清单 4-4 向 purchase_price 列中插入 NULL

INSERT INTO ProductIns (product_id, product_name, product_type, sale_price, purchase_price, regist_date) VALUES ('0006', '叉子', '厨房用具', 500, NULL, '2009- 09- 20');

表示下一行接续本行，只是由于版面所限而换行。

但是，想要插入 NULL 的列一定不能设置 NOT NULL 约束。向设置了 NOT NULL 约束的列中插入 NULL 时，INSERT 语句会出错，导致数据插入失败。

插入失败指的是希望通过 INSERT 语句插入的数据无法正常插入到表中，但之前已经插入的数据并不会被破坏。

# 注①

不仅是 INSERT, DELETE 和 UPDATE 等更新语句也一样，SQL 语句执行失败时都不会对表中数据造成影响。

# 插入默认值

# KEYWORD

●默认值●DEFAULT 约束

我们还可以向表中插入默认值（初始值）。可以通过在创建表的 CREATE TABLE 语句中设置 DEFAULT 约束来设定默认值。

本章开头创建的 ProductIns 表的定义部分请参见代码清单 4- 5。其中 DEFAULT 0 就是设置 DEFAULT 约束的部分。像这样，我们可以通过“DEFAULT  $<$  默认值  $>$  ”的形式来设定默认值。

# 代码清单 4-5 创建 ProductIns 表的 CREATE TABLE 语句（节选）

CREATE TABLE ProductIns (product_id CHAR (4) NOT NULL, （略） sale_price INTEGER DEFAULT 0，- - 销售单价的默认值设定为 0； （略） PRIMARYKEY（product_id));

如果在创建表的同时设定了默认值，就可以在 INSERT 语句中自动为列赋值了。默认值的使用方法通常有显式和隐式两种。

# 通过显式方法插入默认值

# KEYWORD

●DEFAULT 关键字

在 VALUES 子句中指定 DEFAULT 关键字（代码清单 4- 6）。

# 代码清单 4-6 通过显式方法设定默认值

INSERT INTO ProductIns (product_id, product_name, product_type, sale_price, purchase_price, _regist_date) VALUES ('0007', '擦菜板', '厨房用具', DEFAULT, 790, '2009- 04- 28');

表示下一行接续本行，只是由于版面所限而换行。

这样一来，RDBMS 就会在插入记录时自动把默认值赋给对应的列。我们可以使用 SELECT 语句来确认通过 INSERT 语句插入的数据行。

确认插入的数据行：SELECT \* FROM ProductIns WHERE product_id  $=$  '0007';

因为 sale_price 列（销售单价）的默认值是 0，所以 sale_price 列被赋予了值 0。

# 执行结果

product_id | product_name | product_type | sale_price | purchase_price | regist_date 0007 | 瘤菜板 | 厨房用具 | 0 | 790 | 2008- 04- 28

# 通过隐式方法插入默认值

通过隐式方法插入默认值插入默认值时也可以不使用 DEFAULT 关键字，只要在列清单和 VALUES 中省略设定了默认值的列就可以了。我们可以像代码清单 4- 7 那样，从 INSERT 语句中删除 sale_price 列（销售单价）。

# 代码清单 4-7 通过隐式方法设定默认值

# 省略 sale_price 列

INSERT INTO ProductIns (product id, product_name, product_type, purchase_price, regist_date) VALUES ('0007', '原菜板', '厨房用具', 790, '2009- 04- 28');

表示下一行接续本行，只是由于版面所限而换行。

这样也可以给 sale_price 赋上默认值 0。

那么在实际使用中哪种方法更好呢？笔者建议大家使用显式的方法。因为这样可以一目了然地知道 sale_price 列使用了默认值，SQL 语句的含义也更加容易理解。

说到省略列名，还有一点要说明一下。如果省略了没有设定默认值的列，该列的值就会被设定为 NULL。因此，如果省略的是设置了 NOT NULL 约束的列，INSERT 语句就会出错（代码清单 4- 8）。请大家一定要注意。

# 代码清单 4-8 未设定默认值的情况

- -省略 purchase_price 列（无约束）：会赋予“NULL”INSERT INTO ProductIns (product_id, product_name, product_type, sale_price, regist_date) VALUES ('0008', '圆珠笔', '办公用品', 100, '2009-11-11');

- -省略 product_name 列（设置了 NOT NULL 约束）：错误！INSERT INTO ProductIns (product_id, product_type, sale_price, purchase_price, regist_date) VALUES ('0009', '办公用品', 1000, 500, '2009-12-12');

表示下一行接续本行，只是由于版面所限而换行。

# 法则 4-2

省略 INSERT 语句中的列名，就会自动设定为该列的默认值（没有默认值时会设定为 NULL）。

# 从其他表中复制数据

要插入数据，除了使用 VALUES 子句指定具体的数据之外，还可以从其他表中复制数据。下面我们就来学习如何从一张表中选取数据，复制到另外一张表中。

要学习该方法，我们首先得创建一张表（代码清单 4- 9）。

# 代码清单 4-9 创建 ProductCopy 表的 CREATE TABLE 语句

- - 用来插入数据的商品复制表 CREATE TABLE ProductCopy (product_id CHAR (4) NOT NULL, product_name VARCHAR (100) NOT NULL, product_type VARCHAR (32) NOT NULL, sale_price INTEGER purchase_price INTEGER ,regist_date DATE PRIMARY KEY (product_id));

ProductCopy（商品复制）表的结构与之前使用的 Product（商品）表完全一样，只是更改了一下表名而已。

接下来，就让我们赶快尝试一下将 Product 表中的数据插入到 ProductCopy 表中吧。代码清单 4- 10 中的语句可以将查询的结果直接插入到表中。

# 代码清单 4-10 INSERT ... SELECT 语句

- - 将商品表中的数据复制到商品复制表中 INSERT INTO ProductCopy (product_id, product_name, product_type, sale_price, purchase_price, regist_date) SELECT product_id, product_name, product_type, sale_price, purchase_price, regist_dateFROM Product;

表示下一行接续本行，只是由于版面所限而换行。

# KEYWORD

INSERT ... SELECT 语句

执行该 INSERT ... SELECT 语句时，如果原来 Product 表中有 8 行数据，那么 ProductCopy 表中也会插入完全相同的 8 行数据。当然，Product 表中的原有数据不会发生改变。因此，INSERT ... SELECT 语句可以在需要进行数据备份时使用（图 4- 2）。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/9336f62e77e65490cd903e5532924c21564af03a3eb7e03bf0a673398b64a876.jpg)  
使用 INSERT... SELECT 语句可以在关联的表之间传递数据

# 多种多样的 SELECT 语句

# 注 1

但即使指定了 ORDER BY 子句也没有任何意义，因为无法保证表内部记录的排列顺序。

该 INSERT 语句中的 SELECT 语句，也可以使用 WHERE 子句或者 GROUP BY 子句等。目前为止学到的各种 SELECT 语句也都可以使用。对在关联表之间存取数据来说，这是非常方便的功能。

接下来我们尝试一下使用包含 GROUP BY 子句的 SELECT 语句进行插入。代码清单 4- 11 中的语句创建了一个用来插入数据的表。

# 代码清单 4-11 创建 ProductType 表的 CREATE TABLE 语句

- - 根据商品种类进行汇总的表：CREATE TABLE ProductType (product_type VARCHAR (32) NOT NULL, sum_sale_price INTEGER, sum_purchase_price INTEGER, PRIMARY KEY (product_type));

该表是用来存储根据商品种类（product_type）计算出的销售单价合计值以及进货单价合计值的表。下面就让我们使用代码清单 4- 12 中的 INSERT... SELECT 语句，从 Product 表中选取出数据插入到这张表中吧。

# 代码清单 4-12 插入其他表中数据合计值的 INSERT... SELECT 语句

INSERT INTO ProductType (product_type, sum_sale_price, sum_purchase_price) SELECT product_type, SUM (sale_price), SUM (purchase_price) FROM Product GROUP BY product_type;

表示下一行接续本行，只是由于版面所限而换行。

通过 SELECT 语句对插入结果进行确认，我们发现 ProductType 表中插入了以下 3 行数据。

- - 确认插入的数据行 SELECT * FROM ProductType;

# 执行结果

<table><tr><td colspan="3">product_type | sum_sale_price | sum_purchase_price</td></tr><tr><td>衣服</td><td>5000</td><td>3300</td></tr><tr><td>办公用品</td><td>600</td><td>320</td></tr><tr><td>厨房用具</td><td>11180</td><td>8590</td></tr></table>

# 法则 4-3

INSERT 语句的 SELECT 语句中，可以使用 WHERE 子句或者 GROUP BY 子句等任何 SQL 语法（但使用 ORDER BY 子句并不会产生任何效果）。

# 4-2

# 第 4 章数据更新

# 数据的删除（DELETE 语句的使用方法）

# 学习重点

学习重点- 如果想将整个表全部删除，可以使用 DROP TABLE 语句，如果只想删除表中全部数据，需使用 DELETE 语句。- 如果想删除部分数据行，只需在 WHERE 子句中书写对象数据的条件即可。通过 WHERE 子句指定删除对象的 DELETE 语句称为搜索型 DELETE 语句。

# DROP TABLE 语句和 DELETE 语句

上一节我们学习了插入数据的方法，本节我们来学习如何删除数据。删除数据的方法大体可以分为以下两种。

KEYWORD- DROP TABLE 语句- DELETE 语句

$①$  DROP TABLE 语句可以将表完全删除 $(2)$  DELETE 语句会留下表（容器），而删除表中的全部数据

$①$  中的 DROP TABLE 语句我们已经在 1- 5 节中学过了，此处再简单回顾一下。DROP TABLE 语句会完全删除整张表，因此删除之后再想插入数据，就必须使用 CREATE TABLE 语句重新创建一张表。

反之， $(2)$  中的 DELETE 语句在删除数据（行）的同时会保留数据表，因此可以通过 INSERT 语句再次向表中插入数据。

本节所要介绍的删除数据，指的就是只删除数据的 DELETE 语句。

此外，我们在第 1 章中也提到过，不管使用哪种方法，删除数据时都要慎重，一旦误删，想要恢复数据就会变得十分困难。

# DELETE 语句的基本语法

DELETE 语句的基本语法如下所示，十分简单。

语法 4- 2 保留数据表，仅删除全部数据行的 DELETE 语句

DELETE FROM <表名>；

执行使用该基本语法的 DELETE 语句，就可以删除指定的表中的全部数据行了。因此，想要删除 Product 表中全部数据行，就可以参照代码清单 4- 13 来书写 DELETE 语句。

# 代码清单 4-13 清空 Product 表

DELETE FROM Product;

如果语句中忘了写 FROM，而是写成了“DELETE < 表名 >”，或者写了多余的列名，都会出错，无法正常执行，请大家特别注意。

前者无法正常执行的原因是删除对象不是表，而是表中的数据行（记录）。这样想的话就很容易理解了吧。

与 INSERT 语句相同，数据的更新也是以记录为基本单位进行的。下一节将要学习的 UPDATE 语句也是如此。

后者错误的原因也是如此。因为 DELETE 语句的对象是行而不是列，所以 DELETE 语句无法只删除部分列的数据。因此，在 DELETE 语句中指定列名是错误的。当然，使用星号的写法（DELETE * FROM Product；）也是不对的，同样会出错。

# 法则 4-4

DELETE 语句的删除对象并不是表或者列，而是记录（行）。

# 指定删除对象的 DELETE 语句（搜索型 DELETE）

# KEYWORD

搜索型 DELETE

想要删除部分数据行时，可以像 SELECT 语句那样使用 WHERE 子句指定删除条件。这种指定了删除对象的 DELETE 语句称为搜索型 DELETE。

# 注②

虽然“搜索型 DELETE”是正式用语，但实际上这种说法并不常用，而是简单地称为 DELETE 语句。

搜索型 DELETE 的语法如下所示。

# 语法 4-3 删除部分数据行的搜索型 DELETE

DELETE FROM < 表名 > WHERE < 条件 >；

下面让我们以 Product（商品）表为例，来具体研究一下如何进行数据删除（表 4- 1）。

表 4-1 Product 表  

<table><tr><td>product_id
(商品编号)</td><td>product_name
(商品名称)</td><td>product_type
(商品种类)</td><td>sale_price
(销售单价)</td><td>purchase_price
(进货单价)</td><td>regist_date
(登记日期)</td></tr><tr><td>0001</td><td>T 恤衫</td><td>衣服</td><td>1000</td><td>500</td><td>2009-09-20</td></tr><tr><td>0002</td><td>打孔器</td><td>办公用品</td><td>500</td><td>320</td><td>2009-09-11</td></tr><tr><td>0003</td><td>运动 T 恤</td><td>衣服</td><td>4000</td><td>2800</td><td></td></tr><tr><td>0004</td><td>菜刀</td><td>厨房用具</td><td>3000</td><td>2800</td><td>2009-09-20</td></tr><tr><td>0005</td><td>高压锅</td><td>厨房用具</td><td>6800</td><td>5000</td><td>2009-01-15</td></tr><tr><td>0006</td><td>叉子</td><td>厨房用具</td><td>500</td><td></td><td>2009-09-20</td></tr><tr><td>0007</td><td>擦菜板</td><td>厨房用具</td><td>880</td><td>790</td><td>2008-04-28</td></tr><tr><td>0008</td><td>圆珠笔</td><td>办公用品</td><td>100</td><td></td><td>2009-11-11</td></tr></table>

假设我们要删除销售单价（sale_price）大于等于 4000 日元的数据（代码清单 4- 14）。上述表中满足该条件的是“运动 T 恤”和“高压锅”。

代码清单 4- 14 删除销售单价（sale_price）大于等于 4000 日元的数据

DELETE FROM Product WHERE sale_price >= 4000;

WHERE 子句的书写方式与此前介绍的 SELECT 语句完全一样。

通过使用 SELECT 语句确认，表中的数据被删除了 2 行，只剩下 6 行。

确认删除后的结果 SELECT * FROM Product;

执行结果  

<table><tr><td>product_id</td><td>product_name</td><td>product_type</td><td>sale_price</td><td>purchase_price</td><td>regist_date</td></tr><tr><td>0001</td><td>T 恤衫</td><td>衣服</td><td>1000</td><td>500</td><td>2009-09-20</td></tr><tr><td>0002</td><td>打孔器</td><td>办公用品</td><td>500</td><td>320</td><td>2009-09-11</td></tr><tr><td>0004</td><td>菜刀</td><td>厨房用具</td><td>3000</td><td>2800</td><td>2009-09-20</td></tr><tr><td>0006</td><td>叉子</td><td>厨房用具</td><td>500</td><td>2009-09-20</td><td></td></tr><tr><td>0007</td><td>擦菜板</td><td>厨房用具</td><td>880</td><td>790</td><td>2008-04-28</td></tr><tr><td>0008</td><td>圆珠笔</td><td>办公用品</td><td>100</td><td>2009-11-11</td><td></td></tr></table>

# 法则 4-5

可以通过 WHERE 子句指定对象条件来删除部分数据。

与 SELECT 语句不同的是，DELETE 语句中不能使用 GROUP BY、HAVING 和 ORDER BY 三类子句，而只能使用 WHERE 子句。原因很简单，GROUP BY 和 HAVING 是从表中选取数据时用来改变抽取数据形式的，而 ORDER BY 是用来指定取得结果显示顺序的。因此，在删除表中数据时它们都起不到什么作用。

# 专栏

# KEYWORD

●TRUNCATE 语句

# 删除和舍弃

标准 SQL 中用来从表中删除数据的只有 DELETE 语句。但是，很多数据库产品中还存在另外一种被称为 TRUNCATE 的语句。这些产品主要包括 Oracle、SQL Server、PostgreSQL、MySQL 和 DB 2。

TRUNCATE 是舍弃的意思，具体的使用方法如下所示

# 语法 4-A 只能删除表中全部数据的 TRUNCATE 语句

TRUNCATE <表名>;

与 DELETE 不同的是，TRUNCATE 只能删除表中的全部数据，而不能通过 WHERE 子句指定条件来删除部分数据。也正是因为它不能具体地控制删除对象，所以其处理速度比 DELETE 要快得多。实际上，DELETE 语句在 DML 语句中也属于处理时间比较长的，因此需要删除全部数据行时，使用 TRUNCATE 可以缩短执行时间。

# 注 1

因此，Oracle 中的 TRUNCATE 不能使用 ROLLBACK。执行 TRUNCATE 的同时会默认执行 COMMIT 操作。

但是，产品不同需要注意的地方也不尽相同。例如在 Oracle 中，把 TRUNCATE 定义为 DDL，而不是 DML。使用 TRUNCATE 时，请大家仔细阅读使用手册，多加注意。便利的工具往往还是会存在一些不足之处的。

# 4-3

# 第 4 章数据更新

# 数据的更新（UPDATE 语句的使用方法）

# 学习重点

学习重点- 使用 UPDATE 语句可以更改（更新）表中的数据。- 更新部分数据行时可以使用 WHERE 来指定更新对象的条件。通过 WHERE 子句指定更新对象的 UPDATE 语句称为搜索型 UPDATE 语句。- UPDATE 语句可以将列的值更新为 NULL。- 同时更新多列时，可以在 UPDATE 语句的 SET 子句中，使用逗号分隔更新对象的多个列。

# UPDATE 语句的基本语法

# KEYWORD

UPDATE 语句

使用 INSERT 语句向表中插入数据之后，有时却想要再更改数据，例如“将商品销售单价登记错了”等的时候。这时并不需要把数据删除之后再重新插入，使用 UPDATE 语句就可以改变表中的数据了。

和 INSERT 语句、DELETE 语句一样，UPDATE 语句也属于 DML 语句。通过执行该语句，可以改变表中的数据。其基本语法如下所示。

# 语法 4-4 改变表中数据的 UPDATE 语句

UPDATE <表名>  SET <列名> = <表达式>;

# KEYWORD

SET 子句

将更新对象的列和更新后的值都记述在 SET 子句中。我们还是以 Product（商品）表为例，由于之前我们删除了“销售单价大于等于 4000 日元”的 2 行数据，现在该表中只剩下了 6 行数据了（表 4- 2）。

表 4-2 Product 表  

<table><tr><td>product_id
(商品编号)</td><td>product_name
(商品名称)</td><td>product_type
(商品种类)</td><td>sale_price
(销售单价)</td><td>purchase_price
(进货单价)</td><td>regist_date
(登记日期)</td></tr><tr><td>0001</td><td>T 恤衫</td><td>衣服</td><td>1000</td><td>500</td><td>2009-09-20</td></tr><tr><td>0002</td><td>打孔器</td><td>办公用品</td><td>500</td><td>320</td><td>2009-09-11</td></tr><tr><td>0004</td><td>菜刀</td><td>厨房用具</td><td>3000</td><td>2800</td><td>2009-09-20</td></tr><tr><td>0006</td><td>叉子</td><td>厨房用具</td><td>500</td><td></td><td>2009-09-20</td></tr><tr><td>0007</td><td>擦菜板</td><td>厨房用具</td><td>880</td><td>790</td><td>2008-04-28</td></tr><tr><td>0008</td><td>圆珠笔</td><td>办公用品</td><td>100</td><td></td><td>2009-11-11</td></tr></table>

接下来，让我们尝试把 regist_date 列（登记日期）的所有数据统一更新为“2009- 10- 10”。具体的 SQL 语句请参见代码清单 4- 15。

# 代码清单 4-15 将登记日期全部更新为“2009-10-10”

UPDATE Product SET regist_date = '2009- 10- 10';

表中的数据有何变化呢？我们通过 SELECT 语句来确认一下吧。

确认更新内容 SELECT * FROM Product ORDER BY product_id;

执行结果  

<table><tr><td>product_id</td><td>product_name</td><td>product_type</td><td>sale_price</td><td>purchase_price</td><td>regist_date</td></tr><tr><td>0001</td><td>T 恤衫</td><td>衣服</td><td>1000</td><td>500</td><td>2009-10-10</td></tr><tr><td>0002</td><td>打孔器</td><td>办公用品</td><td>500</td><td>320</td><td>2009-10-10</td></tr><tr><td>0004</td><td>菜刀</td><td>厨房用具</td><td>3000</td><td>2800</td><td>2009-10-10</td></tr><tr><td>0006</td><td>叉子</td><td>厨房用具</td><td>500</td><td>2009-10-10</td><td></td></tr><tr><td>0007</td><td>擦菜板</td><td>厨房用具</td><td>880</td><td>790</td><td>2009-10-10</td></tr><tr><td>0008</td><td>圆珠笔</td><td>办公用品</td><td>100</td><td>2009-10-10</td><td></td></tr><tr><td></td><td></td><td></td><td></td><td>所有行的数据都被更新为“2009-10-10”</td><td></td></tr></table>

此时，连登记日期原本为 NULL 的数据行（运动 T 恤）的值也更新为 2009- 10- 10 了。

<table><tr><td>0003</td><td>运动 T 恤</td><td>衣服</td><td>4000</td><td>2800</td><td>|</td></tr><tr><td></td><td></td><td></td><td>↓</td><td></td><td></td></tr><tr><td>0003</td><td>运动 T 恤</td><td>衣服</td><td>4000</td><td>2800</td><td>2009-10-10</td></tr></table>

# 指定条件的 UPDATE 语句（搜索型 UPDATE）

接下来，让我们看一看指定更新对象的情况。更新数据时也可以像 DELETE 语句那样使用 WHERE 子句，这种指定更新对象的 UPDATE 语句称为搜索型 UPDATE 语句。该语句的语法如下所示（与 DELETE 语句十分相似）。

# 语法 4-5 更新部分数据行的搜索型 UPDATE

UPDATE <表名>SET <列名> = <表达式>WHERE <条件>;

例如，将商品种类（product_type）为厨房用具的记录的销售单价（sale_price）更新为原来的 10 倍，请参见代码清单 4- 16。

代码清单 4- 16 将商品种类为厨房用具的记录的销售单价更新为原来的 10 倍

UPDATE Product SET sale_price = sale_price * 10 WHERE product_type = '厨房用具';

我们可以使用如下 SELECT 语句来确认更新后的内容。

确认更新内容 SELECT * FROM Product ORDER BY product_id;

# 执行结果

<table><tr><td>product_id</td><td>product_name</td><td>product_type</td><td>sale_price</td><td>purchase_price</td><td>regist_date</td></tr><tr><td>0001</td><td>T 恤衫</td><td>衣服</td><td>1000</td><td>500</td><td>2009-10-10</td></tr><tr><td>0002</td><td>打孔器</td><td>办公用品</td><td>500</td><td>320</td><td>2009-10-10</td></tr><tr><td>0004</td><td>菜刀</td><td>厨房用具</td><td>30000</td><td>2800</td><td>2009-10-10</td></tr><tr><td>0006</td><td>叉子</td><td>厨房用具</td><td>5000</td><td>2009-10-10</td><td></td></tr><tr><td>0007</td><td>擦菜板</td><td>厨房用具</td><td>8800</td><td>790</td><td>2009-10-10</td></tr><tr><td>0008</td><td>圆珠笔</td><td>办公用品</td><td>100</td><td>2009-10-10</td><td></td></tr></table>

该语句通过 WHERE 子句中的“product_type = '厨房用具'”条件，将更新对象限定为 3 行。然后通过 SET 子句中的表达式 sale_price * 10，将原来的单价扩大了 10 倍。SET 子句中赋值表达式的右边不仅可以是单纯的值，还可以是包含列的表达式。

# 使用 NULL 进行更新

使用 UPDATE 也可以将列更新为 NULL（该更新俗称为 NULL 清空）。此时只需要将赋值表达式右边的值直接写为 NULL 即可。例如，我们可以将商品编号（product_id）为 0008 的数据（圆珠笔）的登记日期（regist_date）更新为 NULL（代码清单 4- 17）。

代码清单 4- 17 将商品编号为 0008 的数据（圆珠笔）的登记日期更新为 NULL

UPDATE Product SET regist_date = NULL WHERE product_id = '0008';

确认更新内容 SELECT * FROM Product ORDER BY product_id;

执行结果  

<table><tr><td>product_id</td><td>product_name</td><td>product_type</td><td>sale_price</td><td>purchase_price</td><td>regist_date</td></tr><tr><td>0001</td><td>T 恤衫</td><td>衣服</td><td>1000</td><td>500</td><td>2009-10-10</td></tr><tr><td>0002</td><td>打孔器</td><td>办公用品</td><td>500</td><td>320</td><td>2009-10-10</td></tr><tr><td>0004</td><td>菜刀</td><td>厨房用具</td><td>30000</td><td>2800</td><td>2009-10-10</td></tr><tr><td>0006</td><td>叉子</td><td>厨房用具</td><td>5000</td><td>2009-10-10</td><td></td></tr><tr><td>0007</td><td>簸箕板</td><td>厨房用具</td><td>8800</td><td>790</td><td>2009-10-10</td></tr><tr><td>0008</td><td>圆珠笔</td><td>办公用品</td><td>100</td><td>登记日期被更新为 NULL</td><td></td></tr></table>

和 INSERT 语句一样，UPDATE 语句也可以将 NULL 作为一个值来使用。

但是，只有未设置 NOT NULL 约束和主键约束的列才可以清空为 NULL。如果将设置了上述约束的列更新为 NULL，就会出错，这点与 INSERT 语句相同。

# 法则 4-6

使用 UPDATE 语句可以将值清空为 NULL（但只限于未设置 NOT NULL 约束的列）。

# 多列更新

UPDATE 语句的 SET 子句支持同时将多个列作为更新对象。例如我们刚刚将销售单价（sale_price）更新为原来的 10 倍，如果想同时将进货单价（purchase_price）更新为原来的一半，该怎么做呢？最容易想到的解决办法可能就是像代码清单 4- 18 那样，执行两条 UPDATE 语句。

# 代码清单 4-18 能够正确执行的繁琐的 UPDATE 语句

- --一条 UPDATE 语句只更新一列 UPDATE ProductSET sale_price = sale_price * 10 WHERE product_type = '厨房用具'; UPDATE ProductSET purchase_price = purchase_price / 2 WHERE product_type = '厨房用具';

虽然这样也能够正确地更新数据，但执行两次 UPDATE 语句不但有些浪费，而且增加了 SQL 语句的书写量。其实，我们可以将其合并为

一条 UPDATE 语句来处理。合并的方法有两种，请参见代码清单 4- 19 和代码清单 4- 20。

# 方法  $①$  ：代码清单 4-19 将代码清单 4-18 的处理合并为一条 UPDATE 语句

- - 使用逗号对列进行分隔排列 UPDATE Product- SET sale_price = sale_price * 10, purchase_price = purchase_price / 2 WHERE product_type = '厨房用具';

# 方法  $(2)$  ：代码清单 4-20 将代码清单 4-18 的处理合并为一条 UPDATE 语句

- - 将列用（）括起来的清单形式 UPDATE Product SET (sale_price, purchase_price) = (sale_price * 10, purchase_price / 2) WHERE product_type = '厨房用具';

表示下一行接续本行，只是由于版面所限而换行。

执行上述两种 UPDATE 语句，都可以得到相同的结果：只有厨房用具的销售单价（sale_price）和进货单价（purchase_price）被更新了。

- - 确认更新内容 SELECT * FROM Product ORDER BY product_id;

# 执行结果

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/b55d71802d4d5dc620f62cd2792cff306efeb031de5e4334b315f57de4aa37bd.jpg)

当然，SET 子句中的列不仅可以是两列，还可以是三列或者更多。

需要注意的是第一种方法——使用逗号将列进行分隔排列（代码清单 4- 19），这一方法在所有的 DBMS 中都可以使用。但是第二种方法——将列清单化（代码清单 4- 20），这一方法在某些 DBMS 中是无法使用的。因此，实际应用中通常都会使用第一种方法。

# 4-4

# 第 4 章数据更新

# 事务

# 学习重点

- 事务是需要在同一个处理单元中执行的一系列更新处理的集合。通过使用事务，可以对数据库中的数据更新处理的提交和取消进行管理。- 事务处理的终止指令包括 COMMIT（提交处理）和 ROLLBACK（取消处理）两种。- DBMS 的事务具有原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability）四种特性。通常将这四种特性的首字母结合起来，统称为 ACID 特性。

# 什么是事务

# KEYWORD

# 事务

估计有些读者对事务（transaction）这个词并不熟悉，它通常被用于商务贸易或者经济活动中，但是在 RDBMS 中，事务是对表中数据进行更新的单位。简单来讲，事务就是需要在同一个处理单元中执行的一系列更新处理的集合。

如前几节所述，对表进行更新需要使用 INSERT、DELETE 或者 UPDATE 三种语句。但通常情况下，更新处理并不是执行一次就结束了，而是需要执行一系列连续的操作。这时，事务就能体现出它的价值了。

说到事务的例子，请大家思考一下下述情况

现在，请大家把自己想象为管理 Product（商品）表的程序员或者软件工程师。销售部门的领导对你提出了如下要求。

“某某，经会议讨论，我们决定把运动 T 恤的销售单价下调 1000 日元，同时把 T 恤衫的销售单价上浮 1000 日元，麻烦你去更新一下数据库。”

由于大家已经学习了更新数据的方法——只需要使用 UPDATE 进行更新就可以了，所以肯定会直接回答“知道了，请您放心吧”。

此时的事务由如下两条更新处理所组成。

# $\bullet$  更新商品信息的事务

$①$  将运动 T 恤的销售单价降低 1000 日元

UPDATE Product SET sale_price = sale_price - 1000 WHERE product_name = '运动 T 恤';

$(2)$  将 T 恤衫的销售单价上浮 1000 日元

UPDATE Product SET sale_price = sale_price + 1000 WHERE product_name = 'T 恤衫';

上述  $(1)$  和  $(2)$  的操作一定要作为同一个处理单元执行。如果只执行了  $(1)$  的操作而忘记了执行  $(2)$  的操作，或者反过来只执行了  $(2)$  的操作而忘记了执行  $(1)$  的操作，一定会受到领导的严厉批评。遇到这种需要在同一个处理单元中执行一系列更新操作的情况，一定要使用事务来进行处理。

# 法则 4-7

事务是需要在同一个处理单元中执行的一系列更新处理的集合。

一个事务中包含多少个更新处理或者包含哪些处理，在 DBMS 中并没有固定的标准，而是根据用户的要求决定的（例如，运动 T 恤和 T 恤衫的销售单价需要同时更新这样的要求，DBMS 是无法了解的）。

# 创建事务

如果想在 DBMS 中创建事务，可以按照如下语法结构编写 SQL 语句。

# 语法 4-6 事务的语法

事务开始语句；

DML 语句  $(1)$  DML 语句  $(2)$  DML 语句  $(3)$

事务结束语句（COMMIT 或者 ROLLBACK）；

使用事务开始语句和事务结束语句，将一系列 DML 语句（INSERT/UPDATE/DELETE 语句）括起来，就实现了一个事务处理。

# 注①

与之相对，事务结束语句只有 COMMIT 和 ROLLBACK 两种，在所有的 RDBMS 中都是通用的。

# KEYWORD

●BEGIN TRANSACTION  ●START TRANSACTION

这时需要特别注意的是事务的开始语句。实际上，在标准 SQL 中并没有定义事务的开始语句，而是由各个 DBMS 自己来定义的。比较有代表性的语法如下所示。

●SQL Server、PostgreSQL

BEGIN TRANSACTION

●MySQL  START TRANSACTION

●Oracle、DB 2  无

例如使用之前的那两个 UPDATE（ $①$ 和 $(2)$ ）创建出的事务如代码清单 4- 21 所示。

# 代码清单 4-21 更新商品信息的事务

# SQL Server PostgreSQL

BEGIN TRANSACTION;

- - 将运动 T 恤的销售单价降低 1000 日元  UPDATE Product  SET sale_price = sale_price - 1000  WHERE product_name = '运动 T 恤';

- - 将 T 恤衫的销售单价上浮 1000 日元

UPDATE Product  SET sale_price = sale_price + 1000  WHERE product_name = 'T 恤衫';

COMMIT;

# MySQL

START TRANSACTION;

- - 将运动 T 恤的销售单价降低 1000 日元  UPDATE Product  SET sale_price = sale_price - 1000  WHERE product_name = '运动 T 恤';

- - 将 T 恤衫的销售单价上浮 1000 日元

UPDATE Product  SET sale_price = sale_price + 1000  WHERE product_name = 'T 恤衫';

COMMIT;

# Oracle DB 2

- - 将运动 T 恤的销售单价降低 1000 日元

UPDATE Product  SET sale_price = sale_price - 1000  WHERE product_name = '运动 T 恤';

- - 将 T 恤衫的销售单价上浮 1000 日元 UPDATE ProductSET sale_price = sale_price + 1000 WHERE product_name = 'T 恤衫'; COMMIT;

# 注①

《标准 SQL 手册修订第 4 版》中的记述：希望大家注意事务默认开始的时间点。没有“BEGIN TRANSACTION”这样明确的开始标志。

如上所示，各个 DBMS 事务的开始语句都不尽相同，其中 Oracle 和 DB 2 并没有定义特定的开始语句。可能大家觉得这样的设计很巧妙，其实是因为标准 SQL 中规定了一种悄悄开始事务处理的方法。因此，即使是经验丰富的工程师也经常会忽略事务处理开始的时间点。大家可以试着通过询问“是否知道某个 DBMS 中事务是什么时候开始的”，来测试学校或者公司前辈的数据库知识。

反之，事务的结束需要用户明确地给出指示。结束事务的指令有如下两种。

# COMMIT——提交处理

# KEYWORD

COMMIT

提交

COMMIT 是提交事务包含的全部更新处理的结束指令（图 4- 3），相当于文件处理中的覆盖保存。一旦提交，就无法恢复到事务开始前的状态了。因此，在提交之前一定要确认是否真的需要进行这些更新。

![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/27761adb4a4ed31fd237372dcd9dd1d791e39b73264838313488762cd04fd6fa.jpg)  
图 4-3 COMMIT 的流程  $=$  直线进行

结束后的状态：  $(2)$  中的所有更新都被反映到了数据库中

万一由于误操作提交了包含错误更新的事务，就只能回到重新建表、重新插入数据这样繁琐的老路上了。由于可能会造成数据无法恢复的后果，请大家一定要注意（特别是在执行 DELETE 语句的 COMMIT 时尤其要小心）。

# 法则 4-8

虽然我们可以不清楚事务开始的时间点，但是在事务结束时一定要仔细进行确认。

# ROLLBACK——取消处理

# KEYWORD

ROLLBACK 回滚

ROLLBACK 是取消事务包含的全部更新处理的结束指令（图 4- 4），相当于文件处理中的放弃保存。一旦回滚，数据库就会恢复到事务开始之前的状态（代码清单 4- 22）。通常回滚并不会像提交那样造成大规模的数据损失。

图 4-4 ROLLBACK 的流程  $=$  掉头回到起点  
![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/782a6dc011852d5a27e5bcdd28a9f991ca4c1508b85d0b0e8a7df80607eafda0.jpg)  
结束后的状态：和  $\mathbb{C}$  执行前相同

# 代码清单 4-22 事务回滚的例子

# SQL Server PostgreSQL

BEGIN TRANSACTION;

- 
- 将运动 T 恤的销售单价降低 1000 日元 UPDATE Product SET sale_price = sale_price - 1000 WHERE product_name = '运动 T 恤';- 
- 将 T 恤衫的销售单价上浮 1000 日元 UPDATE Product SET sale_price = sale_price + 1000 WHERE product_name = 'T 恤衫';

ROLLBACK;

# 特定的 SQL

至此，我们已经知道各个 DBMS 中关于事务的语法不尽相同。代码清单 4- 22 中的语句在 MySQL 中执行时需要将①语句改写为“START TRANSACTION”，而在 Oracle 和 DB 2 中执行时则无需①语句（请将其删除），具体请参考 4- 4 节的“创建事务”。

上述事务处理执行之后，表中的数据不会发生任何改变。这是因为执行最后一行的 ROLLBACK 之后，所有的处理都被取消了。因此，回滚执行起来就无需像提交时那样小心翼翼了（即使是想要提交的情况，也只需要重新执行事务处理就可以了）。

# 专栏

# 事务处理何时开始

之前我们说过，事务并没有标准的开始指令存在，而是根据 DBMS 的不同而不同。

实际上，几乎所有的数据库产品的事务都无需开始指令。这是因为大部分情况下，事务在数据库连接建立时就已经悄悄开始了，并不需要用户再明确发出开始指令。例如，使用 Oracle 时，数据库连接建立之后，第一条 SQL 语句执行的同时，事务就已经悄悄开始了。

像这样不使用指令而悄悄开始事务的情况下，应该如何区分各个事务呢？通常会有如下两种情况。

# KEYWORD

自动提交模式

# 注①

例如，PostgreSQL 的用户手册中有如下记述：“PostgreSQL 中所有的 SQL 指令语句都在事务内执行。即使不执行 BEGIN，这些命令语句也会在执行时悄悄被括在 BEGIN 和 COMMIT（如果成功的语）之间。”（《PostgreSQL 9.5.2 文档》“3- 4 节事务”）

$(\underline{A})$  每条 SQL 语句就是一个事务（自动提交模式）

$(\widehat{\mathbb{B}})$  直到用户执行 COMMIT 或者 ROLLBACK 为止算作一个事务

通常的 DBMS 都可以选择其中任意一种模式。默认使用自动提交模式的 DBMS 有 SQL Server、PostgreSQL 和 MySQL 等。该模式下的 DML 语句如下所示，每一条语句都括在事务的开始语句和结束语句之中。

# BEGIN TRANSACTION:

- - 将运动 T 恤的销售单价降低 1000 日元 UPDATE ProductSET sale_price = sale_price - 1000 WHERE product_name = '运动 T 恤';

COMMIT;

BEGIN TRANSACTION;- - 将 T 恤衫的销售单价上浮 1000 日元 UPDATE ProductSET sale_price = sale_price + 1000 WHERE product_name = 'T 恤衫'; COMMIT;

在默认使用 B 模式的 Oracle 中，事务都是直到用户自己执行提交或者回滚指令才会结束。

自动提交的情况需要特别注意的是 DELETE 语句。如果不是自动提交，即使使用 DELETE 语句删除了数据表，也可以通过 ROLLBACK 命令取消该事务的处理，恢复表中的数据。但这仅限于明示开始事务，或者关闭自动提交的情况。如果不小心在自动提交模式下执行了 DELETE 操作，即使再回滚也无济于事了。这是一个很严重的问题，初学者难免会碰到这样的麻烦。一旦误删了数据，如果无法重新插入，是不是想哭的心都有了？所以一定要特别小心。

# ACID 特性

# KEYWORD

ACID 特性

DBMS 的事务都遵循四种特性，将这四种特性的首字母结合起来统称为 ACID 特性。这是所有 DBMS 都必须遵守的规则。

# KEYWORD

KEYWORD 原子性（Atomicity）

# 原子性（Atomicity）

原子性是指在事务结束时，其中所包含的更新处理要么全部执行，要么完全不执行，也就是要么占有一切要么一无所有。例如，在之前的例子中，在事务结束时，绝对不可能出现运动 T 恤的价格下降了，而 T 恤衫的价格却没有上涨的情况。该事务的结束状态，要么是两者都执行了（COMMIT），要么是两者都未执行（ROLLBACK）。

从事务中途停止的角度去考虑，就能比较容易理解原子性的重要性了。由于用户在一个事务中定义了两条 UPDATE 语句，DBMS 肯定不会只执行其中一条，否则就会对业务处理造成影响。

# KEYWORD

KEYWORD 一致性（Consistency）完整性

# 一致性（Consistency）

一致性指的是事务中包含的处理要满足数据库提前设置的约束，如主键约束或者 NOT NULL 约束等。例如，设置了 NOT NULL 约束的列是不能更新为 NULL 的，试图插入违反主键约束的记录就会出错，无法执行。对事务来说，这些不合法的 SQL 会被回滚。也就是说，这些 SQL 处理会被取消，不会执行。

一致性也称为完整性（图 4- 5）。

图 4-5 保持完整性的流程  
![](https://cdn-mineru.openxlab.org.cn/result/2025-09-10/73f80d02-cbfb-4685-880f-8c0771d72bfe/874c936f6b7512ce0da9bdd9691e61019b3ab526d2f35cd0befb10962e38202c.jpg)  
结束后的状态：只有 2-2 的更新没有被反映到数据库中

# KEYWORD

隔离性（Isolation）

# 隔离性（Isolation）

隔离性指的是保证不同事务之间互不干扰的特性。该特性保证了事务之间不会互相嵌套。此外，在某个事务中进行的更改，在该事务结束之前，对其他事务而言是不可见的。因此，即使某个事务向表中添加了记录，在没有提交之前，其他事务也是看不到新添加的记录的。

# KEYWORD

$\bullet$  持久性（Durability） $\bullet$  日志

# 持久性（Durability）

持久性也可以称为耐久性，指的是在事务（不论是提交还是回滚）结束后，DBMS 能够保证该时间点的数据状态会被保存的特性。即使由于系统故障导致数据丢失，数据库也一定能通过某种手段进行恢复。

如果不能保证持久性，即使是正常提交结束的事务，一旦发生了系统故障，也会导致数据丢失，一切都需要从头再来。

保证持久性的方法根据实现的不同而不同，其中最常见的就是将事务的执行记录保存到硬盘等存储介质中（该执行记录称为日志）。当发生故障时，可以通过日志恢复到故障发生前的状态。

# 练习题

4.1 A 先生在自己的计算机（电脑）上，使用 CREATETABLE 语句创建出了一张空的 Product（商品）表，并执行了如下的 SQL 语句向其中插入数据。

BEGIN TRANSACTION; INSERT INTO Product VALUES ('0001', 'T 恤衫', '衣服', 1000, 500, '2008- 09- 20'); INSERT INTO Product VALUES ('0002', '打孔器', '办公用品', 500, 320, '2008- 09- 11'); INSERT INTO Product VALUES ('0003', '运动 T 恤', '衣服', 4000, 2800, NULL);

表示下一行接续本行，只是由于版面所限而换行。

紧接着，B 先生使用其他的计算机连接上该数据库，执行了如下 SELECT 语句。这时 B 先生能得到怎样的查询结果呢？

SELECT \* FROM Product;

提示：如果可以使用 DELETE 语句，就可以对通过 CREATE TABLE 语句创建出的空表执行该操作了。

4.2 如下所示，有一张包含 3 条记录的 Product 表。

<table><tr><td>商品编号</td><td>商品名称</td><td>商品种类</td><td>销售单价</td><td>进货单价</td><td>登记日期</td></tr><tr><td>0001</td><td>T 恤衫</td><td>衣服</td><td>1000</td><td>500</td><td>2009-09-20</td></tr><tr><td>0002</td><td>打孔器</td><td>办公用品</td><td>500</td><td>320</td><td>2009-09-11</td></tr><tr><td>0003</td><td>运动 T 恤</td><td>衣服</td><td>4000</td><td>2800</td><td></td></tr></table>

使用如下的 INSERT 语句复制这 3 行数据，应该就能够将表中的数据增加为 6 行。请说出该语句的执行结果。

INSERT INTO Product SELECT * FROM Product;

4.3 以练习 4.2 中的 Product 表为基础，再创建另外一张包含利润列的新表 ProductMargin（商品利润）。

- -商品利润表

CREATE TABLE ProductMargin (product_id CHAR (4) NOT NULL, product_name VARCHAR (100) NOT NULL, sale_price INTEGER, purchase_price INTEGER, margin INTEGER, PRIMARY KEY (product_id));

请写出向上述表中插入如下数据的 SQL 语句，其中的利润可以简单地通过对 Product 表中的数据进行计算（销售单价－进货单价）得出。

<table><tr><td>product_id</td><td>product_name</td><td>sale_price</td><td>purchase_price</td><td>margin</td></tr><tr><td>0001</td><td>T 恤衫</td><td>1000</td><td>500</td><td>500</td></tr><tr><td>0002</td><td>打孔器</td><td>500</td><td>320</td><td>180</td></tr><tr><td>0003</td><td>运动 T 恤</td><td>4000</td><td>2800</td><td>1200</td></tr></table>

4.4 对练习 4.3 中的 ProductMargin 表的数据进行如下更改。

1. 将运动 T 恤的销售单价从 4000 日元下调至 3000 日元

2. 根据上述结果再次计算运动 T 恤的利润

更改后的 ProductMargin 表如下所示。请写出能够实现该变更的 SQL 语句。

<table><tr><td>product_id</td><td>product_name</td><td>sale_price</td><td>purchase_price</td><td>margin</td></tr><tr><td>0001</td><td>T 恤衫</td><td>1000</td><td>500</td><td>500</td></tr><tr><td>0002</td><td>打孔器</td><td>500</td><td>320</td><td>180</td></tr></table>